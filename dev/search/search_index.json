{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Async kernel","text":"<p>Async kernel is a Python Jupyter kernel that runs in an anyio event loop.</p> <p>Documentation</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Concurrent message handling</li> <li>Debugger client</li> <li>Configurable backend<ul> <li>Asyncio (default)<ul> <li>uvloop enabled by default<sup>1</sup></li> </ul> </li> <li>trio backend</li> </ul> </li> <li>IPython shell provides:<ul> <li>code execution</li> <li>magic</li> <li>code completions</li> <li>history</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install async-kernel\n</code></pre>"},{"location":"#trio","title":"Trio","text":"<p>To add a kernel spec for <code>trio</code>.</p> <pre><code>pip install trio\nasync-kernel -a async-trio\n</code></pre>"},{"location":"#origin","title":"Origin","text":"<p>Async kernel started as a fork of IPyKernel. Thank you to the original contributors of IPyKernel that made Async kernel possible.</p> <ol> <li> <p>Uvloop is not a dependency of async-kernel but will be used if it has been installed.\u00a0\u21a9</p> </li> </ol>"},{"location":"commands/","title":"Command line","text":"<p><code>async-kernel</code> (and alias <code>async_kernel</code>) is provided on the command line. The main options are:</p> <ul> <li>Add kernel spec</li> <li>Remove a kernel spec</li> <li>Start a kernel</li> </ul>"},{"location":"commands/#add-a-kernel-spec","title":"Add a kernel spec","text":"<p>Use the argument <code>-a</code> followed by the kernel name to add a new kernel spec. Include 'trio' in the kernel name to use a 'trio' backend. Any valid kernel name is allowed (whitespace is not allowed).</p> <p>Recommended kernel names are:</p> <ul> <li>'async': Default kernel that is installed that provides a the default 'asyncio' backend.</li> <li>'async-trio': A trio backend. Note: trio must be installed separately.</li> </ul> <p>Add a trio kernel spec.</p> <pre><code>async-kernel -a async-trio\n</code></pre>"},{"location":"commands/#custom-arguments","title":"Custom arguments","text":"<p>Additional arguments can be included when defining the kernel spec, these include:</p> <ul> <li>Arguments for async_kernel.kernelspec.write_kernel_spec<ul> <li><code>--kernel_factory</code></li> <li><code>--fullpath=False</code></li> <li><code>--display_name</code></li> <li><code>--prefix</code></li> </ul> </li> <li>Nested attributes on the kernel via `kernel.\\' <p>Each parameter should be specified as if it were a 'flag' as follows.</p> <p>Prefix with \"--\" and join with the delimiter \"=\".</p> <pre><code>--&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;=&lt;VALUE&gt;\n</code></pre> <p>or, with compact notation to set a Boolean value as a Boolean flag.</p> <pre><code># True\n--&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;\n\n# False\n--no-&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;\n</code></pre>"},{"location":"commands/#examples","title":"Examples","text":"write_kernel_spec argumentKernel attributeKernel Boolean attribute as a flag <p>kernel_factory</p> <p>To specify an alternate kernel factory.</p> <pre><code>--kernel_factory=my_module.my_kernel_factory\n</code></pre> <p>fullpath (True)</p> <pre><code>--fullpath\n</code></pre> <p>display name</p> <p>To set the kernel display name to <code>True</code>.</p> <pre><code>\"--display_name=My kernel display name\"\n</code></pre> <p>Set the execute request timeout trait on the kernel shell.</p> <pre><code>--shell.execute_request_timeout=0.1\n</code></pre> <p>Set <code>kernel.quiet=True</code>:</p> <pre><code>--quiet \n</code></pre> <p>Set <code>kernel.quiet=False</code>:</p> <pre><code>--no=quiet \n</code></pre>"},{"location":"commands/#remove-a-kernel-spec","title":"Remove a kernel spec","text":"<p>Use the flag <code>-r</code> or <code>--remove</code> to remove a kernelspec.</p> <pre><code>async-kernel\n</code></pre> <p>If you added the custom kernel spec above, you can remove it with:</p> <pre><code>async-kernel -r async-trio-custom\n</code></pre>"},{"location":"commands/#start-a-kernel","title":"Start a kernel","text":"<p>Use the flag <code>-f</code> or <code>--connection_file</code> followed by the full path to the connection file. To skip providing a connection file</p> <p>This will start the default kernel (async).</p> <pre><code>async-kernel -f .\n</code></pre> <p>Additional settings can be passed as arguments.</p> <pre><code>async-kernel -f . --kernel_name=async-trio-custom --display_name='My custom kernel' --quiet=False\n</code></pre> <p>The call above will start a new kernel with a 'trio' backend. The quiet setting is a parameter that gets set on kernel. Parameters of this type are converted using [eval] prior to setting.</p> <p>For further detail, see the API for the command line handler command_line.</p>"},{"location":"about/","title":"About","text":"<ul> <li>Contributing</li> <li>Changelog</li> <li>License</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":""},{"location":"about/changelog/#miscellaneous","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Minimize calls to 'expensive' thread.Event methods #146</li> </ul>"},{"location":"about/changelog/#053-2025-09-27","title":"0.5.3 - 2025-09-27","text":""},{"location":"about/changelog/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Various documentation improvements. #144</li> </ul>"},{"location":"about/changelog/#miscellaneous_1","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.3 #145</p> </li> <li> <p>Tidy up Caller queues and  remove kernel.CancelledError. #143</p> </li> <li> <p>Refactored ReentrantAsyncLock and AsyncLock with a new method 'base'. #142</p> </li> </ul>"},{"location":"about/changelog/#052-2025-09-26","title":"0.5.2 - 2025-09-26","text":""},{"location":"about/changelog/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix debugger #140</li> </ul>"},{"location":"about/changelog/#miscellaneous_2","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.2 #141</p> </li> <li> <p>Refactor Kernel and Subclass Caller from anyio.AsyncContextManagerMixin #139</p> </li> </ul>"},{"location":"about/changelog/#051-2025-09-25","title":"0.5.1 - 2025-09-25","text":""},{"location":"about/changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Take advantage of current_token in utils.wait_thread_event. #136</li> </ul>"},{"location":"about/changelog/#miscellaneous_3","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.1 #138</p> </li> <li> <p>Reinstate test_debugger for windows. #137</p> </li> </ul>"},{"location":"about/changelog/#050-2025-09-24","title":"0.5.0 - 2025-09-24","text":""},{"location":"about/changelog/#breaking-changes","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Simplify queue with breaking changes #134</li> </ul>"},{"location":"about/changelog/#miscellaneous_4","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.5.0 #135</li> </ul>"},{"location":"about/changelog/#040-2025-09-23","title":"0.4.0 - 2025-09-23","text":""},{"location":"about/changelog/#breaking-changes_1","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Revise message handling for comm_msg #129</p> </li> <li> <p>Improve Calller.get_instance to start a caller for the main thread if there isn't one running. #127</p> </li> </ul>"},{"location":"about/changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Make Caller.queue_call and Caller.queue_call_no_wait thread safe #131</p> </li> <li> <p>Add  Caller.get_runner. #126</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_5","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.4.0 #133</p> </li> <li> <p>Maintenance #132</p> </li> <li> <p>Put _send_reply back inside run_handler. #130</p> </li> <li> <p>Prevent memory leaks in caller scheduled futures #128</p> </li> <li> <p>Housekeeping #125</p> </li> </ul>"},{"location":"about/changelog/#030-2025-09-14","title":"0.3.0 - 2025-09-14","text":""},{"location":"about/changelog/#breaking-changes_2","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Caller.queue_call - divide into queue_get_sender, queue_call and queue_call_no_wait. #123</p> </li> <li> <p>Stricter handling in Caller class. #122</p> </li> <li> <p>Add AsyncEvent  class. #118</p> </li> </ul>"},{"location":"about/changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Store Caller.call_later function details in the futures  metadata #119</p> </li> <li> <p>Add metadata to Future. #116</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_6","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.3.0 #124</p> </li> <li> <p>AsyncEvent maintenance - make more robust #120</p> </li> <li> <p>Switch from pytest-retry to pytest-rerun failures. #117</p> </li> <li> <p>Refactor Caller to speed up initialization of Future by removing the creation of the threading event. #115</p> </li> </ul>"},{"location":"about/changelog/#021-2025-09-10","title":"0.2.1 - 2025-09-10","text":""},{"location":"about/changelog/#breaking-changes_3","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Maintenance #105</li> </ul>"},{"location":"about/changelog/#features_3","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Divide Lock into AsyncLock and ReentrantAsyncLock #113</p> </li> <li> <p>Improve Lock class #112</p> </li> <li> <p>Add a context based Lock #111</p> </li> <li> <p>Add classmethod  Caller.wait #106</p> </li> <li> <p>Add 'shield' option to Caller.as_completed. #104</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_7","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.2.1 #114</p> </li> <li> <p>Bump actions/setup-python from 5 to 6 in the actions group #110</p> </li> <li> <p>Maintenance - Caller refactoring #109</p> </li> <li> <p>Drop WaitType for Literals directly in Caller.wait. #108</p> </li> <li> <p>Change Caller._queue_map to a WeakKeyDictionary. #107</p> </li> <li> <p>Refactor Caller.wait to avoid catching  exceptions. #103</p> </li> </ul>"},{"location":"about/changelog/#020-2025-09-06","title":"0.2.0 - 2025-09-06","text":""},{"location":"about/changelog/#breaking-changes_4","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Rename Caller.call_no_context to Caller.call_direct. #100</p> </li> <li> <p>Future - breaking changes- better compatibility of Future.result #96</p> </li> </ul>"},{"location":"about/changelog/#features_4","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Add the classmethod Caller.current_future. #99</p> </li> <li> <p>Add timeout, shield and result optional arguments to Future wait and wait_sync methods: #97</p> </li> <li> <p>Add  optional argument 'msg' to Future.cancel method. #95</p> </li> <li> <p>Support weakref on the Future class. #94</p> </li> </ul>"},{"location":"about/changelog/#documentation_1","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Documentation maintenance. #101</li> </ul>"},{"location":"about/changelog/#miscellaneous_8","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.2.0 #102</p> </li> <li> <p>Result should raise cancelled error, but was raising and InvalidStateError. #98</p> </li> </ul>"},{"location":"about/changelog/#014-2025-09-03","title":"0.1.4 - 2025-09-03","text":""},{"location":"about/changelog/#breaking-changes_5","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Optionally store a string representation of a kernel factory inside the kernel spec. #92</p> </li> <li> <p>Use capital 'V' instead of 'v'  for version flag in command_line. #88</p> </li> </ul>"},{"location":"about/changelog/#documentation_2","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Fix for publish-docs.yml not  setting the version info correctly. #90</p> </li> <li> <p>Include changelog in 'dev' version of docs. #89</p> </li> <li> <p>Development documentation updates and fixes for publish-docs.yml. #87</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_9","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.4 #93</p> </li> <li> <p>Ensure there is only one kernel instance including subclases. #91</p> </li> </ul>"},{"location":"about/changelog/#013-2025-09-02","title":"0.1.3 - 2025-09-02","text":""},{"location":"about/changelog/#features_5","title":"\ud83d\ude80 Features","text":"<ul> <li>Add version option to command line. #82</li> </ul>"},{"location":"about/changelog/#fixes_1","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix bug setting version for mike. #80</li> </ul>"},{"location":"about/changelog/#documentation_3","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update documentation #84</li> </ul>"},{"location":"about/changelog/#miscellaneous_10","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.3 #86</p> </li> <li> <p>Minor import changes. #85</p> </li> <li> <p>Change base class of Kernel from ConnectionFileMixin to HasTraits #83</p> </li> <li> <p>Overwrite subclass properties that should not be available. #81</p> </li> <li> <p>CI checks for python 3.14 #63</p> </li> </ul>"},{"location":"about/changelog/#012-2025-08-31","title":"0.1.2 - 2025-08-31","text":""},{"location":"about/changelog/#breaking-changes_6","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Breaking changes to kernel initialisation and launching #78</p> </li> <li> <p>Enhancement -  Make kernel async enterable. #77</p> </li> </ul>"},{"location":"about/changelog/#documentation_4","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Fix alias for latest docs and limit release versions. #75</li> </ul>"},{"location":"about/changelog/#miscellaneous_11","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.2 #79</p> </li> <li> <p>CI and pre-commit maintenance #76</p> </li> </ul>"},{"location":"about/changelog/#011-2025-08-28","title":"0.1.1 - 2025-08-28","text":""},{"location":"about/changelog/#miscellaneous_12","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.1 #74</p> </li> <li> <p>Bugfixes - fix installing without trio and installing a kernelspec #73</p> </li> </ul>"},{"location":"about/changelog/#010-2025-08-28","title":"0.1.0 - 2025-08-28","text":""},{"location":"about/changelog/#breaking-changes_7","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Caller.queue_call add argument send_nowait  and convert to sync that optionally returns an awaitable. #71</li> </ul>"},{"location":"about/changelog/#features_6","title":"\ud83d\ude80 Features","text":"<ul> <li>Add anyio_backend_options and use uvloop by default #70</li> </ul>"},{"location":"about/changelog/#documentation_5","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Use mike for documentation versioning. #67</p> </li> <li> <p>Update docs, readme and project description. #66</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_13","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0 #72</p> </li> <li> <p>Drop matplotlib dependency. #69</p> </li> </ul>"},{"location":"about/changelog/#010-rc3-2025-08-26","title":"0.1.0-rc3 - 2025-08-26","text":""},{"location":"about/changelog/#features_7","title":"\ud83d\ude80 Features","text":"<ul> <li>Add more classifers and code coverage #64</li> </ul>"},{"location":"about/changelog/#miscellaneous_14","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc3 #65</p> </li> <li> <p>Add workflow_run event because the release is not triggered if  the release is created by another workflow. #62</p> </li> </ul>"},{"location":"about/changelog/#010-rc2-2025-08-26","title":"0.1.0-rc2 - 2025-08-26","text":""},{"location":"about/changelog/#miscellaneous_15","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.1.0-rc2 #61</li> </ul>"},{"location":"about/changelog/#010-rc1-2025-08-26","title":"0.1.0-rc1 - 2025-08-26","text":""},{"location":"about/changelog/#documentation_6","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update licensing and contribution notes #27</li> </ul>"},{"location":"about/changelog/#miscellaneous_16","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc1 #60</p> </li> <li> <p>Merge pull request #56 from fleming79/release/v0.1.0-rc1 #56</p> </li> <li> <p>Revise new release #55</p> </li> <li> <p>New release workflow in one step with publish option. #51</p> </li> <li> <p>Improve release workflow, update documentation and license info. #29</p> </li> <li> <p>Maintenance #26</p> </li> </ul>"},{"location":"about/changelog/#010-rc0-2025-08-24","title":"[0.1.0-rc0] - 2025-08-24","text":""},{"location":"about/changelog/#features_8","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>First release #18</p> </li> <li> <p>Switch to vcs for versioning. #2</p> </li> </ul>"},{"location":"about/changelog/#fixes_2","title":"\ud83d\udc1b Fixes","text":"<ul> <li> <p>Use no-local-version in pyproject.toml instead. #5</p> </li> <li> <p>Use no-local-version on ci. #4</p> </li> </ul>"},{"location":"about/changelog/#documentation_7","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Revise workflow to work with tags that start with 'v'. No longer sets the tag when writing the changelog. #16</p> </li> <li> <p>Switch to python installer to run git cliff. #14</p> </li> <li> <p>Revise changelog template. #12</p> </li> <li> <p>Do changelog as PR instead of push to main. #8</p> </li> <li> <p>Git cliff #7</p> </li> <li> <p>Fix mkdocs publishing #6</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_17","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Bugfix #25</p> </li> <li> <p>Update changelog #24</p> </li> <li> <p>Update changelog #22</p> </li> <li> <p>Release workflow changes #21</p> </li> <li> <p>Update release workflow to use a template that appends output from git-cliff #17</p> </li> <li> <p>Bump the actions group across 1 directory with 2 updates #3</p> </li> </ul>"},{"location":"about/contributing/","title":"Contributing","text":"<p>This project is under active development. Feel free to create an issue to provide feedback.</p>"},{"location":"about/contributing/#development","title":"Development","text":"<p>The development environment is provided by uv using locking and syncing.</p> <p>If you are working on a pull request make a fork of the project and work on the fork.</p> <pre><code>git clone &lt;your fork repository&gt;\ncd async-kernel\n</code></pre> <p>Synchronise the environment.</p> <pre><code>uv venv --python 3.11 # or whichever environment you are targeting.\nuv sync\n# Activate the environment\n</code></pre> <p>Additional steps to build documentation (optional):</p> <pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --shell.execute_request_timeout=0.1\n</code></pre>"},{"location":"about/contributing/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"about/contributing/#running-tests-with-coverage","title":"Running tests with coverage","text":"<p>We intend to maintain 100% code coverage on CI (Linux). The coverage report and badge  are generated with Codecov.</p> <p>You can run tests locally with coverage to see if the test will pass on CI using:</p> <pre><code>uv run pytest -vv --cov --cov-fail-under=100\n</code></pre> Info <p>We are only targeting 100% on linux for &gt;= 3.12 for the following reasons:</p> <ol> <li>linux is the only platform that reliably supports the <code>transport</code> type <code>ipc</code> for zmq sockets which is supported by async kerenel.</li> <li>Coverage on Python 3.11 doesn't correctly gather data for subprocesses giving invalid coverage reports.</li> </ol>"},{"location":"about/contributing/#pre-commit","title":"Pre-commit","text":"<p>Pre-commit runs a number of checks on the code and will also re-format it.</p> <p>Pre-commit will run automatically on submission of a PR but you can also run it locally as a tool with:</p> Changed filesAll files <pre><code>uvx pre-commit run\n</code></pre> <pre><code>uvx pre-commit run -a\n</code></pre>"},{"location":"about/contributing/#type-checking","title":"Type checking","text":"<p>Type checking is performed separately to pre-commit checks. Currently type checking is done using basedpyright. Other type checkers might be added in the future.</p> <pre><code>uv run basedpyright\n</code></pre>"},{"location":"about/contributing/#update-packages","title":"Update packages","text":"<p>To upgrade all packages use the command:</p> <pre><code>uv lock --upgrade\n</code></pre>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is generated from markdown files and the source using Material for MkDocs  and mike for versioning. Publishing of documentation is handled by the automation workflow 'publish-docs.yml'.</p> <p>The 'docs' group specified extra packages are required to build documentation.</p>"},{"location":"about/contributing/#sync-docs-group","title":"Sync 'docs' group","text":"<pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --shell.execute_request_timeout=0.1\n</code></pre>"},{"location":"about/contributing/#test-the-docs","title":"Test the docs","text":"<pre><code>uv run mkdocs build -s\n</code></pre> Info <p>The command:</p> <pre><code>uv run async-kernel -a async-docs --shell.execute_request_timeout=0.1\n</code></pre> <p>defines a new kernel spec with the name \"async-docs\" that sets the <code>shell.execute_request_timeout</code> to 100ms.</p> <p>The \"async-docs\" named kernel spec is used by mkdocs-jupyter to convert the notebooks for inclusion in the usage section of the documentation.</p>"},{"location":"about/contributing/#serve-locally","title":"Serve locally","text":"<pre><code>mkdocs serve \n</code></pre>"},{"location":"about/contributing/#api-docstrings","title":"API / Docstrings","text":"<p>API documentation is included using mkdocstrings.</p> <p>Docstrings are written in docstring format google-notypes. Typing information is included automatically by griff.</p>"},{"location":"about/contributing/#see-also","title":"See also","text":"<ul> <li>cross-referencing</li> </ul>"},{"location":"about/contributing/#notebooks","title":"Notebooks","text":"<p>Notebooks are included in the documentation by the plugin mkdocs-jupyter.</p> <p>Info</p> <p>We use the kernel spec named 'async-docs' which has a cell execute timeout of 100ms. This is used to advance execution through long running cells.</p> <p>The suppress-error tag is inserted in code cells to enable with generating documentation. The symbol '\u26a0' is an indicator that the error was suppressed. Normally this is due to the timeout but there is no distinction on the type of error.</p>"},{"location":"about/contributing/#useful-links","title":"Useful links","text":"<p>These links are not relevant for docstrings.</p> <ul> <li>footnotes</li> <li>tooltips</li> </ul>"},{"location":"about/contributing/#releasing-async-kernel","title":"Releasing Async kernel","text":"<p>To make a new release go to the new_release.yml action and click 'Run workflow'.</p>"},{"location":"about/contributing/#new_releaseyml","title":"new_release.yml","text":"<p>The workflow does the following:</p> <ol> <li>Creates and merges a PR with the updated changelog generated with git-cliff.</li> <li>Starts a new Github release which adds a tag 'v' to the head of the main branch."},{"location":"about/contributing/#publish-to-pypiyml","title":"publish-to-pypi.yml","text":"<p>The publish-to-pypi<sup>1</sup> workflow will start automatically on completion of the \"new_release.yml\". It performs the following steps.</p> <ol> <li>Builds the distribution.</li> <li>Waits for manual approval to release.</li> <li>Uploads the release files to PyPi.</li> <li>Uploads the release files to the Github release.</li> </ol> <p>Once the new PR is available merge the PR into the main branch. Normally this will also trigger publication of the new release.</p>"},{"location":"about/contributing/#publish","title":"Publish","text":"<p>publish-to-pypi.yml is the workflow that publishes the release. It starts on a push to the main branch but can also be manually triggered. It will always publish to TestPyPI on a push. If the git head has a tag starting with 'v' it will also publish to PyPi. If it is published to PyPI successfully, it will also create a Github release.</p>"},{"location":"about/contributing/#run-ci-checks-locally","title":"Run ci checks locally","text":"<p>You can run tests locally to see if there is anything that might be caught by CI.</p> <pre><code>uvx pre-commit run -a\nuv run pytest -vv --cov --cov-fail-under=100\nuv run basedpyright\nuv run mkdocs build -s\n</code></pre> <p>Note</p> <p>CI checks also run for a matrix of OS's and python versions. So even if all tests pass locally, tests can still fail for another os or python version.</p> <ol> <li> <p>This workflow also runs on push to the main branch, but will instead publish to TestPyPI.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Alan Fleming.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished \nto do so, subject to the following conditions:\n\nThe above copyright notice, shall be included in all copies or substantial \nportions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Notebooks<sup>1</sup> in this documentation show the result of each cell after executing for a short duration (~100ms).</p> <p>You can download the notebook with the button at the top right of the page for the notebook.</p> <ol> <li> <p>Further detail about how notebooks are generated is provided here.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebooks/caller/","title":"Caller","text":"<p>To get the caller for the main thread.</p> <p>Ensure you're running an async kernel.</p> In\u00a0[1]: Copied! <pre>%callers\n</pre> %callers <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> In\u00a0[2]: suppress-error Copied! <pre>import random\nimport time\n\nimport ipywidgets as ipw\n\nfrom async_kernel import Caller\n\noutputs = {}\n\n\ndef my_func(n):\n    caller = Caller()\n    if not (out := outputs.get(caller)):\n        outputs[caller] = out = ipw.HTML(description=str(caller))\n        out.style.description_width = \"220px\"\n        display(out)\n    sleep_time = random.random() / 4\n    out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"\n    time.sleep(sleep_time)\n    return n\n\n\nasync def run_forever():\n    n = 0\n    while True:\n        n += 1\n        yield Caller.to_thread(my_func, n)\n\n\nasync for fut in Caller.as_completed(run_forever()):\n    result = await fut\n    print(f\"Finished: {result}\", end=\"\\r\")\n</pre> import random import time  import ipywidgets as ipw  from async_kernel import Caller  outputs = {}   def my_func(n):     caller = Caller()     if not (out := outputs.get(caller)):         outputs[caller] = out = ipw.HTML(description=str(caller))         out.style.description_width = \"220px\"         display(out)     sleep_time = random.random() / 4     out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"     time.sleep(sleep_time)     return n   async def run_forever():     n = 0     while True:         n += 1         yield Caller.to_thread(my_func, n)   async for fut in Caller.as_completed(run_forever()):     result = await fut     print(f\"Finished: {result}\", end=\"\\r\") <pre>HTML(value='', description='Caller&lt;Thread-11 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-9 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220p\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-13 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-15 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-17 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-19 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-23 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-25 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-27 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-21 (async_kernel_caller) \ud83c\udfc3&gt;', style=HTMLStyle(description_width='220\u2026</pre> <pre></pre> In\u00a0[3]: Copied! <pre>%callers\n</pre> %callers <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-9 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-11 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-13 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-15 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-17 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-19 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-21 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-23 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-25 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-27 (async_kernel_caller)\t</pre> <pre>\n</pre>"},{"location":"notebooks/caller/#caller","title":"Caller\u00b6","text":"<p><code>Caller</code> is a class that makes it easy to call code in different threads/tasks.</p> <p>One caller instance is created per thread, and each of those instances can be retrieved by name using the <code>Caller.get_instance</code> class method or in the thread in which it is running simply by <code>Caller()</code>.</p> <p><code>Caller</code> is used by the kernel internally for running code, but can also be used directly by the user. Each caller starts its own iopub zmq socket.</p>"},{"location":"notebooks/caller/#threads","title":"Threads\u00b6","text":"<p>The caller manages a pool of worker threads (not related to anyio worker threads) or you can specify the name of a new thread which you can manage yourself. Each thread has its own anyio event loop in which the code will be called.</p> <p>Most methods that perform execution return an <code>async_kernel.Future</code>.</p>"},{"location":"notebooks/caller/#usage-by-the-kernel","title":"Usage by the kernel\u00b6","text":"<p>The kernel runs two threads; one each for the shell and control. The thread names are 'MainThread' and 'ControlThread' respectively. You can easily get the main thread caller by using the classmethod <code>Caller.get_instance()</code>.</p> <p>kernel uses one of <code>Caller().call_soon</code> <code>Caller.to_thread</code> depending on the header directive</p>"},{"location":"notebooks/caller/#caller-of-the-current-thread","title":"Caller of the current thread\u00b6","text":"<p>To get the caller for the current thread use Caller(). It will raise a Runtime error if the thread doesn't have a running instance.</p>"},{"location":"notebooks/caller/#example","title":"Example\u00b6","text":"<p>This example requires ipywidgets!</p>"},{"location":"notebooks/concurrency/","title":"Concurrency","text":"In\u00a0[1]: Copied! <pre>from async_kernel import utils\nfrom async_kernel.typing import KernelConcurrencyMode, MsgType, RunMode\n\nkernel = utils.get_kernel()\n\nkernel.get_run_mode(MsgType.comm_msg)\n</pre> from async_kernel import utils from async_kernel.typing import KernelConcurrencyMode, MsgType, RunMode  kernel = utils.get_kernel()  kernel.get_run_mode(MsgType.comm_msg) <pre>&lt;RunMode.queue: 'queue'&gt;</pre> <p>The <code>kernel.concurrency_mode</code> will also change the <code>RunMode</code> that is returned by <code>kernel.get_run_mode</code>.</p> In\u00a0[2]: Copied! <pre>kernel.concurrency_mode = KernelConcurrencyMode.blocking\nprint(f\"\"\"\nkernel.concurrency_mode: {kernel.concurrency_mode!s}    \nkernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\")\n\nkernel.concurrency_mode = KernelConcurrencyMode.default\nprint(f\"\"\"\nkernel.concurrency_mode: {kernel.concurrency_mode!s}    \nkernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\")\n</pre> kernel.concurrency_mode = KernelConcurrencyMode.blocking print(f\"\"\" kernel.concurrency_mode: {kernel.concurrency_mode!s}     kernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\")  kernel.concurrency_mode = KernelConcurrencyMode.default print(f\"\"\" kernel.concurrency_mode: {kernel.concurrency_mode!s}     kernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\") <pre>\nkernel.concurrency_mode: blocking    \nkernel.get_run_mode:     blocking</pre> <pre>\n</pre> <pre>\nkernel.concurrency_mode: default    \nkernel.get_run_mode:     queue</pre> <pre>\n</pre> <p>Below is a list of the run modes for the currently available concurrency modes.</p> <p>Note</p> <p>     `blocking` mode is roughly equivalent to how IpyKernel &lt; 7.0 operates.      </p> In\u00a0[3]: Copied! <pre>data = kernel.all_concurrency_run_modes()\ntry:\n    import pandas as pd\nexcept ImportError:\n    print(data)\nelse:\n    data = pd.DataFrame(data)\n    data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")\n    data = data.pivot(index=\"MsgType\", columns=[\"SocketID\", \"KernelConcurrencyMode\"], values=\"RunMode\")  # noqa: PD010\n    display(data)\n</pre> data = kernel.all_concurrency_run_modes() try:     import pandas as pd except ImportError:     print(data) else:     data = pd.DataFrame(data)     data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")     data = data.pivot(index=\"MsgType\", columns=[\"SocketID\", \"KernelConcurrencyMode\"], values=\"RunMode\")  # noqa: PD010     display(data) SocketID shell control KernelConcurrencyMode default blocking default blocking MsgType comm_close blocking blocking blocking blocking comm_info_request blocking blocking blocking blocking comm_msg queue blocking queue blocking comm_open blocking blocking blocking blocking complete_request thread blocking thread blocking debug_request None None blocking blocking execute_request queue blocking task blocking history_request thread blocking thread blocking inspect_request thread blocking thread blocking interrupt_request blocking blocking blocking blocking is_complete_request thread blocking thread blocking kernel_info_request blocking blocking blocking blocking shutdown_request None None blocking blocking In\u00a0[4]: Copied! <pre>async def demo():\n    import threading\n\n    from ipywidgets import Button\n\n    from async_kernel import AsyncEvent, Caller, utils\n\n    print(\"Run mode:\", utils.get_job()[\"run_mode\"])\n\n    print(f\"Thread name: '{threading.current_thread().name}'\")\n    button = Button(description=\"Finish\")\n    event = AsyncEvent()\n    caller = Caller()  # Use caller so the `##thread` example works.\n    # This is because widget messages are received by the shell in the main thread. The event is being waited in this thread.\n    button.on_click(lambda _: caller.call_direct(event.set))\n    display(button)\n    await event.wait()\n    button.close()\n    print(f\"Finished ... thread name: '{threading.current_thread().name}'\")\n    return \"Finished\"\n</pre> async def demo():     import threading      from ipywidgets import Button      from async_kernel import AsyncEvent, Caller, utils      print(\"Run mode:\", utils.get_job()[\"run_mode\"])      print(f\"Thread name: '{threading.current_thread().name}'\")     button = Button(description=\"Finish\")     event = AsyncEvent()     caller = Caller()  # Use caller so the `##thread` example works.     # This is because widget messages are received by the shell in the main thread. The event is being waited in this thread.     button.on_click(lambda _: caller.call_direct(event.set))     display(button)     await event.wait()     button.close()     print(f\"Finished ... thread name: '{threading.current_thread().name}'\")     return \"Finished\" <p>Lets run it normally (queue)</p> In\u00a0[5]: suppress-error Copied! <pre>await demo()\n</pre> await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[6]: suppress-error Copied! <pre>##queue\n# Tip: try running this cell while the previous cell is still busy.\nawait demo()\n</pre> ##queue # Tip: try running this cell while the previous cell is still busy. await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[7]: suppress-error Copied! <pre>RunMode.task  # noqa: B018  # Using the literal `RunMode` values directly is also possible. Though it may show up as a [Flake8 B018 issue](https://docs.astral.sh/ruff/rules/useless-expression/)\nawait demo()\n</pre> RunMode.task  # noqa: B018  # Using the literal `RunMode` values directly is also possible. Though it may show up as a [Flake8 B018 issue](https://docs.astral.sh/ruff/rules/useless-expression/) await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[8]: thread suppress-error Copied! <pre># This time we'll use the tag to run the cell in a Thread\nawait demo()\n</pre> # This time we'll use the tag to run the cell in a Thread await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[9]: Copied! <pre>##thread\n%callers # magic provided by async kernel\n</pre> ##thread %callers # magic provided by async kernel <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-26 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-28 (async_kernel_caller)\t\u2190 current thread</pre> <pre>\n</pre>"},{"location":"notebooks/concurrency/#concurrency","title":"Concurrency\u00b6","text":"<p>Async kernel runs message request with one of the following <code>RunModes</code>.</p> <ul> <li>blocking: Run the handler directly blocking the message loop</li> <li>queue: Run in a queue</li> <li>task: Run in a task</li> <li>thread: Run in a Caller thread</li> </ul> <p>The kernel decides the run mode dynamically with the method [get_run_mode][async_kernel.kernel.Kernel.get_run_mode].</p>"},{"location":"notebooks/concurrency/#execute-request-run-mode","title":"Execute request run mode\u00b6","text":"<p>There are a few options to modify how code cells are run.</p> <ul> <li>Metadata</li> <li>Directly in code</li> <li>tags</li> <li>Message header (in custom messages)</li> </ul> <p>Warning</p> <p>Only Jupyter lab is known to allow concurrent execution of cells.</p>"},{"location":"notebooks/concurrency/#code-for-example","title":"Code for example\u00b6","text":"<ul> <li>This example requires ipywidgets</li> <li>Ensure you are running an async kernel</li> </ul> <p>Lets define a function that we'll reuse for the remainder of the notebook.</p>"},{"location":"notebooks/concurrency/#run-mode-task","title":"Run mode: task\u00b6","text":"<p>The <code>task</code> mode instructs the kernel to execute the code in a task separate to the queue, Both <code>task</code> and <code>thread</code> execute modes can be started when the kernel is busy executing. There is no imposed limitation on the number of tasks (or threads) that can be run concurrently.</p> <p>See also the Caller example on how to call directly.</p>"},{"location":"notebooks/concurrency/#run-mode-thread","title":"Run mode: thread\u00b6","text":""},{"location":"notebooks/simple_example/","title":"Simple example","text":"In\u00a0[1]: Copied! <pre>import ipywidgets as ipw\n\nfrom async_kernel import AsyncEvent, Caller, utils\n\n\nasync def demo():\n    %callers\n    caller = Caller()  # Use caller set the event in the waiting thread\n    b = ipw.Button(description=\"Continue\")\n    display(b)\n    for i in range(1, 3):\n        b.description = f\"Continue {i}\"\n        event = AsyncEvent()\n        b.on_click(lambda _: caller.call_soon(event.set))  # noqa: B023\n        print(f\"Waiting {i}\", end=\"\\r\")\n        await event.wait()\n    b.close()\n    print(\"\\nDone!\")\n</pre> import ipywidgets as ipw  from async_kernel import AsyncEvent, Caller, utils   async def demo():     %callers     caller = Caller()  # Use caller set the event in the waiting thread     b = ipw.Button(description=\"Continue\")     display(b)     for i in range(1, 3):         b.description = f\"Continue {i}\"         event = AsyncEvent()         b.on_click(lambda _: caller.call_soon(event.set))  # noqa: B023         print(f\"Waiting {i}\", end=\"\\r\")         await event.wait()     b.close()     print(\"\\nDone!\") In\u00a0[2]: suppress-error Copied! <pre>print(utils.get_tags())\nawait demo()\n</pre> print(utils.get_tags()) await demo() <pre>[]</pre> <pre>\n</pre> <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[3]: suppress-error Copied! <pre>##task\nawait demo()\n</pre> ##task await demo() <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[4]: suppress-error Copied! <pre>##thread\nawait demo()\n</pre> ##thread await demo() <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-13 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-15 (async_kernel_caller)\t\u2190 current thread</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[5]: suppress-error Copied! <pre>async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):\n    pass\n</pre> async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):     pass <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-13 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-15 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-13 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-15 (async_kernel_caller)\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre>"},{"location":"notebooks/simple_example/#overview","title":"Overview\u00b6","text":"<p>This example demonstrates different ways that the same code can be executed. This is an overview of the four cells shown in the animation below.</p> <ol> <li>Define the coroutine function.<ol> <li>Cell 'magic' <code>%callers</code> prints a list of Caller instances and the thread in which it is executing.</li> <li>A button is created and and it runs a loop twice:<ol> <li>Creates any anyio event.</li> <li>Prints a statement.</li> <li>Waits for the button click to set the event.</li> </ol> </li> </ol> </li> <li>Execute <code>demo</code> normally.</li> <li>Execute <code>demo</code> concurrently in a task.</li> <li>Execute <code>demo</code> in a thread.</li> </ol> <p></p>"},{"location":"notebooks/simple_example/#calleras_completed","title":"Caller.as_completed\u00b6","text":"<p>See also: the caller notebook.</p>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides documentation for each module in async kernel.</p>"},{"location":"reference/#highlights","title":"Highlights","text":"<ul> <li>Caller</li> </ul>"},{"location":"reference/asyncshell/","title":"async_kernel.asyncshell","text":"<p>Classes:</p> <ul> <li> <code>AsyncDisplayHook</code>           \u2013            <p>A displayhook subclass that publishes data using ZeroMQ.</p> </li> <li> <code>AsyncDisplayPublisher</code>           \u2013            <p>A display publisher that publishes data using a ZeroMQ PUB socket.</p> </li> <li> <code>AsyncInteractiveShell</code>           \u2013            <p>An IPython InteractiveShell modified to work with Async kernel.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook","title":"async_kernel.asyncshell.AsyncDisplayHook","text":"<p>               Bases: <code>DisplayHook</code></p> <p>A displayhook subclass that publishes data using ZeroMQ.</p> <p>This is intended to work with an InteractiveShell instance. It sends a dict of different representations of the object.</p> <p>Methods:</p> <ul> <li> <code>start_displayhook</code>             \u2013              <p>Start the display hook.</p> </li> <li> <code>write_output_prompt</code>             \u2013              <p>Write the output prompt.</p> </li> <li> <code>write_format_data</code>             \u2013              <p>Write format data to the message.</p> </li> <li> <code>finish_displayhook</code>             \u2013              <p>Finish up all displayhook activities.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.start_displayhook","title":"start_displayhook","text":"<pre><code>start_displayhook() -&gt; None\n</code></pre> <p>Start the display hook.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef start_displayhook(self) -&gt; None:\n    \"\"\"Start the display hook.\"\"\"\n    self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_output_prompt","title":"write_output_prompt","text":"<pre><code>write_output_prompt() -&gt; None\n</code></pre> <p>Write the output prompt.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_output_prompt(self) -&gt; None:\n    \"\"\"Write the output prompt.\"\"\"\n    self.content[\"execution_count\"] = self.prompt_count\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_format_data","title":"write_format_data","text":"<pre><code>write_format_data(format_dict, md_dict=None) -&gt; None\n</code></pre> <p>Write format data to the message.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_format_data(self, format_dict, md_dict=None) -&gt; None:\n    \"\"\"Write format data to the message.\"\"\"\n    self.content[\"data\"] = format_dict\n    self.content[\"metadata\"] = md_dict\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.finish_displayhook","title":"finish_displayhook","text":"<pre><code>finish_displayhook() -&gt; None\n</code></pre> <p>Finish up all displayhook activities.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef finish_displayhook(self) -&gt; None:\n    \"\"\"Finish up all displayhook activities.\"\"\"\n    if self.content:\n        self.kernel.iopub_send(\"display_data\", content=self.content)\n        self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher","title":"async_kernel.asyncshell.AsyncDisplayPublisher","text":"<p>               Bases: <code>DisplayPublisher</code></p> <p>A display publisher that publishes data using a ZeroMQ PUB socket.</p> <p>Methods:</p> <ul> <li> <code>publish</code>             \u2013              <p>Publish a display-data message.</p> </li> <li> <code>clear_output</code>             \u2013              <p>Clear output associated with the current execution (cell).</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish","title":"publish","text":"<pre><code>publish(\n    data: Content,\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None\n</code></pre> <p>Publish a display-data message.</p> <p>Parameters:</p> <p>Reference</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef publish(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self,\n    data: Content,\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Publish a display-data message.\n\n    Args:\n        data: A mime-bundle dict, keyed by mime-type.\n        metadata: Metadata associated with the data.\n        transient: Transient data that may only be relevant during a live display, such as display_id.\n            Transient data should not be persisted to documents.\n        update: If True, send an update_display_data message instead of display_data.\n\n    [Reference](https://jupyter-client.readthedocs.io/en/stable/messaging.html#update-display-data)\n    \"\"\"\n    utils.get_kernel().iopub_send(\n        msg_or_type=\"update_display_data\" if update else \"display_data\",\n        content={\"data\": data, \"metadata\": metadata or {}, \"transient\": transient or {}} | kwargs,\n        ident=self.topic,\n    )\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(data)","title":"<code>data</code>","text":"(<code>Content</code>)           \u2013            <p>A mime-bundle dict, keyed by mime-type.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(metadata)","title":"<code>metadata</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata associated with the data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(transient)","title":"<code>transient</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Transient data that may only be relevant during a live display, such as display_id. Transient data should not be persisted to documents.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(update)","title":"<code>update</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, send an update_display_data message instead of display_data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output","title":"clear_output","text":"<pre><code>clear_output(wait: bool = False) -&gt; None\n</code></pre> <p>Clear output associated with the current execution (cell).</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef clear_output(self, wait: bool = False) -&gt; None:\n    \"\"\"\n    Clear output associated with the current execution (cell).\n\n    Args:\n        wait: If True, the output will not be cleared immediately,\n            instead waiting for the next display before clearing.\n            This reduces bounce during repeated clear &amp; display loops.\n    \"\"\"\n    utils.get_kernel().iopub_send(msg_or_type=\"clear_output\", content={\"wait\": wait}, ident=self.topic)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output(wait)","title":"<code>wait</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the output will not be cleared immediately, instead waiting for the next display before clearing. This reduces bounce during repeated clear &amp; display loops.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell","title":"async_kernel.asyncshell.AsyncInteractiveShell","text":"<p>               Bases: <code>InteractiveShell</code></p> <p>An IPython InteractiveShell modified to work with Async kernel.</p> <p>Notable differences</p> <ul> <li>All execute requests are run asynchronously.</li> <li> <p>Supports a soft timeout with the metadata {\"timeout\":}<sup>1</sup>. <li> <p>Not all features are support (see \"not-supported\" features listed below).</p> </li> <ol> <li> <p>When the execution time exceeds the timeout value, the code execution will \"move on\".\u00a0\u21a9</p> </li> </ol> <p>Methods:</p> <ul> <li> <code>run_cell_async</code>             \u2013              <p>Run a complete IPython cell asynchronously.</p> </li> <li> <code>init_magics</code>             \u2013              <p>Initialize magics.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>execute_request_timeout</code>           \u2013            <p>A timeout in seconds to complete execute requests.</p> </li> <li> <code>run_cell</code>           \u2013            <p>not-supported</p> </li> <li> <code>loop_runner_map</code>           \u2013            <p>not-supported</p> </li> <li> <code>loop_runner</code>           \u2013            <p>not-supported</p> </li> <li> <code>debug</code>           \u2013            <p>not-supported</p> </li> <li> <code>readline_use</code>           \u2013            <p>not-supported</p> </li> <li> <code>autoindent</code>           \u2013            <p>not-supported</p> </li> <li> <code>kernel</code>               (<code>Kernel</code>)           \u2013            <p>The current kernel.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.execute_request_timeout","title":"execute_request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request_timeout = CFloat(default_value=None, allow_none=True)\n</code></pre> <p>A timeout in seconds to complete execute requests.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.run_cell","title":"run_cell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_cell = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.loop_runner_map","title":"loop_runner_map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loop_runner_map = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.loop_runner","title":"loop_runner  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loop_runner = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.readline_use","title":"readline_use  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>readline_use = False\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.autoindent","title":"autoindent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autoindent = False\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.kernel","title":"kernel  <code>property</code>","text":"<pre><code>kernel: Kernel\n</code></pre> <p>The current kernel.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.run_cell_async","title":"run_cell_async  <code>async</code>","text":"<pre><code>run_cell_async(\n    raw_cell: str,\n    store_history=False,\n    silent=False,\n    shell_futures=True,\n    *,\n    transformed_cell: str | None = None,\n    preprocessing_exc_tuple: tuple | None = None,\n    cell_id: str | None = None,\n) -&gt; ExecutionResult\n</code></pre> <p>Run a complete IPython cell asynchronously.</p> <p>This function runs execute requests for the kernel wrapping InteractiveShell.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\nasync def run_cell_async(\n    self,\n    raw_cell: str,\n    store_history=False,\n    silent=False,\n    shell_futures=True,\n    *,\n    transformed_cell: str | None = None,\n    preprocessing_exc_tuple: tuple | None = None,\n    cell_id: str | None = None,\n) -&gt; ExecutionResult:\n    \"\"\"\n    Run a complete IPython cell asynchronously.\n\n    This function runs [execute requests][async_kernel.Kernel.execute_request] for the kernel\n    wrapping [InteractiveShell][IPython.core.interactiveshell.InteractiveShell.run_cell_async].\n    \"\"\"\n    with anyio.fail_after(delay=utils.get_execute_request_timeout()):\n        result: ExecutionResult = await super().run_cell_async(\n            raw_cell=raw_cell,\n            store_history=store_history,\n            silent=silent,\n            shell_futures=shell_futures,\n            transformed_cell=transformed_cell,\n            preprocessing_exc_tuple=preprocessing_exc_tuple,\n            cell_id=cell_id,\n        )\n    self.events.trigger(\"post_execute\")\n    if not silent:\n        self.events.trigger(\"post_run_cell\", result)\n    return result\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.init_magics","title":"init_magics","text":"<pre><code>init_magics() -&gt; None\n</code></pre> <p>Initialize magics.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef init_magics(self) -&gt; None:\n    \"\"\"Initialize magics.\"\"\"\n    super().init_magics()\n    self.register_magics(KernelMagics)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics","title":"async_kernel.asyncshell.KernelMagics","text":"<p>               Bases: <code>Magics</code></p> <p>Extra magics for async kernel.</p> <p>Methods:</p> <ul> <li> <code>connect_info</code>             \u2013              <p>Print information for connecting other clients to this kernel.</p> </li> <li> <code>callers</code>             \u2013              <p>Print a table of Callers, indicating its status including:  -running - protected - on the current thread.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.connect_info","title":"connect_info","text":"<pre><code>connect_info(_) -&gt; None\n</code></pre> <p>Print information for connecting other clients to this kernel.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef connect_info(self, _) -&gt; None:\n    \"\"\"Print information for connecting other clients to this kernel.\"\"\"\n    kernel = utils.get_kernel()\n    connection_file = pathlib.Path(kernel.connection_file)\n    # if it's in the default dir, truncate to basename\n    if jupyter_runtime_dir() == str(connection_file.parent):\n        connection_file = connection_file.name\n    info = kernel.get_connection_info()\n    print(\n        json.dumps(info, indent=2, default=json_default),\n        \"Paste the above JSON into a file, and connect with:\\n\"\n        + \"    $&gt; jupyter &lt;app&gt; --existing &lt;file&gt;\\n\"\n        + \"or, if you are local, you can connect with just:\\n\"\n        + f\"    $&gt; jupyter &lt;app&gt; --existing {connection_file}\\n\"\n        + \"or even just:\\n\"\n        + \"    $&gt; jupyter &lt;app&gt; --existing\\n\"\n        + \"if this is the most recent Jupyter kernel you have started.\",\n    )\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.callers","title":"callers","text":"<pre><code>callers(_) -&gt; None\n</code></pre> <p>Print a table of Callers, indicating its status including:  -running - protected - on the current thread.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef callers(self, _) -&gt; None:\n    \"Print a table of [Callers][async_kernel.Caller], indicating its status including:  -running - protected - on the current thread.\"\n    lines = [\"\\t\".join([\"Running\", \"Protected\", \"\\t\", \"Name\"]), \"\u2500\" * 70]\n    for caller in Caller.all_callers(running_only=False):\n        symbol = \"   \u2713\" if caller.running else \"   \u2717\"\n        current_thread: Literal[\"\u2190 current thread\", \"\"] = \"\u2190 current thread\" if caller is Caller() else \"\"\n        protected = \"   \ud83d\udd10\" if caller.protected else \"\"\n        lines.append(\"\\t\".join([symbol, protected, \"\", caller.thread.name, current_thread]))\n    print(*lines, sep=\"\\n\")\n</code></pre>"},{"location":"reference/caller/","title":"async_kernel.caller","text":"<p>Classes:</p> <ul> <li> <code>FutureCancelledError</code>           \u2013            <p>Used to indicate a Future is cancelled.</p> </li> <li> <code>InvalidStateError</code>           \u2013            <p>An invalid state of a Future.</p> </li> <li> <code>AsyncEvent</code>           \u2013            <p>An asynchronous thread-safe event compatible with Caller.</p> </li> <li> <code>Future</code>           \u2013            <p>A class representing a future result modelled on asyncio.Future.</p> </li> <li> <code>Caller</code>           \u2013            <p>A class to enable calling functions and coroutines between anyio event loops.</p> </li> <li> <code>ReentrantAsyncLock</code>           \u2013            <p>A Reentrant asynchronous lock compatible with Caller.</p> </li> <li> <code>AsyncLock</code>           \u2013            <p>A mutex asynchronous lock that is compatible with Caller.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.FutureCancelledError","title":"async_kernel.caller.FutureCancelledError","text":"<p>               Bases: <code>ClosedResourceError</code></p> <p>Used to indicate a Future is cancelled.</p>"},{"location":"reference/caller/#async_kernel.caller.InvalidStateError","title":"async_kernel.caller.InvalidStateError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An invalid state of a Future.</p>"},{"location":"reference/caller/#async_kernel.caller.AsyncEvent","title":"async_kernel.caller.AsyncEvent","text":"<pre><code>AsyncEvent(thread: Thread | None = None)\n</code></pre> <p>An asynchronous thread-safe event compatible with Caller.</p> <p>Methods:</p> <ul> <li> <code>wait</code>             \u2013              <p>Wait until the flag has been set.</p> </li> <li> <code>set</code>             \u2013              <p>Set the internal flag to <code>True</code> and trigger notification.</p> </li> <li> <code>is_set</code>             \u2013              <p>Return <code>True</code> if the flag is set, <code>False</code> if not.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __init__(self, thread: threading.Thread | None = None) -&gt; None:\n    self._thread = thread or threading.current_thread()\n    self._events = set()\n    self._flag = False\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.AsyncEvent.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait until the flag has been set.</p> <p>If the flag has already been set when this method is called, it returns immediately.</p> <p>Warning</p> <p>This method requires that a Caller for its target thread. ```</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"\n    Wait until the flag has been set.\n\n    If the flag has already been set when this method is called, it returns immediately.\n\n    !!! warning\n\n        This method requires that a [Caller][async_kernel.caller.Caller] for its target thread.\n        ```\n    \"\"\"\n    if not self._flag:\n\n        def _get_event(event_type: type[T]) -&gt; T | None:\n            for event in self._events:\n                if isinstance(event, event_type):\n                    return event if not self._flag else None\n            event = event_type()\n            self._events.add(event)\n            return event if not self._flag else None\n\n        if self._thread is threading.current_thread():\n            if event := _get_event(anyio.Event):\n                await event.wait()\n        else:\n            if event := _get_event(threading.Event):\n                await wait_thread_event(event)\n    self.set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.AsyncEvent.set","title":"set","text":"<pre><code>set() -&gt; None\n</code></pre> <p>Set the internal flag to <code>True</code> and trigger notification.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set(self) -&gt; None:\n    \"Set the internal flag to `True` and trigger notification.\"\n    self._flag = True\n    while self._events:\n        event = self._events.pop()\n        if isinstance(event, anyio.Event):\n            Caller(thread=self._thread).call_direct(event.set)\n        else:\n            event.set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.AsyncEvent.is_set","title":"is_set","text":"<pre><code>is_set() -&gt; bool\n</code></pre> <p>Return <code>True</code> if the flag is set, <code>False</code> if not.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def is_set(self) -&gt; bool:\n    \"Return `True` if the flag is set, `False` if not.\"\n    return self._flag\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future","title":"async_kernel.caller.Future","text":"<pre><code>Future(thread: Thread | None = None, /, **metadata)\n</code></pre> <p>               Bases: <code>Awaitable[T]</code></p> <p>A class representing a future result modelled on asyncio.Future.</p> <p>This class provides an anyio compatible Future primitive. It is designed to work with <code>Caller</code> to enable thread-safe calling, setting, awaiting and cancelling execution results.</p> <p>Methods:</p> <ul> <li> <code>wait</code>             \u2013              <p>Wait for future to be done (thread-safe) returning the result if specified.</p> </li> <li> <code>set_result</code>             \u2013              <p>Set the result (thread-safe using Caller).</p> </li> <li> <code>set_exception</code>             \u2013              <p>Set the exception (thread-safe using Caller).</p> </li> <li> <code>done</code>             \u2013              <p>Returns True if the Future is done.</p> </li> <li> <code>add_done_callback</code>             \u2013              <p>Add a callback for when the callback is done (not thread-safe).</p> </li> <li> <code>cancel</code>             \u2013              <p>Cancel the Future (thread-safe using Caller).</p> </li> <li> <code>cancelled</code>             \u2013              <p>Return True if the Future is cancelled.</p> </li> <li> <code>result</code>             \u2013              <p>Return the result of the Future.</p> </li> <li> <code>exception</code>             \u2013              <p>Return the exception that was set on the Future.</p> </li> <li> <code>remove_done_callback</code>             \u2013              <p>Remove all instances of a callback from the callbacks list.</p> </li> <li> <code>set_canceller</code>             \u2013              <p>Set a callback to handle cancellation.</p> </li> <li> <code>get_caller</code>             \u2013              <p>The Caller that is running for this futures thread.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dict provided to store metadata with the future.</p> </li> <li> <code>thread</code>               (<code>Thread</code>)           \u2013            <p>The thread to which the future is associated.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __init__(self, thread: threading.Thread | None = None, /, **metadata) -&gt; None:\n    self._done_callbacks = []\n    self._metadata = metadata\n    self._thread = thread = thread or threading.current_thread()\n    self._done = AsyncEvent(thread)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre> <p>A dict provided to store metadata with the future.</p> <p>Info</p> <p>The metadata is used when forming the representation of the future.</p> <p>Example</p> At initOn the instance <pre><code>fut = Future(name=\"My future\")\n</code></pre> <pre><code>fut = Caller().call_soon(anyio.sleep, 0)\nfut.metadata.update(name=\"My future\")\n</code></pre> <p>Tip</p> <p>A <code>future</code> returned by methods of async_kernel.caller.Caller stores the function and call arguments in the futures metedata. It adds a on_set_callback that clears the metadata to avoid memory leaks.</p>"},{"location":"reference/caller/#async_kernel.caller.Future.thread","title":"thread  <code>property</code>","text":"<pre><code>thread: Thread\n</code></pre> <p>The thread to which the future is associated.</p>"},{"location":"reference/caller/#async_kernel.caller.Future.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    *,\n    timeout: float | None = ...,\n    shield: bool = False | ...,\n    result: Literal[True] = True,\n) -&gt; T\n</code></pre><pre><code>wait(*, timeout: float | None = ..., shield: bool = ..., result: Literal[False]) -&gt; None\n</code></pre> <pre><code>wait(\n    *, timeout: float | None = None, shield: bool = False, result: bool = True\n) -&gt; T | None\n</code></pre> <p>Wait for future to be done (thread-safe) returning the result if specified.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def wait(self, *, timeout: float | None = None, shield: bool = False, result: bool = True) -&gt; T | None:\n    \"\"\"\n    Wait for future to be done (thread-safe) returning the result if specified.\n\n    Args:\n        timeout: Timeout in seconds.\n        shield: Shield the future from cancellation.\n        result: Whether the result should be returned.\n    \"\"\"\n    try:\n        if not self.done():\n            with anyio.fail_after(timeout):\n                await self._done.wait()\n        return self.result() if result else None\n    finally:\n        if not self.done() and not shield:\n            self.cancel(\"Cancelled with waiter cancellation.\")\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.wait(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds.</p>"},{"location":"reference/caller/#async_kernel.caller.Future.wait(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield the future from cancellation.</p>"},{"location":"reference/caller/#async_kernel.caller.Future.wait(result)","title":"<code>result</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the result should be returned.</p>"},{"location":"reference/caller/#async_kernel.caller.Future.set_result","title":"set_result","text":"<pre><code>set_result(value: T) -&gt; None\n</code></pre> <p>Set the result (thread-safe using Caller).</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set_result(self, value: T) -&gt; None:\n    \"Set the result (thread-safe using Caller).\"\n    self._set_value(\"result\", value)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.set_exception","title":"set_exception","text":"<pre><code>set_exception(exception: BaseException) -&gt; None\n</code></pre> <p>Set the exception (thread-safe using Caller).</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set_exception(self, exception: BaseException) -&gt; None:\n    \"Set the exception (thread-safe using Caller).\"\n    self._set_value(\"exception\", exception)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.done","title":"done","text":"<pre><code>done() -&gt; bool\n</code></pre> <p>Returns True if the Future is done.</p> <p>Done means either that a result / exception is available.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Returns True if the Future is done.\n\n    Done means either that a result / exception is available.\"\"\"\n    return self._done.is_set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.add_done_callback","title":"add_done_callback","text":"<pre><code>add_done_callback(fn: Callable[[Self], Any]) -&gt; None\n</code></pre> <p>Add a callback for when the callback is done (not thread-safe).</p> <p>If the Future is already done it will be scheduled for calling.</p> <p>The result of the future and done callbacks are always called for the futures thread. Callbacks are called in the reverse order in which they were added in the owning thread.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def add_done_callback(self, fn: Callable[[Self], Any]) -&gt; None:\n    \"\"\"\n    Add a callback for when the callback is done (not thread-safe).\n\n    If the Future is already done it will be scheduled for calling.\n\n    The result of the future and done callbacks are always called for the futures thread.\n    Callbacks are called in the reverse order in which they were added in the owning thread.\n    \"\"\"\n    if not self.done():\n        self._done_callbacks.append(fn)\n    else:\n        self.get_caller().call_direct(fn, self)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; bool\n</code></pre> <p>Cancel the Future (thread-safe using Caller).</p> <p>Note</p> <ul> <li>Cancellation cannot be undone.</li> <li>The future will not be done until set_result or set_excetion is called     in both cases the value is ignore and replaced with a FutureCancelledError     and the result is inaccessible.</li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns if it has been cancelled.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; bool:\n    \"\"\"\n    Cancel the Future (thread-safe using Caller).\n\n    !!! note\n\n        - Cancellation cannot be undone.\n        - The future will not be done until set_result or set_excetion is called\n            in both cases the value is ignore and replaced with a [FutureCancelledError][async_kernel.caller.FutureCancelledError]\n            and the result is inaccessible.\n\n    Args:\n        msg: The message to use when cancelling.\n\n    Returns if it has been cancelled.\n    \"\"\"\n    if not self.done():\n        if msg and isinstance(self._cancelled, str):\n            msg = f\"{self._cancelled}\\n{msg}\"\n        self._cancelled = msg or self._cancelled or True\n        if canceller := self._canceller:\n            if threading.current_thread() is self._thread:\n                canceller(msg)\n            else:\n                Caller(thread=self._thread).call_direct(self.cancel)\n    return self.cancelled()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.cancel(msg)","title":"<code>msg</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The message to use when cancelling.</p>"},{"location":"reference/caller/#async_kernel.caller.Future.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Return True if the Future is cancelled.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Return True if the Future is cancelled.\"\"\"\n    return bool(self._cancelled)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.result","title":"result","text":"<pre><code>result() -&gt; T\n</code></pre> <p>Return the result of the Future.</p> <p>If the Future has been cancelled, this method raises a FutureCancelledError exception.</p> <p>If the Future isn't done yet, this method raises an InvalidStateError exception.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def result(self) -&gt; T:\n    \"\"\"\n    Return the result of the Future.\n\n    If the Future has been cancelled, this method raises a [FutureCancelledError][async_kernel.caller.FutureCancelledError] exception.\n\n    If the Future isn't done yet, this method raises an [InvalidStateError][async_kernel.caller.InvalidStateError] exception.\n    \"\"\"\n    if not self.cancelled() and not self.done():\n        raise InvalidStateError\n    if e := self.exception():\n        raise e\n    return self._result\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.exception","title":"exception","text":"<pre><code>exception() -&gt; BaseException | None\n</code></pre> <p>Return the exception that was set on the Future.</p> <p>If the Future has been cancelled, this method raises a FutureCancelledError exception.</p> <p>If the Future isn't done yet, this method raises an InvalidStateError exception.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def exception(self) -&gt; BaseException | None:\n    \"\"\"\n    Return the exception that was set on the Future.\n\n    If the Future has been cancelled, this method raises a [FutureCancelledError][async_kernel.caller.FutureCancelledError] exception.\n\n    If the Future isn't done yet, this method raises an [InvalidStateError][async_kernel.caller.InvalidStateError] exception.\n    \"\"\"\n    if self._cancelled:\n        raise self._make_cancelled_error()\n    if not self.done():\n        raise InvalidStateError\n    return self._exception\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.remove_done_callback","title":"remove_done_callback","text":"<pre><code>remove_done_callback(fn: Callable[[Self], object]) -&gt; int\n</code></pre> <p>Remove all instances of a callback from the callbacks list.</p> <p>Returns the number of callbacks removed.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def remove_done_callback(self, fn: Callable[[Self], object], /) -&gt; int:\n    \"\"\"\n    Remove all instances of a callback from the callbacks list.\n\n    Returns the number of callbacks removed.\n    \"\"\"\n    n = 0\n    while fn in self._done_callbacks:\n        n += 1\n        self._done_callbacks.remove(fn)\n    return n\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.set_canceller","title":"set_canceller","text":"<pre><code>set_canceller(canceller: Callable[[str | None], Any]) -&gt; None\n</code></pre> <p>Set a callback to handle cancellation.</p> <p>Note</p> <p><code>set_result</code> must still be called to mark the future as completed. You can pass any value as it will be replaced with a async_kernel.caller.FutureCancelledError.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set_canceller(self, canceller: Callable[[str | None], Any]) -&gt; None:\n    \"\"\"\n    Set a callback to handle cancellation.\n\n    !!! note\n\n        `set_result` must still be called to mark the future as completed. You can pass any\n        value as it will be replaced with a [async_kernel.caller.FutureCancelledError][].\n    \"\"\"\n    if self.done() or self._canceller:\n        raise InvalidStateError\n    self._canceller = canceller\n    if self.cancelled():\n        self.cancel()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.get_caller","title":"get_caller","text":"<pre><code>get_caller() -&gt; Caller\n</code></pre> <p>The Caller that is running for this futures thread.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def get_caller(self) -&gt; Caller:\n    \"The [Caller][async_kernel.caller.Caller] that is running for this *futures* thread.\"\n    return Caller(thread=self._thread)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller","title":"async_kernel.caller.Caller","text":"<p>               Bases: <code>AsyncContextManagerMixin</code></p> <p>A class to enable calling functions and coroutines between anyio event loops.</p> <p>The <code>Caller</code> class provides a mechanism to execute functions and coroutines in a dedicated thread, leveraging AnyIO for asynchronous task management. It supports scheduling calls with delays, executing them immediately, and running them without a context.  It also provides a means to manage a pool of threads for general purpose offloading of tasks.</p> <p>The class maintains a registry of instances, associating each with a specific thread. It uses a task group to manage the execution of scheduled tasks and provides methods to start, stop, and query the status of the caller.</p> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>Create or retrieve the <code>Caller</code> instance for the specified thread.</p> </li> <li> <code>get_runner</code>             \u2013              <p>The preferred way to run the caller loop.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the caller, cancelling all pending tasks and close the thread.</p> </li> <li> <code>schedule_call</code>             \u2013              <p>Schedule <code>func</code> to be called inside a task running in the callers thread (thread-safe).</p> </li> <li> <code>call_later</code>             \u2013              <p>Schedule func to be called in caller's event loop copying the current context.</p> </li> <li> <code>call_soon</code>             \u2013              <p>Schedule func to be called in caller's event loop copying the current context.</p> </li> <li> <code>call_direct</code>             \u2013              <p>Schedule <code>func</code> to be called in caller's event loop directly.</p> </li> <li> <code>queue_get</code>             \u2013              <p>Returns Future for <code>func</code> where the queue is running.</p> </li> <li> <code>queue_call</code>             \u2013              <p>Queue the execution of <code>func</code> in a queue unique to it and this caller (thread-safe).</p> </li> <li> <code>queue_close</code>             \u2013              <p>Close the execution queue associated with <code>func</code> (thread-safe).</p> </li> <li> <code>stop_all</code>             \u2013              <p>A classmethod to stop all un-protected callers.</p> </li> <li> <code>get_instance</code>             \u2013              <p>A classmethod that gets the caller associated to the thread using the threads name.</p> </li> <li> <code>to_thread</code>             \u2013              <p>A classmethod to call func in a separate thread see also to_thread_by_name.</p> </li> <li> <code>to_thread_by_name</code>             \u2013              <p>A classmethod to call func in the thread specified by name.</p> </li> <li> <code>start_new</code>             \u2013              <p>A classmethod that creates a new caller instance with the thread determined according to the provided <code>name</code>.</p> </li> <li> <code>current_future</code>             \u2013              <p>A classmethod that returns the current future when called from inside a function scheduled by Caller.</p> </li> <li> <code>all_callers</code>             \u2013              <p>A classmethod to get a list of the callers.</p> </li> <li> <code>as_completed</code>             \u2013              <p>A classmethod iterator to get Futures as they complete.</p> </li> <li> <code>wait</code>             \u2013              <p>A classmethod to wait for the futures given by items to complete.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>MAX_IDLE_POOL_INSTANCES</code>           \u2013            <p>The number of <code>pool</code> instances to leave idle (See also to_thread).</p> </li> <li> <code>log</code>               (<code>LoggerAdapter[Any]</code>)           \u2013            </li> <li> <code>iopub_sockets</code>               (<code>WeakKeyDictionary[Thread, Socket]</code>)           \u2013            </li> <li> <code>iopub_url</code>               (<code>ClassVar</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the thread when the caller was created.</p> </li> <li> <code>thread</code>               (<code>Thread</code>)           \u2013            <p>The thread in which the caller will run.</p> </li> <li> <code>backend</code>               (<code>Backend</code>)           \u2013            <p>The <code>anyio</code> backend the caller is running in.</p> </li> <li> <code>protected</code>               (<code>bool</code>)           \u2013            <p>Returns <code>True</code> if the caller is protected from stopping.</p> </li> <li> <code>running</code>           \u2013            <p>Returns <code>True</code> when the caller is available to run requests.</p> </li> <li> <code>stopped</code>               (<code>bool</code>)           \u2013            <p>Returns  <code>True</code> if the caller is stopped.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller.MAX_IDLE_POOL_INSTANCES","title":"MAX_IDLE_POOL_INSTANCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_IDLE_POOL_INSTANCES = 10\n</code></pre> <p>The number of <code>pool</code> instances to leave idle (See also to_thread).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: LoggerAdapter[Any]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.iopub_sockets","title":"iopub_sockets  <code>class-attribute</code>","text":"<pre><code>iopub_sockets: WeakKeyDictionary[Thread, Socket] = WeakKeyDictionary()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.iopub_url","title":"iopub_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub_url: ClassVar = 'inproc://iopub'\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the thread when the caller was created.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.thread","title":"thread  <code>property</code>","text":"<pre><code>thread: Thread\n</code></pre> <p>The thread in which the caller will run.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: Backend\n</code></pre> <p>The <code>anyio</code> backend the caller is running in.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.protected","title":"protected  <code>property</code>","text":"<pre><code>protected: bool\n</code></pre> <p>Returns <code>True</code> if the caller is protected from stopping.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre> <p>Returns <code>True</code> when the caller is available to run requests.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stopped","title":"stopped  <code>property</code>","text":"<pre><code>stopped: bool\n</code></pre> <p>Returns  <code>True</code> if the caller is stopped.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__","title":"__new__","text":"<pre><code>__new__(\n    *,\n    thread: Thread | None = None,\n    log: LoggerAdapter | None = None,\n    create: bool = False,\n    protected: bool = False,\n) -&gt; Self\n</code></pre> <p>Create or retrieve the <code>Caller</code> instance for the specified thread.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Caller</code> (              <code>Self</code> )          \u2013            <p>The <code>Caller</code> instance for the current thread.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If <code>create</code> is <code>False</code> and a <code>Caller</code> instance does not exist.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __new__(\n    cls,\n    *,\n    thread: threading.Thread | None = None,\n    log: logging.LoggerAdapter | None = None,\n    create: bool = False,\n    protected: bool = False,\n) -&gt; Self:\n    \"\"\"\n    Create or retrieve the `Caller` instance for the specified thread.\n\n    Args:\n        thread: The thread where the caller is based. There is only one instance per thread.\n        log: Logger to use for logging messages.\n        create: Whether to create a new instance if one does not exist for the current thread.\n        protected: Whether the caller is protected from having its event loop closed.\n\n    Returns:\n        Caller: The `Caller` instance for the current thread.\n\n    Raises:\n        RuntimeError: If `create` is `False` and a `Caller` instance does not exist.\n    \"\"\"\n\n    thread = thread or threading.current_thread()\n    if not (inst := cls._instances.get(thread)):\n        if not create:\n            msg = f\"A caller does not exist for{thread=}. Did you mean use the classmethod `Caller.get_instance()`?\"\n            raise RuntimeError(msg)\n        inst = super().__new__(cls)\n        inst._thread = thread\n        inst._name = thread.name\n        inst.log = log or logging.LoggerAdapter(logging.getLogger())\n        inst._jobs = deque()\n        inst._job_added = threading.Event()\n        inst._protected = protected\n        inst._queue_map = {}\n        cls._instances[thread] = inst\n    return inst\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(thread)","title":"<code>thread</code>","text":"(<code>Thread | None</code>, default:                   <code>None</code> )           \u2013            <p>The thread where the caller is based. There is only one instance per thread.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(log)","title":"<code>log</code>","text":"(<code>LoggerAdapter | None</code>, default:                   <code>None</code> )           \u2013            <p>Logger to use for logging messages.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(create)","title":"<code>create</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create a new instance if one does not exist for the current thread.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(protected)","title":"<code>protected</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the caller is protected from having its event loop closed.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_runner","title":"get_runner","text":"<pre><code>get_runner(*, started: Callable[[], None] | None = None)\n</code></pre> <p>The preferred way to run the caller loop.</p> <p>Tip</p> <p>See async_kernel.caller.Caller.get_instance for a usage example.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def get_runner(self, *, started: Callable[[], None] | None = None):\n    \"\"\"The preferred way to run the caller loop.\n\n    !!! tip\n\n        See [async_kernel.caller.Caller.get_instance][] for a usage example.\n    \"\"\"\n    if self.running or self.stopped:\n        raise RuntimeError\n\n    async def run_caller_in_context() -&gt; None:\n        with contextlib.suppress(anyio.get_cancelled_exc_class()):\n            async with self:\n                if started:\n                    started()\n                await anyio.sleep_forever()\n\n    return run_caller_in_context\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop","title":"stop","text":"<pre><code>stop(*, force=False) -&gt; None\n</code></pre> <p>Stop the caller, cancelling all pending tasks and close the thread.</p> <p>If the instance is protected, this is no-op unless force is used.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def stop(self, *, force=False) -&gt; None:\n    \"\"\"\n    Stop the caller, cancelling all pending tasks and close the thread.\n\n    If the instance is protected, this is no-op unless force is used.\n    \"\"\"\n    if self._protected and not force:\n        return\n    self._stopped = True\n    for func in tuple(self._queue_map):\n        self.queue_close(func)\n    self._job_added.set()\n    self._instances.pop(self.thread, None)\n    if self in self._to_thread_pool:\n        self._to_thread_pool.remove(self)\n    if self.thread is not threading.current_thread():\n        self._stopped_event.wait()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call","title":"schedule_call","text":"<pre><code>schedule_call(\n    func: Callable[..., CoroutineType[Any, Any, T] | T],\n    /,\n    args: tuple,\n    kwargs: dict,\n    context: Context | None = None,\n    **metadata: Any,\n) -&gt; Future[T]\n</code></pre> <p>Schedule <code>func</code> to be called inside a task running in the callers thread (thread-safe).</p> <p>The methods call_soon and call_later use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.</p> <p>Parameters:</p> <p>Note</p> <p>All arguments are stored in the future's metadata. When the call is done the metadata is cleared to avoid memory leaks.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def schedule_call(\n    self,\n    func: Callable[..., CoroutineType[Any, Any, T] | T],\n    /,\n    args: tuple,\n    kwargs: dict,\n    context: contextvars.Context | None = None,\n    **metadata: Any,\n) -&gt; Future[T]:\n    \"\"\"\n    Schedule `func` to be called inside a task running in the callers thread (thread-safe).\n\n    The methods [call_soon][async_kernel.caller.Caller.call_soon] and [call_later][async_kernel.caller.Caller.call_later]\n    use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.\n\n    Args:\n        func: The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.\n        args: Arguments corresponding to in the call to  `func`.\n        kwargs: Keyword arguments to use with in the call to `func`.\n        context: The context to use, if not provided the current context is used.\n        metadata: Additional metadata to store in the future.\n\n    !!! note\n\n        All arguments are stored in the future's metadata. When the call is done the\n        metadata is cleared to avoid memory leaks.\n    \"\"\"\n    if self._stopped:\n        raise anyio.ClosedResourceError\n    fut = Future(self.thread, func=func, args=args, kwargs=kwargs, **metadata)\n    fut.add_done_callback(self._on_call_done)\n    self._jobs.append((context or contextvars.copy_context(), fut))\n    self._job_added.set()\n    return fut\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(func)","title":"<code>func</code>","text":"(<code>Callable[..., CoroutineType[Any, Any, T] | T]</code>)           \u2013            <p>The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(args)","title":"<code>args</code>","text":"(<code>tuple</code>)           \u2013            <p>Arguments corresponding to in the call to  <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(kwargs)","title":"<code>kwargs</code>","text":"(<code>dict</code>)           \u2013            <p>Keyword arguments to use with in the call to <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(context)","title":"<code>context</code>","text":"(<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>The context to use, if not provided the current context is used.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(metadata)","title":"<code>metadata</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional metadata to store in the future.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later","title":"call_later","text":"<pre><code>call_later(\n    delay: float,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Future[T]\n</code></pre> <p>Schedule func to be called in caller's event loop copying the current context.</p> <p>Parameters:</p> <p>Info</p> <p>All call arguments are packed into the Futures metadata. The future metadata is cleared when futures result is set.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_later(\n    self,\n    delay: float,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Future[T]:\n    \"\"\"\n    Schedule func to be called in caller's event loop copying the current context.\n\n    Args:\n        func: The function.\n        delay: The minimum delay to add between submission and execution.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    !!! info\n\n        All call arguments are packed into the Futures metadata. The future metadata\n        is cleared when futures result is set.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs, delay=delay, start_time=time.monotonic())\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(delay)","title":"<code>delay</code>","text":"(<code>float</code>)           \u2013            <p>The minimum delay to add between submission and execution.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon","title":"call_soon","text":"<pre><code>call_soon(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Future[T]\n</code></pre> <p>Schedule func to be called in caller's event loop copying the current context.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_soon(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Future[T]:\n    \"\"\"\n    Schedule func to be called in caller's event loop copying the current context.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct","title":"call_direct","text":"<pre><code>call_direct(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; None\n</code></pre> <p>Schedule <code>func</code> to be called in caller's event loop directly.</p> <p>This method is provided to facilitate lightweight thread-safe function calls that need to be performed from within the callers event loop/taskgroup.</p> <p>Parameters:</p> Warning <p>Use this method for lightweight calls only!</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_direct(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"\n    Schedule `func` to be called in caller's event loop directly.\n\n    This method is provided to facilitate lightweight *thread-safe* function calls that\n    need to be performed from within the callers event loop/taskgroup.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    ??? warning\n\n        **Use this method for lightweight calls only!**\n\n    \"\"\"\n    self._jobs.append(functools.partial(func, *args, **kwargs))\n    self._job_added.set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_get","title":"queue_get","text":"<pre><code>queue_get(func: Callable) -&gt; Future[Never] | None\n</code></pre> <p>Returns Future for <code>func</code> where the queue is running.</p> <p>Warning</p> <ul> <li>This future loops forever until the  loop is closed or func no longer exists.</li> <li><code>queue_close</code> is the preferred means to shutdown the queue.</li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_get(self, func: Callable) -&gt; Future[Never] | None:\n    \"\"\"Returns Future for `func` where the queue is running.\n\n    !!! warning\n\n        - This future loops forever until the  loop is closed or func no longer exists.\n        - `queue_close` is the preferred means to shutdown the queue.\n    \"\"\"\n    return self._queue_map.get(hash(func))\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call","title":"queue_call","text":"<pre><code>queue_call(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; None\n</code></pre> <p>Queue the execution of <code>func</code> in a queue unique to it and this caller (thread-safe).</p> <p>The queue executor loop will stay open until one of the following occurs:</p> <ol> <li>The method async_kernel.caller.Caller.queue_close is called with <code>func</code>.</li> <li>If <code>func</code> is a method is deleted and garbage collected (using weakref.finalize).</li> </ol> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_call(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"\n    Queue the execution of `func` in a queue unique to it and this caller (thread-safe).\n\n    The queue executor loop will stay open until one of the following occurs:\n\n    1. The method [async_kernel.caller.Caller.queue_close][] is called with `func`.\n    2. If `func` is a method is deleted and garbage collected (using [weakref.finalize][]).\n\n    Args:\n        func: The function.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n    \"\"\"\n    key = hash(func)\n    if not (fut_ := self._queue_map.get(key)):\n        queue = deque()\n        event_added = threading.Event()\n        with contextlib.suppress(TypeError):\n            weakref.finalize(func.__self__ if inspect.ismethod(func) else func, lambda: self.queue_close(key))\n\n        async def queue_loop(key: int, queue: deque, event_added: threading.Event) -&gt; None:\n            fut = self.current_future()\n            assert fut\n            try:\n                while True:\n                    if not queue:\n                        await wait_thread_event(event_added)\n                    if queue:\n                        context, func_, args, kwargs = queue.popleft()\n                        try:\n                            result = context.run(func_, *args, **kwargs)\n                            if inspect.iscoroutine(object=result):\n                                await result\n                        except (anyio.get_cancelled_exc_class(), Exception) as e:\n                            if fut.cancelled():\n                                raise\n                            self.log.exception(\"Execution %f failed\", func_, exc_info=e)\n                        finally:\n                            func_ = None\n                    else:\n                        event_added.clear()\n            finally:\n                self._queue_map.pop(key)\n\n        self._queue_map[key] = fut_ = self.call_soon(queue_loop, key=key, queue=queue, event_added=event_added)\n    fut_.metadata[\"kwargs\"][\"queue\"].append((contextvars.copy_context(), func, args, kwargs))\n    if len(fut_.metadata[\"kwargs\"][\"queue\"]) == 1:\n        fut_.metadata[\"kwargs\"][\"event_added\"].set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close","title":"queue_close","text":"<pre><code>queue_close(func: Callable | int) -&gt; None\n</code></pre> <p>Close the execution queue associated with <code>func</code> (thread-safe).</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_close(self, func: Callable | int) -&gt; None:\n    \"\"\"\n    Close the execution queue associated with `func` (thread-safe).\n\n    Args:\n        func: The queue of the function to close.\n    \"\"\"\n    key = func if isinstance(func, int) else hash(func)\n    if fut := self._queue_map.pop(key, None):\n        fut.cancel()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close(func)","title":"<code>func</code>","text":"(<code>Callable | int</code>)           \u2013            <p>The queue of the function to close.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop_all","title":"stop_all  <code>classmethod</code>","text":"<pre><code>stop_all(*, _stop_protected: bool = False) -&gt; None\n</code></pre> <p>A classmethod to stop all un-protected callers.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef stop_all(cls, *, _stop_protected: bool = False) -&gt; None:\n    \"\"\"\n    A [classmethod][] to stop all un-protected callers.\n\n    Args:\n        _stop_protected: A private argument to shutdown protected instances.\n    \"\"\"\n    for caller in tuple(reversed(cls._instances.values())):\n        caller.stop(force=_stop_protected)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop_all(_stop_protected)","title":"<code>_stop_protected</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A private argument to shutdown protected instances.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(name: str | None = 'MainThread', *, create: bool = False) -&gt; Self\n</code></pre> <p>A classmethod that gets the caller associated to the thread using the threads name.</p> <p>The default will provide the caller from the MainThread.  If an instance doesn't exist for the main thread an instance will be created and started when the backend provided there is a running event loop.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef get_instance(cls, name: str | None = \"MainThread\", *, create: bool = False) -&gt; Self:\n    \"\"\"\n    A [classmethod][] that gets the caller associated to the thread using the threads name.\n\n\n    The default will provide the caller from the MainThread.  If an instance doesn't exist\n    for the main thread an instance will be created and started when the backend provided\n    there is a running event loop.\n\n    Args:\n        name: The name of the thread where the caller is base. When name is `None`, a new worker thread is created.\n        create: Create a new instance if one with the corresponding name does not already exist.\n    \"\"\"\n    for caller in cls._instances.values():\n        if caller.name == name:\n            return caller\n    if create is True or name == \"MainThread\":\n        return cls.start_new(name=name)\n    msg = f\"A Caller was not found for {name=}.\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_instance(name)","title":"<code>name</code>","text":"(<code>str | None</code>, default:                   <code>'MainThread'</code> )           \u2013            <p>The name of the thread where the caller is base. When name is <code>None</code>, a new worker thread is created.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_instance(create)","title":"<code>create</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create a new instance if one with the corresponding name does not already exist.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread","title":"to_thread  <code>classmethod</code>","text":"<pre><code>to_thread(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Future[T]\n</code></pre> <p>A classmethod to call func in a separate thread see also to_thread_by_name.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef to_thread(\n    cls,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Future[T]:\n    \"\"\"A [classmethod][] to call func in a separate thread see also [to_thread_by_name][async_kernel.Caller.to_thread_by_name].\"\"\"\n    return cls.to_thread_by_name(None, func, *args, **kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name","title":"to_thread_by_name  <code>classmethod</code>","text":"<pre><code>to_thread_by_name(\n    name: str | None,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Future[T]\n</code></pre> <p>A classmethod to call func in the thread specified by name.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Future[T]</code>           \u2013            <p>A future that can be awaited for the  result of func.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef to_thread_by_name(\n    cls,\n    name: str | None,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Future[T]:\n    \"\"\"\n    A [classmethod][] to call func in the thread specified by name.\n\n    Args:\n        name: The name of the `Caller`. A new `Caller` is created if an instance corresponding to name  [^notes].\n\n            [^notes]:  'MainThread' is special name corresponding to the main thread.\n                A `RuntimeError` will be raised if a Caller does not exist for the main thread.\n\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Returns:\n        A future that can be awaited for the  result of func.\n    \"\"\"\n    caller = (\n        cls._to_thread_pool.popleft()\n        if not name and cls._to_thread_pool\n        else cls.get_instance(name=name, create=True)\n    )\n    fut = caller.call_soon(func, *args, **kwargs)\n    if not name:\n        cls._pool_instances.add(caller)\n        cls._busy_worker_threads += 1\n\n        def _to_thread_by_name_on_done(_) -&gt; None:\n            cls._busy_worker_threads -= 1\n            if not caller._stopped:\n                if len(caller._to_thread_pool) + cls._busy_worker_threads &lt; caller.MAX_IDLE_POOL_INSTANCES:\n                    caller._to_thread_pool.append(caller)\n                else:\n                    caller.stop()\n\n        fut.add_done_callback(_to_thread_by_name_on_done)\n    return fut\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(name)","title":"<code>name</code>","text":"(<code>str | None</code>)           \u2013            <p>The name of the <code>Caller</code>. A new <code>Caller</code> is created if an instance corresponding to name  <sup>1</sup>.</p> <ol> <li> <p>'MainThread' is special name corresponding to the main thread. A <code>RuntimeError</code> will be raised if a Caller does not exist for the main thread.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new","title":"start_new  <code>classmethod</code>","text":"<pre><code>start_new(\n    *,\n    name: str | None = None,\n    log: LoggerAdapter | None = None,\n    backend: Backend | NoValue = NoValue,\n    protected: bool = False,\n    backend_options: dict | None | NoValue = NoValue,\n) -&gt; Self\n</code></pre> <p>A classmethod that creates a new caller instance with the thread determined according to the provided <code>name</code>.</p> <p>When <code>name</code> equals the current threads it will use the current thread providing the backend is 'asyncio' and there is a running event loop available.</p> <p>When the name does not match the current thread name, a new thread will be started provided that the name provided is not the name does not overlap with any existing threads. When no name is provided, a new thread can always be started.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Caller</code> (              <code>Self</code> )          \u2013            <p>The newly created caller.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If a caller already exists or when the caller can't be started.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef start_new(\n    cls,\n    *,\n    name: str | None = None,\n    log: logging.LoggerAdapter | None = None,\n    backend: Backend | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    protected: bool = False,\n    backend_options: dict | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n) -&gt; Self:\n    \"\"\"\n    A [classmethod][] that creates a new caller instance with the thread determined according to the provided `name`.\n\n    When `name` equals the current threads it will use the current thread providing the backend is 'asyncio' and\n    there is a running event loop available.\n\n    When the name does not match the current thread name, a new thread will be started provided\n    that the name provided is not the name does not overlap with any existing threads. When no\n    name is provided, a new thread can always be started.\n\n    Args:\n        backend: The backend to use for the anyio event loop (anyio.run). Defaults to the backend from where it is called.\n        log: A logging adapter to use for debug messages.\n        protected: When True, the caller will not shutdown unless shutdown is called with `force=True`.\n        backend_options: Backend options for [anyio.run][]. Defaults to `Kernel.backend_options`.\n\n    Returns:\n        Caller: The newly created caller.\n\n    Raises:\n        RuntimeError: If a caller already exists or when the caller can't be started.\n\n    \"\"\"\n    if name and name in [t.name for t in cls._instances]:\n        msg = f\"A caller already exists with {name=}!\"\n        raise RuntimeError(msg)\n\n    # Current thread\n    if name is not None and name == threading.current_thread().name:\n        if (backend := sniffio.current_async_library()) == Backend.asyncio:\n            loop = asyncio.get_running_loop()\n            caller = cls(log=log, create=True, protected=protected)\n            caller._task = loop.create_task(caller.get_runner()())  # pyright: ignore[reportAttributeAccessIssue]\n            return caller\n        msg = f\"Starting a caller for the MainThread is not supported for {backend=}\"\n        raise RuntimeError(msg)\n\n    # New thread\n    if name and name in [t.name for t in threading.enumerate()]:\n        msg = f\"A thread with {name=} already exists!\"\n        raise RuntimeError(msg)\n\n    def async_kernel_caller() -&gt; None:\n        anyio.run(caller.get_runner(started=ready_event.set), backend=backend_, backend_options=backend_options)\n\n    backend_ = Backend(backend if backend is not NoValue else sniffio.current_async_library())\n    if backend_options is NoValue:\n        backend_options = async_kernel.Kernel().anyio_backend_options.get(backend_)\n    ready_event = threading.Event()\n    thread = threading.Thread(target=async_kernel_caller, name=name or None, daemon=True)\n    caller = cls(thread=thread, log=log, create=True, protected=protected)\n    thread.start()\n    ready_event.wait()\n    return caller\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(backend)","title":"<code>backend</code>","text":"(<code>Backend | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>The backend to use for the anyio event loop (anyio.run). Defaults to the backend from where it is called.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(log)","title":"<code>log</code>","text":"(<code>LoggerAdapter | None</code>, default:                   <code>None</code> )           \u2013            <p>A logging adapter to use for debug messages.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(protected)","title":"<code>protected</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the caller will not shutdown unless shutdown is called with <code>force=True</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(backend_options)","title":"<code>backend_options</code>","text":"(<code>dict | None | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>Backend options for anyio.run. Defaults to <code>Kernel.backend_options</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.current_future","title":"current_future  <code>classmethod</code>","text":"<pre><code>current_future() -&gt; Future[Any] | None\n</code></pre> <p>A classmethod that returns the current future when called from inside a function scheduled by Caller.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef current_future(cls) -&gt; Future[Any] | None:\n    \"\"\"A [classmethod][] that returns the current future when called from inside a function scheduled by Caller.\"\"\"\n    return cls._future_var.get()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers","title":"all_callers  <code>classmethod</code>","text":"<pre><code>all_callers(running_only: bool = True) -&gt; list[Caller]\n</code></pre> <p>A classmethod to get a list of the callers.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef all_callers(cls, running_only: bool = True) -&gt; list[Caller]:\n    \"\"\"\n    A [classmethod][] to get a list of the callers.\n\n    Args:\n        running_only: Restrict the list to callers that are active (running in an async context).\n    \"\"\"\n    return [caller for caller in Caller._instances.values() if caller._running or not running_only]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers(running_only)","title":"<code>running_only</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Restrict the list to callers that are active (running in an async context).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed","title":"as_completed  <code>async</code> <code>classmethod</code>","text":"<pre><code>as_completed(\n    items: Iterable[Future[T]] | AsyncGenerator[Future[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,\n    shield: bool = False,\n) -&gt; AsyncGenerator[Future[T], Any]\n</code></pre> <p>A classmethod iterator to get Futures as they complete.</p> <p>Parameters:</p> <p>Tip</p> <ol> <li>Pass a generator should you wish to limit the number future jobs when calling to_thread/to_task etc.</li> <li>Pass a set/list/tuple to ensure all get monitored at once.</li> </ol> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\nasync def as_completed(\n    cls,\n    items: Iterable[Future[T]] | AsyncGenerator[Future[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    shield: bool = False,\n) -&gt; AsyncGenerator[Future[T], Any]:\n    \"\"\"\n    A [classmethod][] iterator to get [Futures][async_kernel.caller.Future] as they complete.\n\n    Args:\n        items: Either a container with existing futures or generator of Futures.\n        max_concurrent: The maximum number of concurrent futures to monitor at a time.\n            This is useful when `items` is a generator utilising [async_kernel.caller.Caller.to_thread][].\n            By default this will limit to `Caller.MAX_IDLE_POOL_INSTANCES`.\n        shield: Shield existing items from cancellation.\n\n    !!! tip\n\n        1. Pass a generator should you wish to limit the number future jobs when calling to_thread/to_task etc.\n        2. Pass a set/list/tuple to ensure all get monitored at once.\n    \"\"\"\n    event_future_ready = threading.Event()\n    has_result: deque[Future[T]] = deque()\n    futures: set[Future[T]] = set()\n    done = False\n    resume: AsyncEvent | None = cast(\"AsyncEvent | None\", None)\n    current_future = cls.current_future()\n    if isinstance(items, set | list | tuple):\n        max_concurrent_ = 0\n    else:\n        max_concurrent_ = cls.MAX_IDLE_POOL_INSTANCES if max_concurrent is NoValue else int(max_concurrent)\n\n    def _on_done(fut: Future[T]) -&gt; None:\n        has_result.append(fut)\n        if not event_future_ready.is_set():\n            event_future_ready.set()\n\n    async def iter_items():\n        nonlocal done, resume\n        gen = items if isinstance(items, AsyncGenerator) else iter(items)\n        try:\n            while True:\n                fut = await anext(gen) if isinstance(gen, AsyncGenerator) else next(gen)\n                if fut is not current_future:\n                    futures.add(fut)\n                    if fut.done():\n                        has_result.append(fut)\n                        if not event_future_ready.is_set():\n                            event_future_ready.set()\n                    else:\n                        fut.add_done_callback(_on_done)\n                    if max_concurrent_ and len(futures) == max_concurrent_:\n                        resume = AsyncEvent()\n                        await resume.wait()\n        except (StopAsyncIteration, StopIteration):\n            return\n        finally:\n            done = True\n            if not event_future_ready.is_set():\n                event_future_ready.set()\n\n    fut = cls().call_soon(iter_items)\n    try:\n        while futures or not done:\n            if not has_result:\n                await wait_thread_event(event_future_ready)\n            if has_result:\n                fut = has_result.popleft()\n                futures.discard(fut)\n                yield fut\n                if resume:\n                    resume.set()\n            else:\n                event_future_ready.clear()\n\n    finally:\n        fut.cancel()\n        for fut in futures:\n            fut.remove_done_callback(_on_done)\n            if not shield:\n                fut.cancel(\"Cancelled by as_completed\")\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(items)","title":"<code>items</code>","text":"(<code>Iterable[Future[T]] | AsyncGenerator[Future[T]]</code>)           \u2013            <p>Either a container with existing futures or generator of Futures.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(max_concurrent)","title":"<code>max_concurrent</code>","text":"(<code>NoValue | int</code>, default:                   <code>NoValue</code> )           \u2013            <p>The maximum number of concurrent futures to monitor at a time. This is useful when <code>items</code> is a generator utilising async_kernel.caller.Caller.to_thread. By default this will limit to <code>Caller.MAX_IDLE_POOL_INSTANCES</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield existing items from cancellation.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait","title":"wait  <code>async</code> <code>classmethod</code>","text":"<pre><code>wait(\n    items: Iterable[Future[T]],\n    *,\n    timeout: float | None = None,\n    return_when: Literal[\n        \"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"\n    ] = \"ALL_COMPLETED\",\n) -&gt; tuple[set[T], set[Future[T]]]\n</code></pre> <p>A classmethod to wait for the futures given by items to complete.</p> <p>Returns two sets of the futures: (done, pending).</p> <p>Parameters:</p> <p>Example</p> <pre><code>done, pending = await asyncio.wait(items)\n</code></pre> <p>Info</p> <ul> <li>This does not raise a TimeoutError!</li> <li>Futures that aren't done when the timeout occurs are returned in the second set.</li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\nasync def wait(\n    cls,\n    items: Iterable[Future[T]],\n    *,\n    timeout: float | None = None,\n    return_when: Literal[\"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"] = \"ALL_COMPLETED\",\n) -&gt; tuple[set[T], set[Future[T]]]:\n    \"\"\"\n    A [classmethod][] to wait for the futures given by items to complete.\n\n    Returns two sets of the futures: (done, pending).\n\n    Args:\n        items: An iterable of futures to wait for.\n        timeout: The maximum time before returning.\n        return_when: The same options as available for [asyncio.wait][].\n\n    !!! example\n\n        ```python\n        done, pending = await asyncio.wait(items)\n        ```\n\n    !!! info\n\n        - This does not raise a TimeoutError!\n        - Futures that aren't done when the timeout occurs are returned in the second set.\n    \"\"\"\n    done = set()\n    if pending := set(items):\n        with anyio.move_on_after(timeout):\n            async for fut in cls.as_completed(items, shield=True):\n                pending.discard(fut)\n                done.add(fut)\n                if return_when == \"FIRST_COMPLETED\":\n                    break\n                if return_when == \"FIRST_EXCEPTION\" and (fut.cancelled() or fut.exception()):\n                    break\n    return done, pending\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(items)","title":"<code>items</code>","text":"(<code>Iterable[Future[T]]</code>)           \u2013            <p>An iterable of futures to wait for.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum time before returning.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(return_when)","title":"<code>return_when</code>","text":"(<code>Literal['FIRST_COMPLETED', 'FIRST_EXCEPTION', 'ALL_COMPLETED']</code>, default:                   <code>'ALL_COMPLETED'</code> )           \u2013            <p>The same options as available for asyncio.wait.</p>"},{"location":"reference/caller/#async_kernel.caller.ReentrantAsyncLock","title":"async_kernel.caller.ReentrantAsyncLock","text":"<pre><code>ReentrantAsyncLock()\n</code></pre> <p>A Reentrant asynchronous lock compatible with Caller.</p> <p>The lock is reentrant in terms of contextvars.Context.</p> <p>Note</p> <ul> <li>The lock context can be exitied in any order.</li> <li>The context can potentially leak.</li> <li>A 'reentrant' lock can release control to another context and then re-enter later for     tasks or threads called from a locked thread maintaining the same reentrant context.</li> </ul> <p>Methods:</p> <ul> <li> <code>acquire</code>             \u2013              <p>Acquire a lock.</p> </li> <li> <code>release</code>             \u2013              <p>Decrement the internal counter.</p> </li> <li> <code>is_in_context</code>             \u2013              <p>Returns <code>True</code> if the current contextvars.Context has the lock.</p> </li> <li> <code>base</code>             \u2013              <p>Acquire the lock as a new contextvars.Context.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>count</code>               (<code>int</code>)           \u2013            <p>Returns the number of times the locked context has been entered.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __init__(self):\n    self._ctx_var: contextvars.ContextVar[int] = contextvars.ContextVar(f\"Lock:{id(self)}\", default=0)\n    self._queue: deque[tuple[int, Future[bool]]] = deque()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.ReentrantAsyncLock.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>Returns the number of times the locked context has been entered.</p>"},{"location":"reference/caller/#async_kernel.caller.ReentrantAsyncLock.acquire","title":"acquire  <code>async</code>","text":"<pre><code>acquire() -&gt; Self\n</code></pre> <p>Acquire a lock.</p> <p>The internal counter increments when the lock is entered.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def acquire(self) -&gt; Self:\n    \"\"\"\n    Acquire a lock.\n\n    The internal counter increments when the lock is entered.\n    \"\"\"\n    if not self._reentrant and self.is_in_context():\n        msg = \"Already locked and not reentrant!\"\n        raise RuntimeError(msg)\n    # Get the context.\n    if (self._ctx_count == 0) or not self._reentrant or not (ctx := self._ctx_var.get()):\n        self._ctx_count = ctx = self._ctx_count + 1\n        self._ctx_var.set(ctx)\n    # Check if we can lock or re-enter an active lock.\n    if (not self._releasing) and ((not self.count) or (self._reentrant and self.is_in_context())):\n        self._count += 1\n        self._ctx_current = ctx\n        return self\n    # Join the queue.\n    k: tuple[int, Future[bool]] = ctx, Future()\n    self._queue.append(k)\n    try:\n        result = await k[1]\n    finally:\n        if k in self._queue:\n            self._queue.remove(k)\n    if result:\n        self._ctx_current = ctx\n        if self._reentrant:\n            for k in tuple(self._queue):\n                if k[0] == ctx:\n                    self._queue.remove(k)\n                    k[1].set_result(False)\n                    self._count += 1\n        self._releasing = False\n    return self\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.ReentrantAsyncLock.release","title":"release  <code>async</code>","text":"<pre><code>release() -&gt; None\n</code></pre> <p>Decrement the internal counter.</p> <p>If the current depth==1 the lock will be passed to the next queued or released if there isn't one.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def release(self) -&gt; None:\n    \"\"\"\n    Decrement the internal counter.\n\n    If the current depth==1 the lock will be passed to the next queued or released if there isn't one.\n    \"\"\"\n    if self._count == 1 and self._queue and not self._releasing:\n        self._releasing = True\n        self._ctx_var.set(0)\n        self._queue.popleft()[1].set_result(True)\n    else:\n        self._count -= 1\n    if self._count == 0:\n        self._ctx_current = 0\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.ReentrantAsyncLock.is_in_context","title":"is_in_context","text":"<pre><code>is_in_context() -&gt; bool\n</code></pre> <p>Returns <code>True</code> if the current contextvars.Context has the lock.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def is_in_context(self) -&gt; bool:\n    \"Returns `True` if the current [contextvars.Context][] has the lock.\"\n    return bool(self._count and self._ctx_current and (self._ctx_var.get() == self._ctx_current))\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.ReentrantAsyncLock.base","title":"base  <code>async</code>","text":"<pre><code>base() -&gt; AsyncGenerator[Self, Any]\n</code></pre> <p>Acquire the lock as a new contextvars.Context.</p> <p>Use this to ensure exclusive access from within this contextvars.Context.</p> <p>Note</p> <ul> <li>This method is not useful for the mutex variant (async_kernel.caller.AsyncLock) which does this by default.</li> </ul> <p>Warning</p> <p>Using this inside its own acquired lock will cause a deadlock.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@asynccontextmanager\nasync def base(self) -&gt; AsyncGenerator[Self, Any]:\n    \"\"\"\n    Acquire the lock as a new [contextvars.Context][].\n\n    Use this to ensure exclusive access from within this [contextvars.Context][].\n\n    !!! note\n        - This method is not useful for the mutex variant ([async_kernel.caller.AsyncLock][]) which does this by default.\n\n    !!! warning\n        Using this inside its own acquired lock will cause a deadlock.\n    \"\"\"\n    if self._reentrant:\n        self._ctx_var.set(0)\n    async with self:\n        yield self\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.AsyncLock","title":"async_kernel.caller.AsyncLock","text":"<pre><code>AsyncLock()\n</code></pre> <p>               Bases: <code>ReentrantAsyncLock</code></p> <p>A mutex asynchronous lock that is compatible with Caller.</p> <p>Note</p> <ul> <li>Attempting to acquire the lock from inside a locked contextvars.Context will raise a RuntimeError.</li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __init__(self):\n    self._ctx_var: contextvars.ContextVar[int] = contextvars.ContextVar(f\"Lock:{id(self)}\", default=0)\n    self._queue: deque[tuple[int, Future[bool]]] = deque()\n</code></pre>"},{"location":"reference/comm/","title":"async_kernel.comm","text":"<p>Classes:</p> <ul> <li> <code>Comm</code>           \u2013            <p>An implementation of <code>comm.BaseComms</code> for async-kernel  (on pypi).</p> </li> </ul>"},{"location":"reference/comm/#async_kernel.comm.Comm","title":"async_kernel.comm.Comm","text":"<p>               Bases: <code>BaseComm</code></p> <p>An implementation of <code>comm.BaseComms</code> for async-kernel  (on pypi).</p> <p>Note</p> <ul> <li><code>kernel</code> is added/removed by the CommManager.</li> <li><code>kernel</code> is added to the CommManager by the kernel once the sockets have been opened.</li> <li>publish_msg is no-op when kernel is unset.</li> </ul> <p>Methods:</p> <ul> <li> <code>publish_msg</code>             \u2013              <p>Helper for sending a comm message on IOPub.</p> </li> <li> <code>handle_msg</code>             \u2013              <p>Handle a comm_msg message</p> </li> </ul>"},{"location":"reference/comm/#async_kernel.comm.Comm.publish_msg","title":"publish_msg","text":"<pre><code>publish_msg(\n    msg_type: str,\n    data: MaybeDict = None,\n    metadata: MaybeDict = None,\n    buffers: BuffersType = None,\n    **keys,\n)\n</code></pre> <p>Helper for sending a comm message on IOPub.</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef publish_msg(\n    self,\n    msg_type: str,\n    data: MaybeDict = None,\n    metadata: MaybeDict = None,\n    buffers: BuffersType = None,\n    **keys,\n):\n    \"\"\"Helper for sending a comm message on IOPub.\"\"\"\n    if (kernel := self.kernel) is None:\n        # Only send when the kernel is set\n        return\n    content = {\"data\": {} if data is None else data, \"comm_id\": self.comm_id} | keys\n    kernel.iopub_send(\n        msg_or_type=msg_type,\n        content=content,\n        metadata=metadata,\n        parent=None,\n        ident=self.topic,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.Comm.handle_msg","title":"handle_msg","text":"<pre><code>handle_msg(msg: MessageType) -&gt; None\n</code></pre> <p>Handle a comm_msg message</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef handle_msg(self, msg: comm.base_comm.MessageType) -&gt; None:\n    \"\"\"Handle a comm_msg message\"\"\"\n    if self._msg_callback:\n        self._msg_callback(msg)\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.CommManager","title":"async_kernel.comm.CommManager","text":"<pre><code>CommManager()\n</code></pre> <p>               Bases: <code>HasTraits</code>, <code>CommManager</code></p> <p>The comm manager for all Comm instances.</p> <p>Note</p> <ul> <li>When the trait <code>CommManager.kernel</code> is set the <code>Comm.kernel</code> trait is set on all async_kernel.comm.Comm instances.</li> <li>The <code>Comm</code> will only send messages when the kernel is set.</li> <li>The <code>kernel</code> sets <code>CommManager.kernel</code> when its ready the iopub socket is open.</li> </ul> <p>Methods:</p> <ul> <li> <code>register_comm</code>             \u2013              <p>Register a new comm</p> </li> </ul> Source code in <code>src/async_kernel/comm.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.CommManager.register_comm","title":"register_comm","text":"<pre><code>register_comm(comm: BaseComm) -&gt; str\n</code></pre> <p>Register a new comm</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef register_comm(self, comm: comm.base_comm.BaseComm) -&gt; str:\n    \"\"\"Register a new comm\"\"\"\n    if isinstance(comm, Comm) and (kernel := self.kernel):\n        comm.kernel = kernel\n    return super().register_comm(comm)\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.set_comm","title":"async_kernel.comm.set_comm","text":"<pre><code>set_comm()\n</code></pre> <p>Monkey patch the comm module's functions to provide iopub comms.</p> <ol> <li><code>comm.create_comm</code> to async_kernel.comm.Comm.</li> <li><code>comm.get_com_manager</code> to async_kernel.comm.CommManager.</li> </ol> Source code in <code>src/async_kernel/comm.py</code> <pre><code>def set_comm():\n    \"\"\"\n    Monkey patch the [comm](https://pypi.org/project/comm/) module's functions to provide iopub comms.\n\n    1.  `comm.create_comm` to [async_kernel.comm.Comm][].\n    1. `comm.get_com_manager` to [async_kernel.comm.CommManager][].\n    \"\"\"\n    comm.create_comm = Comm\n    comm.get_comm_manager = get_comm_manager\n</code></pre>"},{"location":"reference/command/","title":"async_kernel.command","text":"<p>Functions:</p> <ul> <li> <code>command_line</code>             \u2013              <p>Parses command-line arguments to manage kernel specs and start kernels.</p> </li> </ul>"},{"location":"reference/command/#async_kernel.command.command_line","title":"async_kernel.command.command_line","text":"<pre><code>command_line(wait_exit_context: Callable[[], Awaitable] = sleep_forever) -&gt; None\n</code></pre> <p>Parses command-line arguments to manage kernel specs and start kernels.</p> <p>This function uses <code>argparse</code> to handle command-line arguments for various kernel operations, including:</p> <ul> <li>Starting a kernel with a specified connection file.</li> <li>Adding a new kernel specification.</li> <li>Removing an existing kernel specification.</li> <li>Print version.</li> </ul> <p>The function determines the appropriate action based on the provided arguments and either starts a kernel, adds a kernel spec, or removes a kernel spec.  If no connection file is provided and no other action is specified, it prints the help message.</p> <p>When starting a kernel, it imports the specified kernel factory (or uses the default <code>Kernel</code> class) and configures the kernel instance with the provided arguments. It then starts the kernel within an <code>anyio</code> context, handling keyboard interrupts and other exceptions.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>If an error occurs during kernel execution or if the program is interrupted.</p> </li> </ul> Source code in <code>src/async_kernel/command.py</code> <pre><code>def command_line(wait_exit_context: Callable[[], Awaitable] = anyio.sleep_forever) -&gt; None:\n    \"\"\"\n    Parses command-line arguments to manage kernel specs and start kernels.\n\n    This function uses `argparse` to handle command-line arguments for\n    various kernel operations, including:\n\n    - Starting a kernel with a specified connection file.\n    - Adding a new kernel specification.\n    - Removing an existing kernel specification.\n    - Print version.\n\n    The function determines the appropriate action based on the provided\n    arguments and either starts a kernel, adds a kernel spec, or removes\n    a kernel spec.  If no connection file is provided and no other action\n    is specified, it prints the help message.\n\n    When starting a kernel, it imports the specified kernel factory (or uses\n    the default `Kernel` class) and configures the kernel instance with\n    the provided arguments. It then starts the kernel within an `anyio`\n    context, handling keyboard interrupts and other exceptions.\n\n    Args:\n        wait_exit_context: An optional asynchronous function or context manager\n            that determines how long the kernel should run. Defaults to\n            `anyio.sleep_forever`, which keeps the kernel running indefinitely\n            until an external signal is received.\n\n    Raises:\n        SystemExit: If an error occurs during kernel execution or if the\n            program is interrupted.\n    \"\"\"\n    title = \"Async kernel\"\n    kernel_dir: Path = get_kernel_dir()\n    parser = argparse.ArgumentParser(\n        description=\"=\" * len(title)\n        + f\"\\n{title}\\n\"\n        + \"=\" * len(title)\n        + \"\\n\\n\"\n        + \"With the async-kernel command line tool you can:\\n\\n\"\n        + \"    - Add/remove kernel specs\\n\"\n        + \"    - start kernels\\n\\n\"\n        + \"Online help: https://fleming79.github.io/async-kernel/latest/commands/#command-line \\n\\n\"\n        + f\"Jupyter kernel directory: '{kernel_dir}'\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--connection_file\",\n        dest=\"connection_file\",\n        help=\"Start a kernel with a connection file. To start a kernel without a file use a period `.`.\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--add\",\n        dest=\"add\",\n        help=f\"Add a kernel spec. Default kernel names are: {list(map(str, KernelName))}.\\n\"\n        + \"To specify a 'trio' backend, include 'trio' in the name. Other options are also permitted. See: `write_kernel_spec` for detail.\",\n    )\n    kernels = [] if not kernel_dir.exists() else [item.name for item in kernel_dir.iterdir() if item.is_dir()]\n    parser.add_argument(\n        \"-r\",\n        \"--remove\",\n        dest=\"remove\",\n        help=f\"Remove existing kernel specs. Installed kernels: {kernels}.\",\n    )\n    parser.add_argument(\n        \"-V\",\n        \"--version\",\n        dest=\"version\",\n        help=\"Print version\",\n        action=\"store_true\",\n    )\n    args, unknownargs = parser.parse_known_args()\n    cl_names = set(vars(args))\n\n    # Convert unknownargs from flags to mappings\n    for v in (v.lstrip(\"-\") for v in unknownargs):\n        if \"=\" in v:\n            k, v_ = v.split(\"=\", maxsplit=1)\n            setattr(args, k, v_.strip(\"'\\\"\").strip())\n        else:\n            # https://docs.python.org/3/library/argparse.html#argparse.BooleanOptionalAction\n            setattr(args, v.removeprefix(\"no-\"), False) if v.startswith(\"no-\") else setattr(args, v, True)\n\n    # Add kernel spec\n    if args.add:\n        if not hasattr(args, \"kernel_name\"):\n            args.kernel_name = args.add\n        for name in cl_names:\n            delattr(args, name)\n        path = write_kernel_spec(**vars(args))\n        print(f\"Added kernel spec {path!s}\")\n\n    # Remove kernel spec\n    elif args.remove:\n        for name in args.remove.split(\",\"):\n            msg = \"removed\" if remove_kernel_spec(name) else \"not found!\"\n            print(f\"Kernel spec: '{name}' {msg}\")\n\n    # Version\n    elif args.version:\n        print(\"async-kernel\", async_kernel.__version__)\n\n    # Start kernel\n    elif args.connection_file:\n        settings = vars(args)\n        for k in cl_names.difference([\"connection_file\"]):\n            settings.pop(k, None)\n        if settings.get(\"connection_file\") in {None, \"\", \".\"}:\n            settings.pop(\"connection_file\", None)\n        factory: KernelFactoryType = import_kernel_factory(getattr(args, \"kernel_factory\", \"\"))\n        kernel: Kernel = factory(settings)\n\n        async def _start() -&gt; None:\n            async with kernel:\n                with contextlib.suppress(anyio.get_cancelled_exc_class()):\n                    await wait_exit_context()\n\n        try:\n            backend = Backend.trio if \"trio\" in kernel.kernel_name.lower() else Backend.asyncio\n            anyio.run(_start, backend=backend, backend_options=kernel.anyio_backend_options.get(backend))\n        except KeyboardInterrupt:\n            pass\n        except BaseException as e:\n            traceback.print_exception(e, file=sys.stderr)\n            if sys.__stderr__ is not sys.stderr:\n                traceback.print_exception(e, file=sys.__stderr__)\n            sys.exit(1)\n        else:\n            sys.exit(0)\n\n    # Print help\n    else:\n        parser.print_help()\n</code></pre>"},{"location":"reference/command/#async_kernel.command.command_line(wait_exit_context)","title":"<code>wait_exit_context</code>","text":"(<code>Callable[[], Awaitable]</code>, default:                   <code>sleep_forever</code> )           \u2013            <p>An optional asynchronous function or context manager that determines how long the kernel should run. Defaults to <code>anyio.sleep_forever</code>, which keeps the kernel running indefinitely until an external signal is received.</p>"},{"location":"reference/kernel/","title":"async_kernel.kernel","text":"<p>Classes:</p> <ul> <li> <code>KernelInterruptError</code>           \u2013            <p>Raised to interrupt the kernel.</p> </li> <li> <code>Kernel</code>           \u2013            <p>An asynchronous kernel with an anyio backend providing an IPython AsyncInteractiveShell with zmq sockets.</p> </li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.KernelInterruptError","title":"async_kernel.kernel.KernelInterruptError","text":"<p>               Bases: <code>InterruptedError</code></p> <p>Raised to interrupt the kernel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel","title":"async_kernel.kernel.Kernel","text":"<pre><code>Kernel(settings: dict | None = None)\n</code></pre> <p>               Bases: <code>HasTraits</code></p> <p>An asynchronous kernel with an anyio backend providing an IPython AsyncInteractiveShell with zmq sockets.</p> <p>Only one instance will be created/run at a time. The instance can be obtained with <code>Kernel()</code> or [async_kernel.utils.get_kernel].</p> <p>To start the kernel:</p> ShellNormalstart (<code>classmethod</code>)Asynchronously inside anyio event loop <p>At the command prompt.</p> <pre><code>async-kernel -f .\n</code></pre> <p>See also:</p> <p>-</p> <pre><code>from async_kernel.__main__ import main\n\nmain()\n</code></pre> <pre><code>Kernel.start()\n</code></pre> <pre><code>kernel = Kernel()\nasync with kernel:\n    await anyio.sleep_forever()\n</code></pre> Tip <p>This is a convenient way to start a kernel for debugging.</p> <p>Origins: IPyKernel Kernel, IPyKernel IPKernelApp &amp;  IPyKernel IPythonKernel</p> <p>Methods:</p> <ul> <li> <code>load_connection_info</code>             \u2013              <p>Load connection info from a dict containing connection info.</p> </li> <li> <code>__aenter__</code>             \u2013              <p>Start the kernel.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the running kernel.</p> </li> <li> <code>handle_message_request</code>             \u2013              <p>The main handler for all shell and control messages.</p> </li> <li> <code>get_run_mode</code>             \u2013              <p>Determine the run mode for a given channel, message type and concurrency mode.</p> </li> <li> <code>all_concurrency_run_modes</code>             \u2013              <p>Generates a dictionary containing all combinations of SocketID, KernelConcurrencyMode, and MsgType,</p> </li> <li> <code>run_handler</code>             \u2013              <p>Runs the handler in the context of the job/message sending the reply content if it is provided.</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send a message on the zmq iopub socket.</p> </li> <li> <code>topic</code>             \u2013              <p>prefixed topic for IOPub messages.</p> </li> <li> <code>kernel_info_request</code>             \u2013              <p>Handle a kernel info request.</p> </li> <li> <code>comm_info_request</code>             \u2013              <p>Handle a comm info request.</p> </li> <li> <code>execute_request</code>             \u2013              <p>Handle a execute request.</p> </li> <li> <code>complete_request</code>             \u2013              <p>Handle a completion request.</p> </li> <li> <code>is_complete_request</code>             \u2013              <p>Handle a is_complete request.</p> </li> <li> <code>inspect_request</code>             \u2013              <p>Handle a inspect request.</p> </li> <li> <code>history_request</code>             \u2013              <p>Handle a history request.</p> </li> <li> <code>comm_open</code>             \u2013              <p>Handle a comm open request.</p> </li> <li> <code>comm_msg</code>             \u2013              <p>Handle a comm msg request.</p> </li> <li> <code>comm_close</code>             \u2013              <p>Handle a comm close request.</p> </li> <li> <code>interrupt_request</code>             \u2013              <p>Handle a interrupt request (control only).</p> </li> <li> <code>shutdown_request</code>             \u2013              <p>Handle a shutdown request (control only).</p> </li> <li> <code>debug_request</code>             \u2013              <p>Handle a debug request (control only).</p> </li> <li> <code>excepthook</code>             \u2013              <p>Handle an exception.</p> </li> <li> <code>unraisablehook</code>             \u2013              <p>Handle unraisable exceptions (during gc for instance).</p> </li> <li> <code>raw_input</code>             \u2013              <p>Forward raw_input to frontends.</p> </li> <li> <code>getpass</code>             \u2013              <p>Forward getpass to frontends.</p> </li> <li> <code>get_connection_info</code>             \u2013              <p>Return the connection info as a dict.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>anyio_backend</code>           \u2013            </li> <li> <code>anyio_backend_options</code>               (<code>Dict[Backend, dict[str, Any] | None]</code>)           \u2013            <p>Default options to use with anyio.run. See also: <code>Kernel.handle_message_request</code></p> </li> <li> <code>concurrency_mode</code>           \u2013            <p>The mode to use when getting the run mode for running the handler of a message request.</p> </li> <li> <code>help_links</code>           \u2013            </li> <li> <code>quiet</code>           \u2013            <p>Only send stdout/stderr to output stream</p> </li> <li> <code>connection_file</code>               (<code>TraitType[Path, Path | str]</code>)           \u2013            <p>JSON file in which to store connection info [default: kernel-.json] <li> <code>kernel_name</code>               (<code>str | Unicode</code>)           \u2013            <p>The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.</p> </li> <li> <code>ip</code>           \u2013            <p>The kernel's IP address [default localhost].</p> </li> <li> <code>log</code>           \u2013            </li> <li> <code>shell</code>           \u2013            </li> <li> <code>session</code>           \u2013            </li> <li> <code>debugger</code>           \u2013            </li> <li> <code>comm_manager</code>               (<code>Instance[CommManager]</code>)           \u2013            </li> <li> <code>event_started</code>           \u2013            <p>An event that occurs when the kernel is started.</p> </li> <li> <code>event_stopped</code>           \u2013            <p>An event that occurs when the kernel is stopped.</p> </li> <li> <code>execution_count</code>               (<code>int</code>)           \u2013            <p>The execution count in context of the current coroutine, else the current value if there isn't one in context.</p> </li> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def __init__(self, settings: dict | None = None, /) -&gt; None:\n    if self._initialised:\n        return  # Only initialize once\n    assert threading.current_thread() is threading.main_thread(), \"The kernel must start in the main thread.\"\n    self._initialised = True\n    super().__init__()\n    sys.excepthook = self.excepthook\n    sys.unraisablehook = self.unraisablehook\n    signal.signal(signal.SIGINT, self._signal_handler)\n    if not os.environ.get(\"MPLBACKEND\"):\n        os.environ[\"MPLBACKEND\"] = \"module://matplotlib_inline.backend_inline\"\n    # setting get loaded in `_validate_settings`\n    assert self.shell, \"The shell should be loaded here.\"\n    self._settings = settings or {}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.anyio_backend","title":"anyio_backend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anyio_backend = UseEnum(Backend)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.anyio_backend_options","title":"anyio_backend_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anyio_backend_options: Dict[Backend, dict[str, Any] | None] = Dict(allow_none=True)\n</code></pre> <p>Default options to use with anyio.run. See also: <code>Kernel.handle_message_request</code></p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.concurrency_mode","title":"concurrency_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>concurrency_mode = UseEnum(KernelConcurrencyMode)\n</code></pre> <p>The mode to use when getting the run mode for running the handler of a message request.</p> See also <ul> <li>async_kernel.Kernel.handle_message_request</li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.help_links","title":"help_links  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help_links = Tuple()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.quiet","title":"quiet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quiet = Bool(True)\n</code></pre> <p>Only send stdout/stderr to output stream</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.connection_file","title":"connection_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection_file: TraitType[Path, Path | str] = TraitType()\n</code></pre> <p>JSON file in which to store connection info [default: kernel-.json] <p>This file will contain the IP, ports, and authentication key needed to connect clients to this kernel. By default, this file will be created in the security dir of the current profile, but can be specified by absolute path.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_name","title":"kernel_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_name: str | Unicode = Unicode()\n</code></pre> <p>The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.ip","title":"ip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ip = Unicode()\n</code></pre> <p>The kernel's IP address [default localhost].</p> <p>If the IP address is something other than localhost, then Consoles on other machines  will be able to connect to the Kernel, so be careful!</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log = Instance(LoggerAdapter)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = Instance(AsyncInteractiveShell, ())\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session = Instance(Session, ())\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debugger","title":"debugger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debugger = Instance(Debugger, ())\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_manager","title":"comm_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_manager: Instance[CommManager] = Instance('async_kernel.comm.CommManager')\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.event_started","title":"event_started  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_started = Instance(AsyncEvent, (), read_only=True)\n</code></pre> <p>An event that occurs when the kernel is started.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.event_stopped","title":"event_stopped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_stopped = Instance(AsyncEvent, (), read_only=True)\n</code></pre> <p>An event that occurs when the kernel is stopped.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execution_count","title":"execution_count  <code>property</code>","text":"<pre><code>execution_count: int\n</code></pre> <p>The execution count in context of the current coroutine, else the current value if there isn't one in context.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_connection_info","title":"load_connection_info","text":"<pre><code>load_connection_info(info: dict[str, Any]) -&gt; None\n</code></pre> <p>Load connection info from a dict containing connection info.</p> <p>Typically this data comes from a connection file and is called by load_connection_file.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Load connection info from a dict containing connection info.\n\n    Typically this data comes from a connection file\n    and is called by load_connection_file.\n\n    Args:\n        info: Dictionary containing connection_info. See the connection_file spec for details.\n    \"\"\"\n    if self._ports:\n        msg = \"Connection info is already loaded!\"\n        raise RuntimeError(msg)\n    self.transport = info.get(\"transport\", self.transport)\n    self.ip = info.get(\"ip\") or self.ip\n    for socket in SocketID:\n        name = f\"{socket}_port\"\n        if socket not in self._ports and name in info:\n            self._ports[socket] = info[name]\n    if \"key\" in info:\n        key = info[\"key\"]\n        if isinstance(key, str):\n            key = key.encode()\n        assert isinstance(key, bytes)\n\n        self.session.key = key\n    if \"signature_scheme\" in info:\n        self.session.signature_scheme = info[\"signature_scheme\"]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_connection_info(info)","title":"<code>info</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary containing connection_info. See the connection_file spec for details.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Start the kernel.</p> <ul> <li>Only one instance can (should) run at a time.</li> <li>An instance can only be started once.</li> <li>A new instance can be started after a previous instance has stopped.</li> </ul> <p>Example</p> <pre><code>async with Kerne() as kernel:\n    await anyio.sleep_forever()\n</code></pre> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"\n    Start the kernel.\n\n    - Only one instance can (should) run at a time.\n    - An instance can only be started once.\n    - A new instance can be started after a previous instance has stopped.\n\n    !!! example\n\n        ```python\n        async with Kerne() as kernel:\n            await anyio.sleep_forever()\n        ```\n    \"\"\"\n    async with contextlib.AsyncExitStack() as stack:\n        self._running = True\n        await stack.enter_async_context(self._start_in_context())\n        self.__stack = stack.pop_all()\n    return self\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.stop","title":"stop  <code>staticmethod</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the running kernel.</p> <p>Once a kernel is stopped; that instance of the kernel cannot be restarted. Instead, a new kernel must be started.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>@staticmethod\ndef stop() -&gt; None:\n    \"\"\"\n    Stop the running kernel.\n\n    Once a kernel is stopped; that instance of the kernel cannot be restarted.\n    Instead, a new kernel must be started.\n    \"\"\"\n    if instance := Kernel._instance:\n        Kernel._instance = None\n        instance.event_stopped.set()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.handle_message_request","title":"handle_message_request  <code>async</code>","text":"<pre><code>handle_message_request(job: Job) -&gt; None\n</code></pre> <p>The main handler for all shell and control messages.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def handle_message_request(self, job: Job, /) -&gt; None:\n    \"\"\"\n    The main handler for all shell and control messages.\n\n    Args:\n        job: The packed [message][async_kernel.typing.Message] for handling.\n    \"\"\"\n    try:\n        msg_type = MsgType(job[\"msg\"][\"header\"][\"msg_type\"])\n        socket_id = job[\"socket_id\"]\n        handler = self.get_handler(msg_type)\n    except (ValueError, TypeError):\n        self.log.debug(\"Invalid job %s\", job)\n        return\n    run_mode = self.get_run_mode(msg_type, socket_id=socket_id, job=job)\n    self.log.debug(\"%s  %s run mode %s handler: %s\", socket_id, msg_type, run_mode, handler)\n    job[\"run_mode\"] = run_mode\n    runner = _wrap_handler(self.run_handler, handler)\n    match run_mode:\n        case RunMode.queue:\n            Caller().queue_call(runner, job)\n        case RunMode.thread:\n            Caller.to_thread(runner, job)\n        case RunMode.task:\n            Caller().call_soon(runner, job)\n        case RunMode.blocking:\n            await runner(job)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.handle_message_request(job)","title":"<code>job</code>","text":"(<code>Job</code>)           \u2013            <p>The packed message for handling.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode","title":"get_run_mode","text":"<pre><code>get_run_mode(\n    msg_type: MsgType,\n    *,\n    socket_id: Literal[shell, control] = shell,\n    concurrency_mode: KernelConcurrencyMode | NoValue = NoValue,\n    job: Job | None = None,\n) -&gt; RunMode\n</code></pre> <p>Determine the run mode for a given channel, message type and concurrency mode.</p> <p>The run mode determines how the kernel will execute the message.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RunMode</code>           \u2013            <p>The run mode for the message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a shutdown or debug request is received on the shell socket.</p> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_run_mode(\n    self,\n    msg_type: MsgType,\n    *,\n    socket_id: Literal[SocketID.shell, SocketID.control] = SocketID.shell,\n    concurrency_mode: KernelConcurrencyMode | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    job: Job | None = None,\n) -&gt; RunMode:\n    \"\"\"\n    Determine the run mode for a given channel, message type and concurrency mode.\n\n    The run mode determines how the kernel will execute the message.\n\n    Args:\n        socket_id: The socket ID the message was received on.\n        msg_type: The type of the message.\n        concurrency_mode: The concurrency mode of the kernel. Defaults to [kernel.concurrency_mode][async_kernel.Kernel.concurrency_mode]\n        job: The job associated with the message, if any.\n\n    Returns:\n        The run mode for the message.\n\n    Raises:\n        ValueError: If a shutdown or debug request is received on the shell socket.\n    \"\"\"\n\n    concurrency_mode = self.concurrency_mode if concurrency_mode is NoValue else concurrency_mode\n    # TODO: Are any of these options worth including?\n    # if mode_from_metadata := job[\"msg\"][\"metadata\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_metadata)\n    # if mode_from_header := job[\"msg\"][\"header\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_header)\n    match (concurrency_mode, socket_id, msg_type):\n        case _, SocketID.shell, MsgType.shutdown_request | MsgType.debug_request:\n            msg = f\"{msg_type=} not allowed on shell!\"\n            raise ValueError(msg)\n        case KernelConcurrencyMode.blocking, _, _:\n            return RunMode.blocking\n        case _, SocketID.control, MsgType.execute_request:\n            return RunMode.task\n        case _, _, MsgType.execute_request:\n            if job:\n                if content := job[\"msg\"].get(\"content\", {}):\n                    if (code := content.get(\"code\")) and (mode_ := RunMode.get_mode(code)):\n                        return mode_\n                    if content.get(\"silent\"):\n                        return RunMode.task\n                if mode_ := set(utils.get_tags(job)).intersection(RunMode):\n                    return RunMode(next(iter(mode_)))\n            return RunMode.queue\n        case _, _, MsgType.inspect_request | MsgType.complete_request | MsgType.is_complete_request:\n            return RunMode.thread\n        case _, _, MsgType.history_request:\n            return RunMode.thread\n        case _, _, MsgType.comm_msg:\n            return RunMode.queue\n        case _, _, MsgType.kernel_info_request | MsgType.comm_info_request | MsgType.comm_open | MsgType.comm_close:\n            return RunMode.blocking\n        case _, _, MsgType.debug_request:\n            return RunMode.blocking\n        case _:\n            return RunMode.blocking\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(socket_id)","title":"<code>socket_id</code>","text":"(<code>Literal[shell, control]</code>, default:                   <code>shell</code> )           \u2013            <p>The socket ID the message was received on.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(msg_type)","title":"<code>msg_type</code>","text":"(<code>MsgType</code>)           \u2013            <p>The type of the message.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(concurrency_mode)","title":"<code>concurrency_mode</code>","text":"(<code>KernelConcurrencyMode | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>The concurrency mode of the kernel. Defaults to kernel.concurrency_mode</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(job)","title":"<code>job</code>","text":"(<code>Job | None</code>, default:                   <code>None</code> )           \u2013            <p>The job associated with the message, if any.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.all_concurrency_run_modes","title":"all_concurrency_run_modes","text":"<pre><code>all_concurrency_run_modes(\n    socket_ids: Iterable[Literal[shell, control]] = (shell, control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"KernelConcurrencyMode\", \"MsgType\", \"RunMode\"],\n    tuple[SocketID, KernelConcurrencyMode, MsgType, RunMode | None],\n]\n</code></pre> <p>Generates a dictionary containing all combinations of SocketID, KernelConcurrencyMode, and MsgType, along with their corresponding RunMode (if available).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def all_concurrency_run_modes(\n    self,\n    socket_ids: Iterable[Literal[SocketID.shell, SocketID.control]] = (SocketID.shell, SocketID.control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"KernelConcurrencyMode\", \"MsgType\", \"RunMode\"],\n    tuple[SocketID, KernelConcurrencyMode, MsgType, RunMode | None],\n]:\n    \"\"\"\n    Generates a dictionary containing all combinations of SocketID, KernelConcurrencyMode, and MsgType,\n    along with their corresponding RunMode (if available).\"\"\"\n    data: list[Any] = []\n    for socket_id in socket_ids:\n        for concurrency_mode in KernelConcurrencyMode:\n            for msg_type in msg_types:\n                try:\n                    mode = self.get_run_mode(msg_type, socket_id=socket_id, concurrency_mode=concurrency_mode)\n                except ValueError:\n                    mode = None\n                data.append((socket_id, concurrency_mode, msg_type, mode))\n    data_ = zip(*data, strict=True)\n    return dict(zip([\"SocketID\", \"KernelConcurrencyMode\", \"MsgType\", \"RunMode\"], data_, strict=True))\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler","title":"run_handler  <code>async</code>","text":"<pre><code>run_handler(handler: HandlerType, job: Job[dict]) -&gt; None\n</code></pre> <p>Runs the handler in the context of the job/message sending the reply content if it is provided.</p> <p>This method gets called for every valid request with the relevant handler.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def run_handler(self, handler: HandlerType, job: Job[dict]) -&gt; None:\n    \"\"\"\n    Runs the handler in the context of the job/message sending the reply content if it is provided.\n\n    This method gets called for every valid request with the relevant handler.\n    \"\"\"\n\n    def send_reply(job: Job[dict], content: dict, /) -&gt; None:\n        if \"status\" not in content:\n            content[\"status\"] = \"ok\"\n        msg = self.session.send(\n            stream=job[\"socket\"],\n            msg_or_type=job[\"msg\"][\"header\"][\"msg_type\"].replace(\"request\", \"reply\"),\n            content=content,\n            parent=job[\"msg\"][\"header\"],  # pyright: ignore[reportArgumentType]\n            ident=job[\"ident\"],\n        )\n        if msg:\n            self.log.debug(\"*** _send_reply %s*** %s\", job[\"socket_id\"], msg)\n\n    token = utils._job_var.set(job)  # pyright: ignore[reportPrivateUsage]\n    try:\n        self.iopub_send(msg_or_type=\"status\", content={\"execution_state\": \"busy\"}, ident=self.topic(\"status\"))\n        if (content := await handler(job)) is not None:\n            send_reply(job, content)\n    except Exception as e:\n        send_reply(job, error_to_content(e))\n        self.log.exception(\"Exception in message handler:\", exc_info=e)\n    finally:\n        utils._job_var.reset(token)  # pyright: ignore[reportPrivateUsage]\n        self.iopub_send(\n            msg_or_type=\"status\", parent=job[\"msg\"], content={\"execution_state\": \"idle\"}, ident=self.topic(\"status\")\n        )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: dict[str, Any] | str,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send a message on the zmq iopub socket.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def iopub_send(\n    self,\n    msg_or_type: dict[str, Any] | str,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"Send a message on the zmq iopub socket.\"\"\"\n    if socket := Caller.iopub_sockets.get(thread := threading.current_thread()):\n        msg = self.session.send(\n            stream=socket,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else utils.get_parent(),  # pyright: ignore[reportArgumentType]\n            ident=ident,\n            buffers=buffers,\n        )\n        if msg:\n            self.log.debug(\n                \"iopub_send: (thread=%s) msg_type:'%s', content: %s\", thread.name, msg[\"msg_type\"], msg[\"content\"]\n            )\n    else:\n        self.control_thread_caller.call_direct(\n            self.iopub_send,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else None,\n            ident=ident,\n            buffers=buffers,\n        )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.topic","title":"topic","text":"<pre><code>topic(topic) -&gt; bytes\n</code></pre> <p>prefixed topic for IOPub messages.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def topic(self, topic) -&gt; bytes:\n    \"\"\"prefixed topic for IOPub messages.\"\"\"\n    return (f\"kernel.{topic}\").encode()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_info_request","title":"kernel_info_request  <code>async</code>","text":"<pre><code>kernel_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a kernel info request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def kernel_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [kernel info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-info).\"\"\"\n    return self.kernel_info\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_info_request","title":"comm_info_request  <code>async</code>","text":"<pre><code>comm_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a comm info request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [comm info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-info).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    target_name = c.get(\"target_name\", None)\n    comms = {\n        k: {\"target_name\": v.target_name}\n        for (k, v) in tuple(self.comm_manager.comms.items())\n        if v.target_name == target_name or target_name is None\n    }\n    return {\"comms\": comms}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execute_request","title":"execute_request  <code>async</code>","text":"<pre><code>execute_request(job: Job[ExecuteContent]) -&gt; Content\n</code></pre> <p>Handle a execute request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def execute_request(self, job: Job[ExecuteContent], /) -&gt; Content:\n    \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    if (\n        job[\"run_mode\"] is RunMode.queue\n        and (job[\"received_time\"] &lt; self._stop_on_error_time)\n        and not c.get(\"silent\", False)\n    ):\n        self.log.info(\"Aborting execute_request: %s\", job)\n        return error_to_content(RuntimeError(\"Aborting due to prior exception\")) | {\n            \"execution_count\": self.execution_count\n        }\n    metadata = job[\"msg\"].get(\"metadata\") or {}\n    if not (silent := c[\"silent\"]):\n        self._execution_count += 1\n        utils._execution_count_var.set(self._execution_count)  # pyright: ignore[reportPrivateUsage]\n        self.iopub_send(\n            msg_or_type=\"execute_input\",\n            content={\"code\": c[\"code\"], \"execution_count\": self.execution_count},\n            parent=job[\"msg\"],\n            ident=self.topic(\"execute_input\"),\n        )\n    fut = (Caller.to_thread if job[\"run_mode\"] is RunMode.thread else Caller().call_soon)(\n        self.shell.run_cell_async,\n        raw_cell=c[\"code\"],\n        store_history=c.get(\"store_history\", False),\n        silent=silent,\n        transformed_cell=self.shell.transform_cell(c[\"code\"]),\n        shell_futures=True,\n        cell_id=metadata.get(\"cellId\"),\n    )\n    if not silent:\n        self._interrupts.add(fut.cancel)\n        fut.add_done_callback(lambda fut: self._interrupts.discard(fut.cancel))\n    try:\n        result: ExecutionResult = await fut\n        err = result.error_before_exec or result.error_in_exec if result else KernelInterruptError()\n    except Exception as e:\n        # A safeguard to catch exceptions not caught by the shell.\n        err = e\n    if (err) and (\n        (Tags.suppress_error in metadata.get(\"tags\", ()))\n        or (isinstance(err, anyio.get_cancelled_exc_class()) and (utils.get_execute_request_timeout() is not None))\n    ):\n        # Suppress the error due to either:\n        # 1. tag\n        # 2. timeout\n        err = None\n    content = {\n        \"status\": \"error\" if err else \"ok\",\n        \"execution_count\": self.execution_count,\n        \"user_expressions\": self.shell.user_expressions(c.get(\"user_expressions\", {})),\n    }\n    if err:\n        content |= error_to_content(err)\n        if (not silent) and c.get(\"stop_on_error\"):\n            try:\n                self._stop_on_error_time = math.inf\n                self.log.info(\"An error occurred in a non-silent execution request\")\n                await anyio.sleep(0)\n            finally:\n                self._stop_on_error_time = time.monotonic()\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.complete_request","title":"complete_request  <code>async</code>","text":"<pre><code>complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a completion request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    code: str = c[\"code\"]\n    cursor_pos = c.get(\"cursor_pos\") or len(code)\n    with IPython.core.completer.provisionalcompleter():\n        completions = self.shell.Completer.completions(code, cursor_pos)\n        completions = list(IPython.core.completer.rectify_completions(code, completions))\n    comps = [\n        {\n            \"start\": comp.start,\n            \"end\": comp.end,\n            \"text\": comp.text,\n            \"type\": comp.type,\n            \"signature\": comp.signature,\n        }\n        for comp in completions\n    ]\n    s, e = completions[0].start, completions[0].end if completions else (cursor_pos, cursor_pos)\n    matches = [c.text for c in completions]\n    return {\n        \"matches\": matches,\n        \"cursor_end\": e,\n        \"cursor_start\": s,\n        \"metadata\": {\"_jupyter_types_experimental\": comps},\n    }\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.is_complete_request","title":"is_complete_request  <code>async</code>","text":"<pre><code>is_complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a is_complete request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def is_complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n    status, indent_spaces = self.shell.input_transformer_manager.check_complete(job[\"msg\"][\"content\"][\"code\"])\n    content = {\"status\": status}\n    if status == \"incomplete\":\n        content[\"indent\"] = \" \" * indent_spaces\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.inspect_request","title":"inspect_request  <code>async</code>","text":"<pre><code>inspect_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a inspect request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def inspect_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    detail_level = int(c.get(\"detail_level\", 0))\n    omit_sections = set(c.get(\"omit_sections\", []))\n    name = token_at_cursor(c[\"code\"], c[\"cursor_pos\"])\n    content = {\"data\": {}, \"metadata\": {}, \"found\": True}\n    try:\n        bundle = self.shell.object_inspect_mime(name, detail_level=detail_level, omit_sections=omit_sections)\n        content[\"data\"] = bundle\n        if not self.shell.enable_html_pager:\n            content[\"data\"].pop(\"text/html\")\n    except KeyError:\n        content[\"found\"] = False\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.history_request","title":"history_request  <code>async</code>","text":"<pre><code>history_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a history request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def history_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    history_manager = self.shell.history_manager\n    assert history_manager\n    if c.get(\"hist_access_type\") == \"tail\":\n        hist = history_manager.get_tail(c[\"n\"], raw=c.get(\"raw\"), output=c.get(\"output\"), include_latest=True)\n    elif c.get(\"hist_access_type\") == \"range\":\n        hist = history_manager.get_range(\n            c.get(\"session\", 0),\n            c.get(\"start\", 1),\n            c.get(\"stop\", None),\n            raw=c.get(\"raw\", True),\n            output=c.get(\"output\", False),\n        )\n    elif c.get(\"hist_access_type\") == \"search\":\n        hist = history_manager.search(\n            c.get(\"pattern\"), raw=c.get(\"raw\"), output=c.get(\"output\"), n=c.get(\"n\"), unique=c.get(\"unique\")\n        )\n    else:\n        hist = []\n    return {\"history\": list(hist)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_open","title":"comm_open  <code>async</code>","text":"<pre><code>comm_open(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm open request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_open(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm open request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#opening-a-comm).\"\"\"\n    self.comm_manager.comm_open(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_msg","title":"comm_msg  <code>async</code>","text":"<pre><code>comm_msg(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm msg request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_msg(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm msg request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-messages).\"\"\"\n    self.comm_manager.comm_msg(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_close","title":"comm_close  <code>async</code>","text":"<pre><code>comm_close(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm close request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_close(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm close request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#tearing-down-comms).\"\"\"\n    self.comm_manager.comm_close(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.interrupt_request","title":"interrupt_request  <code>async</code>","text":"<pre><code>interrupt_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a interrupt request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def interrupt_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [interrupt request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-interrupt) (control only).\"\"\"\n    self._interrupt_requested = True\n    if sys.platform == \"win32\":\n        signal.raise_signal(signal.SIGINT)\n        time.sleep(0)\n    else:\n        os.kill(os.getpid(), signal.SIGINT)\n    for interrupter in tuple(self._interrupts):\n        interrupter()\n    return {}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shutdown_request","title":"shutdown_request  <code>async</code>","text":"<pre><code>shutdown_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a shutdown request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def shutdown_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [shutdown request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-shutdown) (control only).\"\"\"\n    self.stop()\n    return {\"restart\": job[\"msg\"][\"content\"].get(\"restart\", False)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debug_request","title":"debug_request  <code>async</code>","text":"<pre><code>debug_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a debug request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def debug_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [debug request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#debug-request) (control only).\"\"\"\n    return await self.debugger.process_request(job[\"msg\"][\"content\"])\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.excepthook","title":"excepthook","text":"<pre><code>excepthook(etype, evalue, tb) -&gt; None\n</code></pre> <p>Handle an exception.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def excepthook(self, etype, evalue, tb) -&gt; None:\n    \"\"\"Handle an exception.\"\"\"\n    # write uncaught traceback to 'real' stderr, not zmq-forwarder\n    traceback.print_exception(etype, evalue, tb, file=sys.__stderr__)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.unraisablehook","title":"unraisablehook","text":"<pre><code>unraisablehook(unraisable: UnraisableHookArgs) -&gt; None\n</code></pre> <p>Handle unraisable exceptions (during gc for instance).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def unraisablehook(self, unraisable: sys.UnraisableHookArgs, /) -&gt; None:\n    \"Handle unraisable exceptions (during gc for instance).\"\n    exc_info = (\n        unraisable.exc_type,\n        unraisable.exc_value or unraisable.exc_type(unraisable.err_msg),\n        unraisable.exc_traceback,\n    )\n    self.log.exception(unraisable.err_msg, exc_info=exc_info, extra={\"object\": unraisable.object})\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.raw_input","title":"raw_input","text":"<pre><code>raw_input(prompt='') -&gt; Any\n</code></pre> <p>Forward raw_input to frontends.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.raw_input--raises","title":"Raises","text":"<p>StdinNotImplementedError if active frontend doesn't support stdin.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def raw_input(self, prompt=\"\") -&gt; Any:\n    \"\"\"\n    Forward raw_input to frontends.\n\n    Raises\n    ------\n    StdinNotImplementedError if active frontend doesn't support stdin.\n    \"\"\"\n    return self._input_request(str(prompt), password=False)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.getpass","title":"getpass","text":"<pre><code>getpass(prompt='') -&gt; Any\n</code></pre> <p>Forward getpass to frontends.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def getpass(self, prompt=\"\") -&gt; Any:\n    \"\"\"Forward getpass to frontends.\"\"\"\n    return self._input_request(prompt, password=True)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_connection_info","title":"get_connection_info","text":"<pre><code>get_connection_info() -&gt; dict[str, Any]\n</code></pre> <p>Return the connection info as a dict.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_connection_info(self) -&gt; dict[str, Any]:\n    \"\"\"Return the connection info as a dict.\"\"\"\n    with self.connection_file.open(\"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.error_to_content","title":"async_kernel.kernel.error_to_content","text":"<pre><code>error_to_content(error: BaseException) -&gt; Content\n</code></pre> <p>Convert the error to a dict.</p> <p>ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#request-reply</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def error_to_content(error: BaseException, /) -&gt; Content:\n    \"\"\"\n    Convert the error to a dict.\n\n    ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#request-reply\n    \"\"\"\n    return {\n        \"status\": \"error\",\n        \"ename\": type(error).__name__,\n        \"evalue\": str(error),\n        \"traceback\": traceback.format_exception(error),\n    }\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.bind_socket","title":"async_kernel.kernel.bind_socket","text":"<pre><code>bind_socket(\n    socket: Socket[SocketType],\n    transport: Literal[\"tcp\", \"ipc\"],\n    ip: str,\n    port: int = 0,\n    max_attempts: int | NoValue = NoValue,\n) -&gt; int\n</code></pre> <p>Bind the socket to a port using the settings.</p> <p>max_attempts: The maximum number of attempts to bind the socket. If un-specified, defaults to 100 if port missing, else 2 attempts.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def bind_socket(\n    socket: Socket[SocketType],\n    transport: Literal[\"tcp\", \"ipc\"],\n    ip: str,\n    port: int = 0,\n    max_attempts: int | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n) -&gt; int:\n    \"\"\"\n    Bind the socket to a port using the settings.\n\n    max_attempts: The maximum number of attempts to bind the socket. If un-specified,\n    defaults to 100 if port missing, else 2 attempts.\n    \"\"\"\n    if socket.TYPE == SocketType.ROUTER:\n        # ref: https://github.com/ipython/ipykernel/issues/270\n        socket.router_handover = 1\n    if transport == \"ipc\":\n        ip = Path(ip).as_posix()\n    if max_attempts is NoValue:\n        max_attempts = 2 if port else 100\n    for attempt in range(max_attempts):\n        try:\n            if transport == \"tcp\":\n                if not port:\n                    port = socket.bind_to_random_port(f\"tcp://{ip}\")\n                else:\n                    socket.bind(f\"tcp://{ip}:{port}\")\n            elif transport == \"ipc\":\n                if not port:\n                    port = 1\n                    while Path(f\"{ip}-{port}\").exists():\n                        port += 1\n                socket.bind(f\"ipc://{ip}-{port}\")\n            else:\n                msg = f\"Invalid transport: {transport}\"  # pyright: ignore[reportUnreachable]\n                raise ValueError(msg)\n        except ZMQError as e:\n            if e.errno not in {errno.EADDRINUSE, 98, 10048, 135}:\n                raise\n            if port and attempt &lt; max_attempts - 1:\n                time.sleep(0.1)\n        else:\n            return port\n    msg = f\"Failed to bind {socket} for {transport=} after {max_attempts} attempts.\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/kernelspec/","title":"async_kernel.kernelspec","text":"<p>Add and remove kernel specifications for Jupyter.</p> <p>Functions:</p> <ul> <li> <code>make_argv</code>             \u2013              <p>Returns an argument vector (argv) that can be used to start a <code>Kernel</code>.</p> </li> <li> <code>write_kernel_spec</code>             \u2013              <p>Write a kernel spec for launching a kernel.</p> </li> <li> <code>get_kernel_dir</code>             \u2013              <p>The path to where kernel specs are stored for Jupyter.</p> </li> </ul>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv","title":"async_kernel.kernelspec.make_argv","text":"<pre><code>make_argv(\n    *,\n    connection_file: str = \"{connection_file}\",\n    kernel_name: KernelName | str = asyncio,\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    fullpath: bool = True,\n    **kwargs,\n) -&gt; list[str]\n</code></pre> <p>Returns an argument vector (argv) that can be used to start a <code>Kernel</code>.</p> <p>This function returns a list of arguments can be used directly start a kernel with subprocess.Popen. It will always call async_kernel.command.command_line as a python module.</p> <p>Parameters:</p> kwargs <p>Additional settings to pass when creating the kernel passed to <code>kernel_factory</code>. When the kernel factThe key should be the dotted path to the attribute. Or if using a</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[str]</code> )          \u2013            <p>A list of command-line arguments to launch the kernel module.</p> </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def make_argv(\n    *,\n    connection_file: str = \"{connection_file}\",\n    kernel_name: KernelName | str = KernelName.asyncio,\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    fullpath: bool = True,\n    **kwargs,\n) -&gt; list[str]:\n    \"\"\"Returns an argument vector (argv) that can be used to start a `Kernel`.\n\n    This function returns a list of arguments can be used directly start a kernel with [subprocess.Popen][].\n    It will always call [async_kernel.command.command_line][] as a python module.\n\n    Args:\n        connection_file: The path to the connection file.\n        kernel_factory: Either the kernel factory object itself, or the string import path to a\n            callable that returns a non-started kernel.\n        kernel_name: The name of the kernel to use.\n        fullpath: If True the full path to the executable is used, otherwise 'python' is used.\n\n    kwargs:\n        Additional settings to pass when creating the kernel passed to `kernel_factory`.\n        When the kernel factThe key should be the dotted path to the attribute. Or if using a\n\n    Returns:\n        list: A list of command-line arguments to launch the kernel module.\n    \"\"\"\n    argv = [(sys.executable if fullpath else \"python\"), \"-m\", \"async_kernel\", \"-f\", connection_file]\n    for k, v in ({\"kernel_factory\": kernel_factory, \"kernel_name\": kernel_name} | kwargs).items():\n        argv.append(f\"--{k}={v}\")\n    return argv\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(connection_file)","title":"<code>connection_file</code>","text":"(<code>str</code>, default:                   <code>'{connection_file}'</code> )           \u2013            <p>The path to the connection file.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(kernel_factory)","title":"<code>kernel_factory</code>","text":"(<code>str | KernelFactoryType</code>, default:                   <code>'async_kernel.Kernel'</code> )           \u2013            <p>Either the kernel factory object itself, or the string import path to a callable that returns a non-started kernel.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(kernel_name)","title":"<code>kernel_name</code>","text":"(<code>KernelName | str</code>, default:                   <code>asyncio</code> )           \u2013            <p>The name of the kernel to use.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(fullpath)","title":"<code>fullpath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True the full path to the executable is used, otherwise 'python' is used.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec","title":"async_kernel.kernelspec.write_kernel_spec","text":"<pre><code>write_kernel_spec(\n    path: Path | str | None = None,\n    *,\n    kernel_name: KernelName | str,\n    display_name: str = \"\",\n    fullpath: bool = False,\n    prefix: str = \"\",\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    connection_file: str = \"{connection_file}\",\n    **kwargs,\n) -&gt; Path\n</code></pre> <p>Write a kernel spec for launching a kernel.</p> <p>Parameters:</p> kwargs <p>Pass additional settings to set on the instance of the <code>Kernel</code> when it is instantiated. Each setting should correspond to the dotted path to the attribute in the kernel. For example <code>kernel.shell.execute_request_timeout</code> should be passed as <code>shell.execute_request_timeout</code>. Unpack from a dict to avoid syntax errors.</p> <p>kwargs added to KernelSpec.argv.</p> Example: Passing a callable kernel_factory. <p>When <code>kernel_factory</code> is passed as a callable, the callable is stored in the file 'kernel_spec.py' inside the kernelspec folder.</p> <pre><code>import async_kernel.kernelspec\n\n\ndef kernel_factory(settings):\n    from IPython.display import display\n    import anyio\n    from ipywidgets import Button\n\n    from async_kernel import AsyncEvent, Kernel\n\n    class MyKernel(Kernel):\n        async def execute_request(self, job):\n            event = AsyncEvent()\n            b = Button(description=\"Continue\")\n            b.on_click(lambda _: event.set())\n            display(b)\n            await event.wait()\n            b.close()\n            return await super().execute_request(job)\n\n    return MyKernel(settings)\n\n\nasync_kernel.kernelspec.write_kernel_spec(\n    kernel_name=\"async-button\", kernel_factory=kernel_factory\n)\n</code></pre> <p>Warning</p> <p>Moving the spec folder will break the import which is stored as an absolute path.</p> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def write_kernel_spec(\n    path: Path | str | None = None,\n    *,\n    kernel_name: KernelName | str,\n    display_name: str = \"\",\n    fullpath: bool = False,\n    prefix: str = \"\",\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    connection_file: str = \"{connection_file}\",\n    **kwargs,\n) -&gt; Path:\n    \"\"\"\n    Write a kernel spec for launching a kernel.\n\n    Args:\n        path: The path where to write the spec.\n        kernel_name: The name of the kernel to use.\n        fullpath: If True the full path to the executable is used, otherwise 'python' is used.\n        display_name: The display name for Jupyter to use for the kernel. The default is `\"Python ({kernel_name})\"`.\n        kernel_factory: The string import path to a callable that creates the Kernel or,\n            a *self-contained* function that returns an instance of a `Kernel`.\n\n        connection_file: The path to the connection file.\n        prefix: given, the kernelspec will be installed to PREFIX/share/jupyter/kernels/KERNEL_NAME.\n            This can be sys.prefix for installation inside virtual or conda envs.\n\n    kwargs:\n        Pass additional settings to set on the instance of the `Kernel` when it is instantiated.\n        Each setting should correspond to the dotted path to the attribute in the kernel.\n        For example `kernel.shell.execute_request_timeout` should be passed as `shell.execute_request_timeout`.\n        Unpack from a dict to avoid syntax errors.\n\n        kwargs added to [KernelSpec.argv][jupyter_client.kernelspec.KernelSpec.argv].\n\n    ??? example \"Example: Passing a callable kernel_factory.\"\n\n        When `kernel_factory` is passed as a callable, the callable is stored in the file\n        'kernel_spec.py' inside the kernelspec folder.\n\n        ```python\n        import async_kernel.kernelspec\n\n\n        def kernel_factory(settings):\n            from IPython.display import display\n            import anyio\n            from ipywidgets import Button\n\n            from async_kernel import AsyncEvent, Kernel\n\n            class MyKernel(Kernel):\n                async def execute_request(self, job):\n                    event = AsyncEvent()\n                    b = Button(description=\"Continue\")\n                    b.on_click(lambda _: event.set())\n                    display(b)\n                    await event.wait()\n                    b.close()\n                    return await super().execute_request(job)\n\n            return MyKernel(settings)\n\n\n        async_kernel.kernelspec.write_kernel_spec(\n            kernel_name=\"async-button\", kernel_factory=kernel_factory\n        )\n        ```\n\n        !!! warning\n\n            Moving the spec folder will break the import which is stored as an absolute path.\n\n\n    \"\"\"\n    assert re.match(re.compile(r\"^[a-z0-9._\\-]+$\", re.IGNORECASE), kernel_name)\n    path = Path(path) if path else (get_kernel_dir(prefix) / kernel_name)\n    # stage resources\n    try:\n        path.mkdir(parents=True, exist_ok=True)\n        if callable(kernel_factory):\n            with path.joinpath(\"kernel_factory.py\").open(\"w\") as f:\n                f.write(textwrap.dedent(inspect.getsource(kernel_factory)))\n            kernel_factory = f\"{path}{CUSTOM_KERNEL_MARKER}{kernel_factory.__name__}\"\n        # validate\n        if kernel_factory != \"async_kernel.Kernel\":\n            import_kernel_factory(kernel_factory)\n        shutil.copytree(src=RESOURCES, dst=path, dirs_exist_ok=True)\n        spec = KernelSpec()\n        spec.argv = make_argv(\n            kernel_factory=kernel_factory,\n            connection_file=connection_file,\n            kernel_name=kernel_name,\n            fullpath=fullpath,\n            **kwargs,\n        )\n        spec.name = kernel_name\n        spec.display_name = display_name or f\"Python ({kernel_name})\"\n        spec.language = \"python\"\n        spec.interrupt_mode = \"message\"\n        spec.metadata = {\"debugger\": True}\n        # write kernel.json\n        with path.joinpath(\"kernel.json\").open(\"w\") as f:\n            json.dump(spec.to_dict(), f, indent=1)\n    except Exception:\n        shutil.rmtree(path, ignore_errors=True)\n        raise\n    else:\n        return path\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(path)","title":"<code>path</code>","text":"(<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path where to write the spec.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(kernel_name)","title":"<code>kernel_name</code>","text":"(<code>KernelName | str</code>)           \u2013            <p>The name of the kernel to use.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(fullpath)","title":"<code>fullpath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True the full path to the executable is used, otherwise 'python' is used.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(display_name)","title":"<code>display_name</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The display name for Jupyter to use for the kernel. The default is <code>\"Python ({kernel_name})\"</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(kernel_factory)","title":"<code>kernel_factory</code>","text":"(<code>str | KernelFactoryType</code>, default:                   <code>'async_kernel.Kernel'</code> )           \u2013            <p>The string import path to a callable that creates the Kernel or, a self-contained function that returns an instance of a <code>Kernel</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(connection_file)","title":"<code>connection_file</code>","text":"(<code>str</code>, default:                   <code>'{connection_file}'</code> )           \u2013            <p>The path to the connection file.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>given, the kernelspec will be installed to PREFIX/share/jupyter/kernels/KERNEL_NAME. This can be sys.prefix for installation inside virtual or conda envs.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.remove_kernel_spec","title":"async_kernel.kernelspec.remove_kernel_spec","text":"<pre><code>remove_kernel_spec(kernel_name: str) -&gt; bool\n</code></pre> <p>Remove a kernelspec returning True if it was removed.</p> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def remove_kernel_spec(kernel_name: str) -&gt; bool:\n    \"Remove a kernelspec returning True if it was removed.\"\n    if (folder := get_kernel_dir().joinpath(kernel_name)).exists():\n        shutil.rmtree(folder, ignore_errors=True)\n        return True\n    return False\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.get_kernel_dir","title":"async_kernel.kernelspec.get_kernel_dir","text":"<pre><code>get_kernel_dir(prefix: str = '') -&gt; Path\n</code></pre> <p>The path to where kernel specs are stored for Jupyter.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def get_kernel_dir(prefix: str = \"\") -&gt; Path:\n    \"\"\"\n    The path to where kernel specs are stored for Jupyter.\n\n    Args:\n        prefix: Defaults to sys.prefix (installable for a particular environment).\n    \"\"\"\n    return Path(prefix or sys.prefix) / \"share/jupyter/kernels\"\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.get_kernel_dir(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Defaults to sys.prefix (installable for a particular environment).</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.import_kernel_factory","title":"async_kernel.kernelspec.import_kernel_factory","text":"<pre><code>import_kernel_factory(kernel_factory: str = '') -&gt; KernelFactoryType\n</code></pre> <p>Import the kernel factory as defined in a kernel spec.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>KernelFactoryType</code>           \u2013            <p>The kernel factory.</p> </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def import_kernel_factory(kernel_factory: str = \"\") -&gt; KernelFactoryType:\n    \"\"\"\n    Import the kernel factory as defined in a kernel spec.\n\n    Args:\n        kernel_factory: The name of the kernel factory.\n\n    Returns:\n        The kernel factory.\n    \"\"\"\n    if CUSTOM_KERNEL_MARKER in kernel_factory:\n        path, factory_name = kernel_factory.split(CUSTOM_KERNEL_MARKER)\n        try:\n            sys.path.insert(0, path)\n            import kernel_factory as kf  # noqa: PLC0415\n\n            factory = getattr(kf, factory_name)\n            assert len(inspect.signature(factory).parameters) == 1\n            return factory\n        finally:\n            sys.path.remove(path)\n    return traitlets.import_item(kernel_factory or \"async_kernel.Kernel\")\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.import_kernel_factory(kernel_factory)","title":"<code>kernel_factory</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the kernel factory.</p>"},{"location":"reference/typing/","title":"async_kernel.typing","text":"<p>Classes:</p> <ul> <li> <code>SocketID</code>           \u2013            <p>Mapping of <code>Kernel.port_&lt;id&gt;</code> for sockets. Ref.</p> </li> <li> <code>RunMode</code>           \u2013            <p>An Enum of the kernel run modes available for</p> </li> <li> <code>KernelConcurrencyMode</code>           \u2013            </li> <li> <code>MsgType</code>           \u2013            <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> </li> <li> <code>MetadataKeys</code>           \u2013            <p>This is an enum of keys for metadata in kernel messages</p> </li> <li> <code>Tags</code>           \u2013            <p>Tags recognised by the kernel.</p> </li> <li> <code>MsgHeader</code>           \u2013            <p>A message header.</p> </li> <li> <code>Message</code>           \u2013            <p>A message.</p> </li> <li> <code>Job</code>           \u2013            <p>An async_kernel.typing.Message bundled with sockit_id, socket and ident.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID","title":"async_kernel.typing.SocketID","text":"<p>               Bases: <code>StrEnum</code></p> <p>Mapping of <code>Kernel.port_&lt;id&gt;</code> for sockets. Ref.</p> <p>Attributes:</p> <ul> <li> <code>heartbeat</code>           \u2013            </li> <li> <code>shell</code>           \u2013            </li> <li> <code>stdin</code>           \u2013            </li> <li> <code>control</code>           \u2013            </li> <li> <code>iopub</code>           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID.heartbeat","title":"heartbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>heartbeat = 'hb'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = 'shell'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.stdin","title":"stdin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stdin = 'stdin'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.control","title":"control  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>control = 'control'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.iopub","title":"iopub  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub = 'iopub'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.RunMode","title":"async_kernel.typing.RunMode","text":"<p>               Bases: <code>StrEnum</code></p> <p>An Enum of the kernel run modes available for altering how message requests are run.</p> <p>String match options</p> <p>Each of these options will give a match.</p> <ul> <li><code>&lt;value&gt;</code></li> <li><code>&lt;##value&gt;</code></li> <li>'<code>RunMode.&lt;value&gt;</code>.</li> </ul> <p>special usage</p> <p>Run mode can be used in execute requests. Add it at the top line (or use the string equivalent \"##\") of a code cell. <p>Methods:</p> <ul> <li> <code>get_mode</code>             \u2013              <p>Get a RunMode from the code if it is found.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>queue</code>           \u2013            <p>The message for the handler is run sequentially with other messages that are queued.</p> </li> <li> <code>task</code>           \u2013            <p>The message for the handler are run concurrently in task (starting immediately).</p> </li> <li> <code>thread</code>           \u2013            <p>Messages for the handler are run concurrently in a thread (starting immediately).</p> </li> <li> <code>blocking</code>           \u2013            <p>Run the handler directly as soon as it is received.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.RunMode.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue = 'queue'\n</code></pre> <p>The message for the handler is run sequentially with other messages that are queued.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task = 'task'\n</code></pre> <p>The message for the handler are run concurrently in task (starting immediately).</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.thread","title":"thread  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>thread = 'thread'\n</code></pre> <p>Messages for the handler are run concurrently in a thread (starting immediately).</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.blocking","title":"blocking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocking = 'blocking'\n</code></pre> <p>Run the handler directly as soon as it is received.</p> <p>Warning</p> <p>This mode blocks the message loop. </p> <p>Use this for short running messages that should be processed as soon as it is received.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.get_mode","title":"get_mode  <code>classmethod</code>","text":"<pre><code>get_mode(code: str) -&gt; RunMode | None\n</code></pre> <p>Get a RunMode from the code if it is found.</p> Source code in <code>src/async_kernel/typing.py</code> <pre><code>@classmethod\ndef get_mode(cls, code: str) -&gt; RunMode | None:\n    \"Get a RunMode from the code if it is found.\"\n    try:\n        if (code := code.strip().split(\"\\n\")[0].strip()).startswith(\"##\"):\n            return RunMode(code.removeprefix(\"##\"))\n        if code.startswith(\"RunMode.\"):\n            return RunMode(code.removeprefix(\"RunMode.\"))\n    except ValueError:\n        return None\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.KernelConcurrencyMode","title":"async_kernel.typing.KernelConcurrencyMode","text":"<p>               Bases: <code>StrEnum</code></p> <p>Attributes:</p> <ul> <li> <code>default</code>           \u2013            <p>The default concurrency mode</p> </li> <li> <code>blocking</code>           \u2013            <p>All handlers are run with the blocking.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.KernelConcurrencyMode.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default = 'default'\n</code></pre> <p>The default concurrency mode</p>"},{"location":"reference/typing/#async_kernel.typing.KernelConcurrencyMode.blocking","title":"blocking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocking = 'blocking'\n</code></pre> <p>All handlers are run with the blocking.</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType","title":"async_kernel.typing.MsgType","text":"<p>               Bases: <code>StrEnum</code></p> <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> <p>Some message types are on the control channel only.</p> <p>Attributes:</p> <ul> <li> <code>kernel_info_request</code>           \u2013            <p>async_kernel.Kernel.kernel_info_request</p> </li> <li> <code>comm_info_request</code>           \u2013            <p>async_kernel.Kernel.comm_info_request</p> </li> <li> <code>execute_request</code>           \u2013            <p>async_kernel.Kernel.execute_request</p> </li> <li> <code>complete_request</code>           \u2013            <p>async_kernel.Kernel.complete_request</p> </li> <li> <code>is_complete_request</code>           \u2013            <p>async_kernel.Kernel.is_complete_request</p> </li> <li> <code>inspect_request</code>           \u2013            <p>async_kernel.Kernel.inspect_request</p> </li> <li> <code>history_request</code>           \u2013            <p>async_kernel.Kernel.history_request</p> </li> <li> <code>comm_open</code>           \u2013            <p>async_kernel.Kernel.comm_open</p> </li> <li> <code>comm_msg</code>           \u2013            <p>async_kernel.Kernel.comm_msg</p> </li> <li> <code>comm_close</code>           \u2013            <p>async_kernel.Kernel.comm_close</p> </li> <li> <code>interrupt_request</code>           \u2013            <p>async_kernel.Kernel.interrupt_request (control channel only)</p> </li> <li> <code>shutdown_request</code>           \u2013            <p>async_kernel.Kernel.shutdown_request (control channel only)</p> </li> <li> <code>debug_request</code>           \u2013            <p>async_kernel.Kernel.debug_request (control channel only)</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgType.kernel_info_request","title":"kernel_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_info_request = 'kernel_info_request'\n</code></pre> <p>async_kernel.Kernel.kernel_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_info_request","title":"comm_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_info_request = 'comm_info_request'\n</code></pre> <p>async_kernel.Kernel.comm_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.execute_request","title":"execute_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request = 'execute_request'\n</code></pre> <p>async_kernel.Kernel.execute_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.complete_request","title":"complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>complete_request = 'complete_request'\n</code></pre> <p>async_kernel.Kernel.complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.is_complete_request","title":"is_complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_complete_request = 'is_complete_request'\n</code></pre> <p>async_kernel.Kernel.is_complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.inspect_request","title":"inspect_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_request = 'inspect_request'\n</code></pre> <p>async_kernel.Kernel.inspect_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.history_request","title":"history_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_request = 'history_request'\n</code></pre> <p>async_kernel.Kernel.history_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_open","title":"comm_open  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_open = 'comm_open'\n</code></pre> <p>async_kernel.Kernel.comm_open</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_msg","title":"comm_msg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_msg = 'comm_msg'\n</code></pre> <p>async_kernel.Kernel.comm_msg</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_close","title":"comm_close  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_close = 'comm_close'\n</code></pre> <p>async_kernel.Kernel.comm_close</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.interrupt_request","title":"interrupt_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupt_request = 'interrupt_request'\n</code></pre> <p>async_kernel.Kernel.interrupt_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.shutdown_request","title":"shutdown_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shutdown_request = 'shutdown_request'\n</code></pre> <p>async_kernel.Kernel.shutdown_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.debug_request","title":"debug_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_request = 'debug_request'\n</code></pre> <p>async_kernel.Kernel.debug_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys","title":"async_kernel.typing.MetadataKeys","text":"<p>               Bases: <code>StrEnum</code></p> <p>This is an enum of keys for metadata in kernel messages that are used in async_kernel.</p> <p>Note</p> <p>Metadata can be edited in Jupyter lab \"Advanced tools\" and Tags can be added using \"common tools\" in the right side bar.</p> <p>Attributes:</p> <ul> <li> <code>tags</code>           \u2013            <p>The <code>tags</code> metadata key corresponds to is a list of strings. </p> </li> <li> <code>timeout</code>           \u2013            <p>The <code>timeout</code> metadata key is used to specify a timeout for execution of the code.</p> </li> <li> <code>suppress_error_message</code>           \u2013            <p>A message to print when the error has been suppressed using async_kernel.typing.Tags.suppress_error. </p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags = 'tags'\n</code></pre> <p>The <code>tags</code> metadata key corresponds to is a list of strings. </p> <p>The list can be edited by the user in a notebook. see also: Tags.</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout = 'timeout'\n</code></pre> <p>The <code>timeout</code> metadata key is used to specify a timeout for execution of the code.</p> <p>The value should be a floating point value of the timeout in seconds.</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.suppress_error_message","title":"suppress_error_message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error_message = 'suppress-error-message'\n</code></pre> <p>A message to print when the error has been suppressed using async_kernel.typing.Tags.suppress_error. </p> Note <p>The default message is '\u26a0'.</p>"},{"location":"reference/typing/#async_kernel.typing.Tags","title":"async_kernel.typing.Tags","text":"<p>               Bases: <code>StrEnum</code></p> <p>Tags recognised by the kernel.</p> Info <p>Tags are can be added per cell.</p> <ul> <li>Jupyter: via the right side bar.</li> <li>VScode: via Jupyter variables explorer/</li> </ul> <p>Attributes:</p> <ul> <li> <code>suppress_error</code>           \u2013            <p>Suppress exceptions that occur during execution of the code cell.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Tags.suppress_error","title":"suppress_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error = 'suppress-error'\n</code></pre> <p>Suppress exceptions that occur during execution of the code cell.</p> <p>Warning</p> <p>The code block will return as 'ok' and there will be no message recorded.</p>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader","title":"async_kernel.typing.MsgHeader","text":"<p>               Bases: <code>TypedDict</code></p> <p>A message header.</p> <p>Attributes:</p> <ul> <li> <code>msg_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>session</code>               (<code>str</code>)           \u2013            </li> <li> <code>username</code>               (<code>str</code>)           \u2013            </li> <li> <code>date</code>               (<code>str</code>)           \u2013            </li> <li> <code>msg_type</code>               (<code>MsgType</code>)           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_id","title":"msg_id  <code>instance-attribute</code>","text":"<pre><code>msg_id: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_type","title":"msg_type  <code>instance-attribute</code>","text":"<pre><code>msg_type: MsgType\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Message","title":"async_kernel.typing.Message","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[T]</code></p> <p>A message.</p> <p>Attributes:</p> <ul> <li> <code>header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> <li> <code>parent_header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> <li> <code>metadata</code>               (<code>Mapping[MetadataKeys | str, Any]</code>)           \u2013            <p>ref</p> </li> <li> <code>content</code>               (<code>T | Content</code>)           \u2013            <p>ref</p> </li> <li> <code>buffers</code>               (<code>list[bytearray | bytes]</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.header","title":"header  <code>instance-attribute</code>","text":"<pre><code>header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.parent_header","title":"parent_header  <code>instance-attribute</code>","text":"<pre><code>parent_header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: Mapping[MetadataKeys | str, Any]\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: T | Content\n</code></pre> <p>ref</p> <p>See also:</p> <ul> <li>ExecuteContent</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.buffers","title":"buffers  <code>instance-attribute</code>","text":"<pre><code>buffers: list[bytearray | bytes]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job","title":"async_kernel.typing.Job","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[T]</code></p> <p>An async_kernel.typing.Message bundled with sockit_id, socket and ident.</p> <p>Attributes:</p> <ul> <li> <code>msg</code>               (<code>Message[T]</code>)           \u2013            </li> <li> <code>socket_id</code>               (<code>Literal[control, shell]</code>)           \u2013            </li> <li> <code>socket</code>               (<code>Socket</code>)           \u2013            </li> <li> <code>ident</code>               (<code>bytes | list[bytes]</code>)           \u2013            </li> <li> <code>received_time</code>               (<code>float</code>)           \u2013            <p>The time the message was received.</p> </li> <li> <code>run_mode</code>               (<code>RunMode</code>)           \u2013            <p>The run mode.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Job.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: Message[T]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.socket_id","title":"socket_id  <code>instance-attribute</code>","text":"<pre><code>socket_id: Literal[control, shell]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.socket","title":"socket  <code>instance-attribute</code>","text":"<pre><code>socket: Socket\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.ident","title":"ident  <code>instance-attribute</code>","text":"<pre><code>ident: bytes | list[bytes]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.received_time","title":"received_time  <code>instance-attribute</code>","text":"<pre><code>received_time: float\n</code></pre> <p>The time the message was received.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.run_mode","title":"run_mode  <code>instance-attribute</code>","text":"<pre><code>run_mode: RunMode\n</code></pre> <p>The run mode.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent","title":"async_kernel.typing.ExecuteContent","text":"<p>               Bases: <code>TypedDict</code></p> <p>Ref.  see also: Message</p> <p>Attributes:</p> <ul> <li> <code>code</code>               (<code>str</code>)           \u2013            <p>The code to execute.</p> </li> <li> <code>silent</code>               (<code>bool</code>)           \u2013            </li> <li> <code>store_history</code>               (<code>bool</code>)           \u2013            </li> <li> <code>user_expressions</code>               (<code>dict[str, str]</code>)           \u2013            </li> <li> <code>allow_stdin</code>               (<code>bool</code>)           \u2013            </li> <li> <code>stop_on_error</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>The code to execute.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.silent","title":"silent  <code>instance-attribute</code>","text":"<pre><code>silent: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.store_history","title":"store_history  <code>instance-attribute</code>","text":"<pre><code>store_history: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.user_expressions","title":"user_expressions  <code>instance-attribute</code>","text":"<pre><code>user_expressions: dict[str, str]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.allow_stdin","title":"allow_stdin  <code>instance-attribute</code>","text":"<pre><code>allow_stdin: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.stop_on_error","title":"stop_on_error  <code>instance-attribute</code>","text":"<pre><code>stop_on_error: bool\n</code></pre>"},{"location":"reference/utils/","title":"async_kernel.utils","text":"<p>Functions:</p> <ul> <li> <code>mark_thread_pydev_do_not_trace</code>             \u2013              <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> </li> <li> <code>do_not_debug_this_thread</code>             \u2013              <p>A context to mark the thread for debugpy to not debug.</p> </li> <li> <code>wait_thread_event</code>             \u2013              <p>Wait for <code>thread_event</code> to be set.</p> </li> <li> <code>get_job</code>             \u2013              <p>Get the job for the current context.</p> </li> <li> <code>get_parent</code>             \u2013              <p>Get the parent message for the current context.</p> </li> <li> <code>get_metadata</code>             \u2013              <p>Gets metadata for the current context.</p> </li> <li> <code>get_tags</code>             \u2013              <p>Gets the tags for the current context.</p> </li> <li> <code>get_execute_request_timeout</code>             \u2013              <p>Gets the execute_request_timeout for the current context.</p> </li> <li> <code>get_execution_count</code>             \u2013              <p>Gets the execution count for the current context, defaults to the current kernel count.</p> </li> <li> <code>setattr_nested</code>             \u2013              <p>Set a nested attribute of an object.</p> </li> </ul>"},{"location":"reference/utils/#async_kernel.utils.mark_thread_pydev_do_not_trace","title":"async_kernel.utils.mark_thread_pydev_do_not_trace","text":"<pre><code>mark_thread_pydev_do_not_trace(thread: Thread, *, remove=False)\n</code></pre> <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def mark_thread_pydev_do_not_trace(thread: threading.Thread, *, remove=False):\n    \"\"\"Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).\"\"\"\n    thread.pydev_do_not_trace = not remove  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.do_not_debug_this_thread","title":"async_kernel.utils.do_not_debug_this_thread","text":"<pre><code>do_not_debug_this_thread()\n</code></pre> <p>A context to mark the thread for debugpy to not debug.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>@contextlib.contextmanager\ndef do_not_debug_this_thread():\n    \"A context to mark the thread for debugpy to not debug.\"\n    if not LAUNCHED_BY_DEBUGPY:\n        mark_thread_pydev_do_not_trace(threading.current_thread())\n    try:\n        yield\n    finally:\n        if not LAUNCHED_BY_DEBUGPY:\n            mark_thread_pydev_do_not_trace(threading.current_thread(), remove=True)\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.wait_thread_event","title":"async_kernel.utils.wait_thread_event  <code>async</code>","text":"<pre><code>wait_thread_event(thread_event: Event)\n</code></pre> <p>Wait for <code>thread_event</code> to be set.</p> <p>Info</p> <ul> <li>On external cancellation the <code>event</code> is set here to prevent the thread from waiting forever.</li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>async def wait_thread_event(thread_event: threading.Event, /):\n    \"\"\"\n    Wait for `thread_event` to be set.\n\n    !!! info\n\n        - On external cancellation the `event` is set here to prevent the thread from waiting forever.\n    \"\"\"\n    await anyio.sleep(0)\n    if thread_event.is_set():\n        return\n\n    def _wait_thread_event(thread_event: threading.Event, event: anyio.Event, token):\n        thread_event.wait()\n        from_thread.run_sync(event.set, token=token)\n\n    try:\n        event = anyio.Event()\n        thread = threading.Thread(target=_wait_thread_event, args=[thread_event, event, current_token()], daemon=True)\n        thread.pydev_do_not_trace = not LAUNCHED_BY_DEBUGPY  # pyright: ignore[reportAttributeAccessIssue]\n        if not thread_event.is_set():\n            thread.start()\n            await event.wait()\n    finally:\n        thread_event.set()\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_kernel","title":"async_kernel.utils.get_kernel","text":"<pre><code>get_kernel() -&gt; Kernel\n</code></pre> <p>Get the current kernel.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_kernel() -&gt; Kernel:\n    \"Get the current kernel.\"\n    return async_kernel.Kernel()\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_job","title":"async_kernel.utils.get_job","text":"<pre><code>get_job() -&gt; Job[dict] | dict\n</code></pre> <p>Get the job for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_job() -&gt; Job[dict] | dict:\n    \"Get the job for the current context.\"\n    try:\n        return _job_var.get()\n    except Exception:\n        return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_parent","title":"async_kernel.utils.get_parent","text":"<pre><code>get_parent(job: Job | None = None) -&gt; Message[dict[str, Any]] | None\n</code></pre> <p>Get the parent message for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_parent(job: Job | None = None, /) -&gt; Message[dict[str, Any]] | None:\n    \"Get the [parent message]() for the current context.\"\n    return (job or get_job()).get(\"msg\")\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_metadata","title":"async_kernel.utils.get_metadata","text":"<pre><code>get_metadata(job: Job | None = None) -&gt; Mapping[str, Any]\n</code></pre> <p>Gets metadata for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_metadata(job: Job | None = None, /) -&gt; Mapping[str, Any]:\n    \"Gets [metadata]() for the current context.\"\n    return (job or get_job()).get(\"msg\", {}).get(\"metadata\", {})\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_tags","title":"async_kernel.utils.get_tags","text":"<pre><code>get_tags(job: Job | None = None) -&gt; list[str]\n</code></pre> <p>Gets the tags for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_tags(job: Job | None = None, /) -&gt; list[str]:\n    \"Gets the [tags]() for the current context.\"\n    return get_metadata(job).get(\"tags\", [])\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execute_request_timeout","title":"async_kernel.utils.get_execute_request_timeout","text":"<pre><code>get_execute_request_timeout(job: Job | None = None) -&gt; float | None\n</code></pre> <p>Gets the execute_request_timeout for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execute_request_timeout(job: Job | None = None, /) -&gt; float | None:\n    \"Gets the execute_request_timeout for the current context.\"\n    try:\n        if timeout := get_metadata(job).get(MetadataKeys.timeout):\n            return float(timeout)\n        return get_kernel().shell.execute_request_timeout\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execution_count","title":"async_kernel.utils.get_execution_count","text":"<pre><code>get_execution_count() -&gt; int\n</code></pre> <p>Gets the execution count for the current context, defaults to the current kernel count.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execution_count() -&gt; int:\n    \"Gets the execution count for the current context, defaults to the current kernel count.\"\n\n    return _execution_count_var.get(None) or async_kernel.Kernel()._execution_count  # pyright: ignore[reportPrivateUsage]\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested","title":"async_kernel.utils.setattr_nested","text":"<pre><code>setattr_nested(obj: object, name: str, value: str | Any) -&gt; dict[str, Any]\n</code></pre> <p>Set a nested attribute of an object.</p> <p>If the attribute name contains dots, it is interpreted as a nested attribute. For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.</p> <p>This is primarily intended for use with async_kernel.command.command_line to set the nesteded attributes on on kernels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The mapping of the name to the set value if the value has been set.</p> </li> <li> <code>dict[str, Any]</code>           \u2013            <p>An empty dict indicates the value was not set.</p> </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def setattr_nested(obj: object, name: str, value: str | Any) -&gt; dict[str, Any]:\n    \"\"\"\n    Set a nested attribute of an object.\n\n    If the attribute name contains dots, it is interpreted as a nested attribute.\n    For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.\n\n    This is primarily intended for use with [async_kernel.command.command_line][]\n    to set the nesteded attributes on on kernels.\n\n    Args:\n        obj: The object to set the attribute on.\n        name: The name of the attribute to set.\n        value: The value to set the attribute to.\n\n    Returns:\n        The mapping of the name to the set value if the value has been set.\n        An empty dict indicates the value was not set.\n\n    \"\"\"\n    if len(bits := name.split(\".\")) &gt; 1:\n        try:\n            obj = getattr(obj, bits[0])\n        except Exception:\n            return {}\n        setattr_nested(obj, \".\".join(bits[1:]), value)\n    if (isinstance(obj, traitlets.HasTraits) and obj.has_trait(name)) or hasattr(obj, name):\n        try:\n            setattr(obj, name, value)\n        except Exception:\n            setattr(obj, name, eval(value))\n        return {name: getattr(obj, name)}\n    return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(obj)","title":"<code>obj</code>","text":"(<code>object</code>)           \u2013            <p>The object to set the attribute on.</p>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The name of the attribute to set.</p>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(value)","title":"<code>value</code>","text":"(<code>str | Any</code>)           \u2013            <p>The value to set the attribute to.</p>"},{"location":"usage/","title":"Usage","text":"<p>If you have used ipykernel before, then you know how to use async-kernel. The major difference is that async kernel is built to run asynchronously.</p>"}]}