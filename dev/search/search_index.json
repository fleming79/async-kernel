{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Async kernel","text":"<p>Async kernel is a Python Jupyter kernel with concurrent message handling.</p> <p>Messages are processed fairly whilst preventing asynchronous deadlocks by using a unique message handler per <code>channel</code>, <code>message_type</code> and <code>subshell_id</code>.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Experimental support for   Jupyterlite try it online here \ud83d\udc48</li> <li>Debugger client</li> <li>anyio compatible event loops<ul> <li><code>asyncio</code> (default)</li> <li><code>trio</code></li> </ul> </li> <li>aiologic thread-safe synchronisation primitives</li> <li>Easy multi-thread / multi-event loop management</li> <li>IPython shell</li> <li>Per-subshell user_ns</li> <li>GUI event loops <sup>1</sup><sup>2</sup><ul> <li> inline</li> <li> ipympl</li> <li> tk with asyncio<sup>3</sup> or trio backend running as a guest</li> <li> qt with asyncio<sup>3</sup> or trio backend running as a guest</li> </ul> </li> </ul> <p>Documentation</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install async-kernel\n</code></pre>"},{"location":"#kernel-specs","title":"Kernel specs","text":"<p>A kernel spec with the name 'async' is added when async kernel is installed.</p> <p>Kernel specs can be added/removed via the command line.</p> <p>The kernel is configured via the interface with the options:</p> <ul> <li><code>interface.backend</code></li> <li><code>interface.backend_options</code></li> <li><code>interface.loop</code></li> <li><code>interface.loop_options</code></li> </ul>"},{"location":"#backends","title":"Backends","text":"<p>The backend defines the asynchronous library provided in the thread in which it is running.</p> <ul> <li>asyncio</li> <li>trio</li> </ul> <p>Example - change kernel spec to use trio</p> <pre><code>pip install trio\nasync-kernel -a async --interface.backend=trio\n</code></pre>"},{"location":"#gui-event-loop","title":"Gui event loop","text":"<p>The kernel can be started with a gui event loop as the host and the backend running as a guest.</p> <p>asyncio backend</p> <pre><code># tk\nasync-kernel -a async-tk --interface.loop=tk\n\n# qt\npip install PySide6-Essentials\nasync-kernel -a async-qt --interface.loop=qt\n</code></pre> <p>trio backend</p> <pre><code>pip install trio\n# tk\nasync-kernel -a async-tk --interface.loop=tk --interface.backend=trio\n\n# qt\npip install PySide6-Essentials\nasync-kernel -a async-qt --interface.loop=qt --interface.backend=trio\n</code></pre> <p>For further detail about kernel spec customisation see command line and kernel configuration.</p>"},{"location":"#origin","title":"Origin","text":"<p>Async kernel started as a fork of IPyKernel. Thank you to the original contributors of IPyKernel that made Async kernel possible.</p> <ol> <li> <p>A gui event loop is provided by starting the event loop (host) and then running an asynchronous backend as a guest in the event loop. Kernel messaging is performed as usual in the asynchronous backend. For this reason it is not possible to enable a gui event loop at runtime.\u00a0\u21a9</p> </li> <li> <p>It is also possible to use a caller to run a gui event loop in a separate thread (with a backend running as a guest) if the gui allows it (qt will only run in the main thread). Also note that pyplot will only permit one interactive gui library in a process.\u00a0\u21a9</p> </li> <li> <p>The asyncio implementation of <code>start_guest_run</code> was written by the author of aiologic and provided as a (gist).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"about/","title":"About","text":"<ul> <li>Contributing</li> <li>Changelog</li> <li>License</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":""},{"location":"about/changelog/#breaking-changes","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Switch from using thread ident to id of thread. Also keep a reference to the thread in the caller. #330</li> </ul>"},{"location":"about/changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Support run_guest_mode in Caller #331</li> </ul>"},{"location":"about/changelog/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Fix link to command line usage in readme #324</li> </ul>"},{"location":"about/changelog/#miscellaneous","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Pre-commit autoupdate and uv upgrade #332</p> </li> <li> <p>Tidy Caller.as_completed. #329</p> </li> <li> <p>Caller refactoring #328</p> </li> <li> <p>Pending.wait minor refactor. #327</p> </li> <li> <p>Refactor Caller.as_completed #326</p> </li> <li> <p>Fix spelling of subshell_id #325</p> </li> </ul>"},{"location":"about/changelog/#0123-2026-02-18","title":"0.12.3 - 2026-02-18","text":""},{"location":"about/changelog/#breaking-changes_1","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Fix PendingTracker for id leakage when opting out of tracking #319</li> </ul>"},{"location":"about/changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Added SingleConsumerAsyncQueue to caller.py #322</p> </li> <li> <p>Add support for running various event loops with the backend running as a guest #320</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_1","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.12.3 #323</p> </li> <li> <p>Make Caller.checkpoint safer. #321</p> </li> <li> <p>Raise a PendingCancelled in a PendingGroup when cancelled via the cancel scope. #318</p> </li> <li> <p>Raise ExceptionGroup in PendingGroup when a pending fails. #317</p> </li> <li> <p>PendingTracker refactoring #316</p> </li> </ul>"},{"location":"about/changelog/#0122-2026-02-10","title":"0.12.2 - 2026-02-10","text":""},{"location":"about/changelog/#breaking-changes_2","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Change Pending trackers default from <code>PendingTracker</code>  to () meaning that tracking is opt in rather than opt out. #314</li> </ul>"},{"location":"about/changelog/#miscellaneous_2","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.12.2 #315</p> </li> <li> <p>Maintenance #313</p> </li> </ul>"},{"location":"about/changelog/#0121-2026-02-08","title":"0.12.1 - 2026-02-08","text":""},{"location":"about/changelog/#breaking-changes_3","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Dropped PendingCreateOptions in favour of trackers #310</p> </li> <li> <p>Improve PendingTracker, PendingManager and PendingGroup reliability #308</p> </li> </ul>"},{"location":"about/changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Add Caller.queue_call_advanced and allow for tracking of queue_call associated pending. #309</p> </li> <li> <p>Improve Caller.wait to pre-check for pending and done. #307</p> </li> </ul>"},{"location":"about/changelog/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix Caller.queue_call not capturing the result of coroutines. #306</li> </ul>"},{"location":"about/changelog/#miscellaneous_3","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.12.1 #312</p> </li> <li> <p>Make pending group cancellation equivalent to Pending cancellation #311</p> </li> </ul>"},{"location":"about/changelog/#0120-2026-01-25","title":"0.12.0 - 2026-01-25","text":""},{"location":"about/changelog/#breaking-changes_4","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Drop the enum KernelName and no longer 'auto' select trio. #303</p> </li> <li> <p>Moved <code>kernel.transport</code> to` interface.transport #301</p> </li> <li> <p>Caller asyncio scheduling optimization and update readme #297</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_4","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.12.0 #305</p> </li> <li> <p>Tweak ci to only run once typechecking passes. #304</p> </li> <li> <p>Chore - pre-commit autoupdate and uv.lock #300</p> </li> <li> <p>Expand kernel tests to run with uvloop/winloop where it is available #299</p> </li> <li> <p>Add a checkpoint that accepts backend as the argument. #298</p> </li> <li> <p>Remove jupyter_client as a build dependency. #296</p> </li> <li> <p>Make the AsyncInteractiveShell.kernel a trait #295</p> </li> </ul>"},{"location":"about/changelog/#0112-2026-01-18","title":"0.11.2 - 2026-01-18","text":""},{"location":"about/changelog/#features_3","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Implement iopub_welcome for JEP65 #292</p> </li> <li> <p>Provide a show_in_pager hook. #291</p> </li> </ul>"},{"location":"about/changelog/#documentation_1","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update docs #293</li> </ul>"},{"location":"about/changelog/#miscellaneous_5","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.11.2 #294</li> </ul>"},{"location":"about/changelog/#0111-2026-01-12","title":"0.11.1 - 2026-01-12","text":""},{"location":"about/changelog/#features_4","title":"\ud83d\ude80 Features","text":"<ul> <li>Remove overrides of <code>run_cell</code>, <code>should_run_async</code> and <code>debug</code>, not testing, but assumed to be functional. #289</li> </ul>"},{"location":"about/changelog/#miscellaneous_6","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.11.1 #290</p> </li> <li> <p>Add kernel_protocol_version to kernelspec. #288</p> </li> </ul>"},{"location":"about/changelog/#0110-2026-01-04","title":"0.11.0 - 2026-01-04","text":""},{"location":"about/changelog/#breaking-changes_5","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Renamed SocketID to Channel and embed the channel inside the message and use channel in place of socket_id. #286</li> </ul>"},{"location":"about/changelog/#fixes_1","title":"\ud83d\udc1b Fixes","text":"<ul> <li> <p>Fix to_thread for pyodide. #283</p> </li> <li> <p>Fix Caller.as_completed sometimes does not yield the last result. #282</p> </li> </ul>"},{"location":"about/changelog/#documentation_2","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update notebook examples #285</li> </ul>"},{"location":"about/changelog/#miscellaneous_7","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.11.0 #287</p> </li> <li> <p>Make interrupt tests more deterministic. #284</p> </li> <li> <p>Metadata and buffers #281</p> </li> </ul>"},{"location":"about/changelog/#0103-2026-01-02","title":"0.10.3 - 2026-01-02","text":""},{"location":"about/changelog/#miscellaneous_8","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.10.3 #280</p> </li> <li> <p>Always set buffers in incoming messages in the callable interface. #279</p> </li> </ul>"},{"location":"about/changelog/#0102-2026-01-02","title":"0.10.2 - 2026-01-02","text":""},{"location":"about/changelog/#breaking-changes_6","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Added a callback style interface compatible with Jupyterlite #277</p> </li> <li> <p>Use ident instead of thread for caller mapping. #276</p> </li> <li> <p>Add an interface abstraction to the kernel with view to enable usage in pyodide. #275</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_9","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.10.2 #278</p> </li> <li> <p>Bump the actions group with 2 updates #274</p> </li> </ul>"},{"location":"about/changelog/#0101-2025-12-14","title":"0.10.1 - 2025-12-14","text":""},{"location":"about/changelog/#breaking-changes_7","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Improve Caller.queue_call rewake reliability and revise Pending.set_result. #272</li> </ul>"},{"location":"about/changelog/#miscellaneous_10","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.10.1 #273</p> </li> <li> <p>Allow PendingManager.deactivate to be called multiple times. #271</p> </li> </ul>"},{"location":"about/changelog/#0100-2025-12-11","title":"0.10.0 - 2025-12-11","text":""},{"location":"about/changelog/#miscellaneous_11","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.10.0 #270</p> </li> <li> <p>Maintenance #269</p> </li> </ul>"},{"location":"about/changelog/#0100-rc2-2025-12-10","title":"0.10.0-rc2 - 2025-12-10","text":""},{"location":"about/changelog/#documentation_3","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Subshell docstrings #267</li> </ul>"},{"location":"about/changelog/#miscellaneous_12","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.10.0-rc2 #268</p> </li> <li> <p>Fix Subshell resetting main_shell namespace reset. #266</p> </li> </ul>"},{"location":"about/changelog/#0100-rc1-2025-12-09","title":"0.10.0-rc1 - 2025-12-09","text":""},{"location":"about/changelog/#breaking-changes_8","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Rename Pending.wait argument shield as protect. #249</p> </li> <li> <p>Drop MetadataKeys and rename execute_request_timeout to timeout and more tags. #247</p> </li> <li> <p>Refactoring with view to supporting pyodide in the kernel. #244</p> </li> <li> <p>Move RunMode.get_mode functionalty to Kernel.get_run_mode #240</p> </li> </ul>"},{"location":"about/changelog/#features_5","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Add LastUpdatedDict and use it for the shell user_ns and user_global_ns. #262</p> </li> <li> <p>Use standard dictionary for Fixed instead of weakkeydict for faster access. #258</p> </li> <li> <p>Added PendingGroup and caller.create_pending_group. #252</p> </li> <li> <p>Added SubshellPendingManager. #251</p> </li> <li> <p>Caller.queue_call is now reset awaitable #250</p> </li> <li> <p>Added PendingTracker,  PendingManager and make Pending.set_result resettable. #248</p> </li> <li> <p>Update uv.lock and bump anyio min version to 4.12 with support for winloop. #243</p> </li> <li> <p>Add support for kernel subshells. #238</p> </li> <li> <p>Run mode header can now be either <code># task</code> or <code>##task</code>. #239</p> </li> <li> <p>Bump aiologic min version to 0.16 and use its import features. #234</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_13","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.10.0-rc1 #265</p> </li> <li> <p>Maintenance #264</p> </li> <li> <p>Use gc.collect at kernel shutdown. #263</p> </li> <li> <p>SubshellManager.create_subshell returns a subshell instead of the subshell_id. #261</p> </li> <li> <p>Modify tests involving weakref to work with pypy. #260</p> </li> <li> <p>Fix type hint for kernel.shell. #259</p> </li> <li> <p>Kernel maintenance #257</p> </li> <li> <p>Alternate kernel run modes. #256</p> </li> <li> <p>Use a tuple to pack direct call instead a functools partial. #255</p> </li> <li> <p>Do_complete_request bugfix. #253</p> </li> <li> <p>Make signature of AsyncInteractiveShell.inspect_request consistent with other methods. #246</p> </li> <li> <p>Move shell related requests to the shell. #245</p> </li> <li> <p>Refactor Caller for improved shutdown. #242</p> </li> <li> <p>Accept subshell_id from either the header or content. Content gets first option. #241</p> </li> <li> <p>Add checkpoints to Caller. #237</p> </li> <li> <p>Add py.typed #236</p> </li> <li> <p>Restore Kernel to the module namespace. #235</p> </li> </ul>"},{"location":"about/changelog/#092-2025-11-27","title":"0.9.2 - 2025-11-27","text":""},{"location":"about/changelog/#miscellaneous_14","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.2 #233</p> </li> <li> <p>Fix typing_extensions min version. #232</p> </li> </ul>"},{"location":"about/changelog/#091-2025-11-27","title":"0.9.1 - 2025-11-27","text":""},{"location":"about/changelog/#miscellaneous_15","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.1 #231</p> </li> <li> <p>Move 'kernel' optional dependencies into normal dependencies. #230</p> </li> <li> <p>Caller.start_sync now just uses asyncio.create_task instead of using an anyio token. #229</p> </li> </ul>"},{"location":"about/changelog/#090-2025-11-25","title":"0.9.0 - 2025-11-25","text":""},{"location":"about/changelog/#miscellaneous_16","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.0 #228</p> </li> <li> <p>Maintenance #227</p> </li> <li> <p>Compat layer isn't required. #226</p> </li> </ul>"},{"location":"about/changelog/#090-rc4-2025-11-25","title":"0.9.0-rc.4 - 2025-11-25","text":""},{"location":"about/changelog/#breaking-changes_9","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Caller refactoring and breaking changes; renamed 'async-context' to 'manual' and removed Caller.to_thread_advanced. #222</p> </li> <li> <p>Make Caller() the preferred way to obtain a running caller. #217</p> </li> <li> <p>Kernel refactoring - moving code around for better readability. #215</p> </li> </ul>"},{"location":"about/changelog/#features_6","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Towards making async_kernel.Callable usable on pyodide. #223</p> </li> <li> <p>Added time based idle worker cleanup. #219</p> </li> <li> <p>Caller.as_completed and Caller.wait can now wait for any awaitables. #218</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_17","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.0-rc.4 #225</p> </li> <li> <p>Remove rudundant code in Caller.new. #224</p> </li> <li> <p>Bump actions/checkout from 5 to 6 in the actions group #221</p> </li> <li> <p>Prepare for release v0.9.0-rc.4 #220</p> </li> <li> <p>Test with free threading python #216</p> </li> </ul>"},{"location":"about/changelog/#090-rc3-2025-11-19","title":"0.9.0-rc.3 - 2025-11-19","text":""},{"location":"about/changelog/#breaking-changes_10","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Caller.wait - renamed argument 'shield' to 'cancel_unfinished' and inverted the logic. #213</li> </ul>"},{"location":"about/changelog/#miscellaneous_18","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.9.0-rc.3 #214</li> </ul>"},{"location":"about/changelog/#090-rc2-2025-11-19","title":"0.9.0-rc.2 - 2025-11-19","text":""},{"location":"about/changelog/#miscellaneous_19","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.0-rc.2 #212</p> </li> <li> <p>Name and hide Kernel.receive_msg_loop from debugpy. #211</p> </li> <li> <p>Tidy up Caller.get. #210</p> </li> <li> <p>Improved interrupts by adding a race to clear or re-reraise. #209</p> </li> <li> <p>Kernel - convert traits to Fixed #208</p> </li> <li> <p>Changed comm_manager to a Fixed property, the ipykernel patch is now only applied when the kernel is started. #207</p> </li> <li> <p>Bugfixes for 'Fixed' class #206</p> </li> </ul>"},{"location":"about/changelog/#090-rc1-2025-11-18","title":"0.9.0-rc.1 - 2025-11-18","text":""},{"location":"about/changelog/#breaking-changes_11","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Caller - instance checks names of children rather than all instances. #204</p> </li> <li> <p>Caller restructuring adding new features and breaking changes plus added 'Fixed' class and renamed Future to Pending. #197</p> </li> <li> <p>Caller enhancements and breaking changes #195</p> </li> <li> <p>Remove unnecessary context copy and call from queue_call. #194</p> </li> </ul>"},{"location":"about/changelog/#features_7","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Added Caller.zmq_context #198</p> </li> <li> <p>Use queue run mode instead of direct which is no slower, but probably 'safer'. #193</p> </li> </ul>"},{"location":"about/changelog/#documentation_4","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Docs #203</p> </li> <li> <p>Update readme. #202</p> </li> <li> <p>Docs and shuffle code inside the kernel #200</p> </li> <li> <p>Update mkdocs and mkdocstrings python - have released insiders features. #192</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_20","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.0-rc.1 #205</p> </li> <li> <p>Add the trait Kernel.print_kernel_messages which when set to false prevents messages from being printed. #201</p> </li> <li> <p>General tidy and remove unrequired tests. #199</p> </li> </ul>"},{"location":"about/changelog/#080-2025-11-12","title":"0.8.0 - 2025-11-12","text":""},{"location":"about/changelog/#breaking-changes_12","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Rename 'RunMode.blocking' to 'RunMode.direct'. #190</p> </li> <li> <p>Add slots to Future. #186</p> </li> <li> <p>Drop Future.init positional argument 'retain_metadata' #185</p> </li> </ul>"},{"location":"about/changelog/#documentation_5","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Maintenance and documentation. #187</li> </ul>"},{"location":"about/changelog/#miscellaneous_21","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.8.0 #191</p> </li> <li> <p>Prepare for release v0.7.2 #189</p> </li> <li> <p>General maintenance #188</p> </li> </ul>"},{"location":"about/changelog/#071-2025-11-11","title":"0.7.1 - 2025-11-11","text":""},{"location":"about/changelog/#features_8","title":"\ud83d\ude80 Features","text":"<ul> <li>Added Kernel.schedule_job, exposed Kernel.caller #181</li> </ul>"},{"location":"about/changelog/#documentation_6","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Improve docstrings: #182</li> </ul>"},{"location":"about/changelog/#miscellaneous_22","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.7.1 #184</p> </li> <li> <p>Make all Threads daemon and add daemon option to Caller.start_new. #183</p> </li> </ul>"},{"location":"about/changelog/#070-2025-11-10","title":"0.7.0 - 2025-11-10","text":""},{"location":"about/changelog/#breaking-changes_13","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Drop 'run_mode' key from Job dict. #174</p> </li> <li> <p>Remove usage of KernelConcurrencyMode. It was functional but unnecessary. #173</p> </li> <li> <p>Run shell and control socket loops in threads without event loops. #172</p> </li> </ul>"},{"location":"about/changelog/#features_9","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Use BinarySemaphore instead of Lock for best performance in send_reply. #178</p> </li> <li> <p>Use a lock in send_reply. #175</p> </li> </ul>"},{"location":"about/changelog/#documentation_7","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Use BinarySemaphore instead of Lock for best performance in send_reply and update readme. #179</li> </ul>"},{"location":"about/changelog/#miscellaneous_23","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.7.0 #180</p> </li> <li> <p>Switch from mdformat to prettier for formatting markdown #177</p> </li> <li> <p>Improve typehints in tests. #176</p> </li> <li> <p>Added Kernel.run and permit the kernel to run outside the main thread #171</p> </li> </ul>"},{"location":"about/changelog/#070-rc2-2025-11-07","title":"0.7.0-rc.2 - 2025-11-07","text":""},{"location":"about/changelog/#features_10","title":"\ud83d\ude80 Features","text":"<ul> <li>Use low-level async primatives in caller module. #169</li> </ul>"},{"location":"about/changelog/#miscellaneous_24","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.7.0-rc.2 #170</li> </ul>"},{"location":"about/changelog/#070-rc1-2025-11-04","title":"0.7.0-rc.1 - 2025-11-04","text":""},{"location":"about/changelog/#breaking-changes_14","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Use aiologic for thread-safe Event and Lock. #164</li> </ul>"},{"location":"about/changelog/#miscellaneous_25","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.7.0-rc.1 #167</li> </ul>"},{"location":"about/changelog/#063-2025-11-04","title":"0.6.3 - 2025-11-04","text":""},{"location":"about/changelog/#miscellaneous_26","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.3 #166</p> </li> <li> <p>Kernel.execute_request unnecessarily sent a thread call to a new thread. #165</p> </li> <li> <p>Update pre-commit #163</p> </li> <li> <p>Use a dependency floor in requirements and upgrade lock file. #162</p> </li> <li> <p>Make AsyncInteractiveShell.enable_gui raise NotImplementedError for unsupported guis. #161</p> </li> </ul>"},{"location":"about/changelog/#062-2025-10-29","title":"0.6.2 - 2025-10-29","text":""},{"location":"about/changelog/#miscellaneous_27","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.2 #160</p> </li> <li> <p>Bump the actions group with 2 updates #158</p> </li> <li> <p>Don't reraise caught cancelled error in Caller_wrap_call. #159</p> </li> <li> <p>Ensure debugInfo is fullly populated. #157</p> </li> </ul>"},{"location":"about/changelog/#061-2025-10-17","title":"0.6.1 - 2025-10-17","text":""},{"location":"about/changelog/#features_11","title":"\ud83d\ude80 Features","text":"<ul> <li>Added Kernel.get_parent. #155</li> </ul>"},{"location":"about/changelog/#miscellaneous_28","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.1 #156</p> </li> <li> <p>Bump astral-sh/setup-uv from 6 to 7 in the actions group #154</p> </li> </ul>"},{"location":"about/changelog/#060-2025-09-30","title":"0.6.0 - 2025-09-30","text":""},{"location":"about/changelog/#breaking-changes_15","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Remove 'name' argument from get_instance (it can be provided as a kwarg. #152</p> </li> <li> <p>Rename Caller.to_thread_by_name to Caller.to_thread_advanced change the first argument from a string or None to a dict. #151</p> </li> </ul>"},{"location":"about/changelog/#features_12","title":"\ud83d\ude80 Features","text":"<ul> <li>Add hooks to AsyncDisplayPublisher #150</li> </ul>"},{"location":"about/changelog/#miscellaneous_29","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.0 #153</p> </li> <li> <p>Better handling of Keyboard Interrupt. #149</p> </li> </ul>"},{"location":"about/changelog/#054-2025-09-28","title":"0.5.4 - 2025-09-28","text":""},{"location":"about/changelog/#miscellaneous_30","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.4 #148</p> </li> <li> <p>Add functools.wraps decorator to kernel._wrap_handler to make it easier to identify which function it is wrapping. #147</p> </li> <li> <p>Minimize calls to 'expensive' thread.Event methods #146</p> </li> </ul>"},{"location":"about/changelog/#053-2025-09-27","title":"0.5.3 - 2025-09-27","text":""},{"location":"about/changelog/#documentation_8","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Various documentation improvements. #144</li> </ul>"},{"location":"about/changelog/#miscellaneous_31","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.3 #145</p> </li> <li> <p>Tidy up Caller queues and  remove kernel.CancelledError. #143</p> </li> <li> <p>Refactored ReentrantAsyncLock and AsyncLock with a new method 'base'. #142</p> </li> </ul>"},{"location":"about/changelog/#052-2025-09-26","title":"0.5.2 - 2025-09-26","text":""},{"location":"about/changelog/#fixes_2","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix debugger #140</li> </ul>"},{"location":"about/changelog/#miscellaneous_32","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.2 #141</p> </li> <li> <p>Refactor Kernel and Subclass Caller from anyio.AsyncContextManagerMixin #139</p> </li> </ul>"},{"location":"about/changelog/#051-2025-09-25","title":"0.5.1 - 2025-09-25","text":""},{"location":"about/changelog/#features_13","title":"\ud83d\ude80 Features","text":"<ul> <li>Take advantage of current_token in utils.wait_thread_event. #136</li> </ul>"},{"location":"about/changelog/#miscellaneous_33","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.1 #138</p> </li> <li> <p>Reinstate test_debugger for windows. #137</p> </li> </ul>"},{"location":"about/changelog/#050-2025-09-24","title":"0.5.0 - 2025-09-24","text":""},{"location":"about/changelog/#breaking-changes_16","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Simplify queue with breaking changes #134</li> </ul>"},{"location":"about/changelog/#miscellaneous_34","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.5.0 #135</li> </ul>"},{"location":"about/changelog/#040-2025-09-23","title":"0.4.0 - 2025-09-23","text":""},{"location":"about/changelog/#breaking-changes_17","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Revise message handling for comm_msg #129</p> </li> <li> <p>Improve Calller.get_instance to start a caller for the main thread if there isn't one running. #127</p> </li> </ul>"},{"location":"about/changelog/#features_14","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Make Caller.queue_call and Caller.queue_call_no_wait thread safe #131</p> </li> <li> <p>Add  Caller.get_runner. #126</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_35","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.4.0 #133</p> </li> <li> <p>Maintenance #132</p> </li> <li> <p>Put _send_reply back inside run_handler. #130</p> </li> <li> <p>Prevent memory leaks in caller scheduled futures #128</p> </li> <li> <p>Housekeeping #125</p> </li> </ul>"},{"location":"about/changelog/#030-2025-09-14","title":"0.3.0 - 2025-09-14","text":""},{"location":"about/changelog/#breaking-changes_18","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Caller.queue_call - divide into queue_get_sender, queue_call and queue_call_no_wait. #123</p> </li> <li> <p>Stricter handling in Caller class. #122</p> </li> <li> <p>Add AsyncEvent  class. #118</p> </li> </ul>"},{"location":"about/changelog/#features_15","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Store Caller.call_later function details in the futures  metadata #119</p> </li> <li> <p>Add metadata to Future. #116</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_36","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.3.0 #124</p> </li> <li> <p>AsyncEvent maintenance - make more robust #120</p> </li> <li> <p>Switch from pytest-retry to pytest-rerun failures. #117</p> </li> <li> <p>Refactor Caller to speed up initialization of Future by removing the creation of the threading event. #115</p> </li> </ul>"},{"location":"about/changelog/#021-2025-09-10","title":"0.2.1 - 2025-09-10","text":""},{"location":"about/changelog/#breaking-changes_19","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Maintenance #105</li> </ul>"},{"location":"about/changelog/#features_16","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Divide Lock into AsyncLock and ReentrantAsyncLock #113</p> </li> <li> <p>Improve Lock class #112</p> </li> <li> <p>Add a context based Lock #111</p> </li> <li> <p>Add classmethod  Caller.wait #106</p> </li> <li> <p>Add 'shield' option to Caller.as_completed. #104</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_37","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.2.1 #114</p> </li> <li> <p>Bump actions/setup-python from 5 to 6 in the actions group #110</p> </li> <li> <p>Maintenance - Caller refactoring #109</p> </li> <li> <p>Drop WaitType for Literals directly in Caller.wait. #108</p> </li> <li> <p>Change Caller._queue_map to a WeakKeyDictionary. #107</p> </li> <li> <p>Refactor Caller.wait to avoid catching  exceptions. #103</p> </li> </ul>"},{"location":"about/changelog/#020-2025-09-06","title":"0.2.0 - 2025-09-06","text":""},{"location":"about/changelog/#breaking-changes_20","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Rename Caller.call_no_context to Caller.call_direct. #100</p> </li> <li> <p>Future - breaking changes- better compatibility of Future.result #96</p> </li> </ul>"},{"location":"about/changelog/#features_17","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Add the classmethod Caller.current_future. #99</p> </li> <li> <p>Add timeout, shield and result optional arguments to Future wait and wait_sync methods: #97</p> </li> <li> <p>Add  optional argument 'msg' to Future.cancel method. #95</p> </li> <li> <p>Support weakref on the Future class. #94</p> </li> </ul>"},{"location":"about/changelog/#documentation_9","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Documentation maintenance. #101</li> </ul>"},{"location":"about/changelog/#miscellaneous_38","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.2.0 #102</p> </li> <li> <p>Result should raise cancelled error, but was raising and InvalidStateError. #98</p> </li> </ul>"},{"location":"about/changelog/#014-2025-09-03","title":"0.1.4 - 2025-09-03","text":""},{"location":"about/changelog/#breaking-changes_21","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Optionally store a string representation of a kernel factory inside the kernel spec. #92</p> </li> <li> <p>Use capital 'V' instead of 'v'  for version flag in command_line. #88</p> </li> </ul>"},{"location":"about/changelog/#documentation_10","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Fix for publish-docs.yml not  setting the version info correctly. #90</p> </li> <li> <p>Include changelog in 'dev' version of docs. #89</p> </li> <li> <p>Development documentation updates and fixes for publish-docs.yml. #87</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_39","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.4 #93</p> </li> <li> <p>Ensure there is only one kernel instance including subclases. #91</p> </li> </ul>"},{"location":"about/changelog/#013-2025-09-02","title":"0.1.3 - 2025-09-02","text":""},{"location":"about/changelog/#features_18","title":"\ud83d\ude80 Features","text":"<ul> <li>Add version option to command line. #82</li> </ul>"},{"location":"about/changelog/#fixes_3","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix bug setting version for mike. #80</li> </ul>"},{"location":"about/changelog/#documentation_11","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update documentation #84</li> </ul>"},{"location":"about/changelog/#miscellaneous_40","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.3 #86</p> </li> <li> <p>Minor import changes. #85</p> </li> <li> <p>Change base class of Kernel from ConnectionFileMixin to HasTraits #83</p> </li> <li> <p>Overwrite subclass properties that should not be available. #81</p> </li> <li> <p>CI checks for python 3.14 #63</p> </li> </ul>"},{"location":"about/changelog/#012-2025-08-31","title":"0.1.2 - 2025-08-31","text":""},{"location":"about/changelog/#breaking-changes_22","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Breaking changes to kernel initialisation and launching #78</p> </li> <li> <p>Enhancement -  Make kernel async enterable. #77</p> </li> </ul>"},{"location":"about/changelog/#documentation_12","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Fix alias for latest docs and limit release versions. #75</li> </ul>"},{"location":"about/changelog/#miscellaneous_41","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.2 #79</p> </li> <li> <p>CI and pre-commit maintenance #76</p> </li> </ul>"},{"location":"about/changelog/#011-2025-08-28","title":"0.1.1 - 2025-08-28","text":""},{"location":"about/changelog/#miscellaneous_42","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.1 #74</p> </li> <li> <p>Bugfixes - fix installing without trio and installing a kernelspec #73</p> </li> </ul>"},{"location":"about/changelog/#010-2025-08-28","title":"0.1.0 - 2025-08-28","text":""},{"location":"about/changelog/#breaking-changes_23","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Caller.queue_call add argument send_nowait  and convert to sync that optionally returns an awaitable. #71</li> </ul>"},{"location":"about/changelog/#features_19","title":"\ud83d\ude80 Features","text":"<ul> <li>Add anyio_backend_options and use uvloop by default #70</li> </ul>"},{"location":"about/changelog/#documentation_13","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Use mike for documentation versioning. #67</p> </li> <li> <p>Update docs, readme and project description. #66</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_43","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0 #72</p> </li> <li> <p>Drop matplotlib dependency. #69</p> </li> </ul>"},{"location":"about/changelog/#010-rc3-2025-08-26","title":"0.1.0-rc3 - 2025-08-26","text":""},{"location":"about/changelog/#features_20","title":"\ud83d\ude80 Features","text":"<ul> <li>Add more classifers and code coverage #64</li> </ul>"},{"location":"about/changelog/#miscellaneous_44","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc3 #65</p> </li> <li> <p>Add workflow_run event because the release is not triggered if  the release is created by another workflow. #62</p> </li> </ul>"},{"location":"about/changelog/#010-rc2-2025-08-26","title":"0.1.0-rc2 - 2025-08-26","text":""},{"location":"about/changelog/#miscellaneous_45","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.1.0-rc2 #61</li> </ul>"},{"location":"about/changelog/#010-rc1-2025-08-26","title":"0.1.0-rc1 - 2025-08-26","text":""},{"location":"about/changelog/#documentation_14","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update licensing and contribution notes #27</li> </ul>"},{"location":"about/changelog/#miscellaneous_46","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc1 #60</p> </li> <li> <p>Merge pull request #56 from fleming79/release/v0.1.0-rc1 #56</p> </li> <li> <p>Revise new release #55</p> </li> <li> <p>New release workflow in one step with publish option. #51</p> </li> <li> <p>Improve release workflow, update documentation and license info. #29</p> </li> <li> <p>Maintenance #26</p> </li> </ul>"},{"location":"about/changelog/#010-rc0-2025-08-24","title":"[0.1.0-rc0] - 2025-08-24","text":""},{"location":"about/changelog/#features_21","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>First release #18</p> </li> <li> <p>Switch to vcs for versioning. #2</p> </li> </ul>"},{"location":"about/changelog/#fixes_4","title":"\ud83d\udc1b Fixes","text":"<ul> <li> <p>Use no-local-version in pyproject.toml instead. #5</p> </li> <li> <p>Use no-local-version on ci. #4</p> </li> </ul>"},{"location":"about/changelog/#documentation_15","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Revise workflow to work with tags that start with 'v'. No longer sets the tag when writing the changelog. #16</p> </li> <li> <p>Switch to python installer to run git cliff. #14</p> </li> <li> <p>Revise changelog template. #12</p> </li> <li> <p>Do changelog as PR instead of push to main. #8</p> </li> <li> <p>Git cliff #7</p> </li> <li> <p>Fix mkdocs publishing #6</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_47","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Bugfix #25</p> </li> <li> <p>Update changelog #24</p> </li> <li> <p>Update changelog #22</p> </li> <li> <p>Release workflow changes #21</p> </li> <li> <p>Update release workflow to use a template that appends output from git-cliff #17</p> </li> <li> <p>Bump the actions group across 1 directory with 2 updates #3</p> </li> </ul>"},{"location":"about/contributing/","title":"Contributing","text":"<p>This project is under active development. Feel free to create an issue to provide feedback.</p>"},{"location":"about/contributing/#development","title":"Development","text":"<p>The development environment is provided by uv using locking and syncing.</p> <p>If you are working on a pull request make a fork of the project and work on the fork.</p> <pre><code>git clone &lt;your fork repository&gt;\ncd async-kernel\n</code></pre> <p>Synchronise the environment.</p> <pre><code>uv venv --python 3.11 # or whichever environment you are targeting.\nuv sync\n# Activate the environment\n</code></pre> <p>Additional steps to build documentation (optional):</p> <pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --main_shell.timeout=0.1\n</code></pre>"},{"location":"about/contributing/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"about/contributing/#running-tests-with-coverage","title":"Running tests with coverage","text":"<p>We intend to maintain 100% code coverage on CI (Linux). The coverage report and badge  are generated with Codecov.</p> <p>You can run tests locally with coverage to see if the test will pass on CI using:</p> <pre><code>uv run pytest -vv --cov --cov-fail-under=100\n</code></pre> Info <p>We are only targeting 100% on linux for &gt;= 3.12 for the following reasons:</p> <ol> <li>linux is the only platform that reliably supports the <code>transport</code> type <code>ipc</code> for zmq sockets which is supported by async kerenel.</li> <li>Coverage on Python 3.11 doesn't correctly gather data for subprocesses giving invalid coverage reports.</li> </ol>"},{"location":"about/contributing/#pre-commit-prek","title":"Pre-commit (prek)","text":"<p>Pre-commit (prek) runs a number of checks on the code and will also re-format it.</p> <p>Pre-commit will run automatically on submission of a PR but you can also run it locally as a tool with:</p> Changed filesAll files <pre><code>uvx prek run\n</code></pre> <pre><code>uvx prek run -a\n</code></pre>"},{"location":"about/contributing/#type-checking","title":"Type checking","text":"<p>Type checking is performed separately to pre-commit checks. Currently type checking is done using basedpyright. Other type checkers might be added in the future.</p> <pre><code>uv run basedpyright\n</code></pre>"},{"location":"about/contributing/#update-packages","title":"Update packages","text":"<p>To upgrade all packages use the command:</p> <pre><code>uv lock --upgrade\n</code></pre>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is generated from markdown files and the source using Material for MkDocs  and mike for versioning. Publishing of documentation is handled by the automation workflow 'publish-docs.yml'.</p> <p>The 'docs' group specified extra packages are required to build documentation.</p>"},{"location":"about/contributing/#sync-docs-group","title":"Sync 'docs' group","text":"<pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --main_shell.timeout=0.1\n</code></pre>"},{"location":"about/contributing/#test-the-docs","title":"Test the docs","text":"<pre><code>uv run mkdocs build -s\n</code></pre> Info <p>The command:</p> <pre><code>uv run async-kernel -a async-docs --main_shell.timeout=0.1\n</code></pre> <p>Defines a new kernel spec with the name \"async-docs\" that sets the <code>shell.timeout</code> to 100ms.</p> <p>The \"async-docs\" named kernel spec is used by mkdocs-jupyter to convert the notebooks for inclusion in the usage section of the documentation.</p>"},{"location":"about/contributing/#serve-locally","title":"Serve locally","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"about/contributing/#api-docstrings","title":"API / Docstrings","text":"<p>API documentation is included using mkdocstrings.</p> <p>Docstrings are written in docstring format google-notypes. Typing information is included automatically by griff.</p>"},{"location":"about/contributing/#see-also","title":"See also","text":"<ul> <li>cross-referencing</li> </ul>"},{"location":"about/contributing/#notebooks","title":"Notebooks","text":"<p>Notebooks are included in the documentation by the plugin mkdocs-jupyter.</p> <p>Info</p> <p>We use the kernel spec named 'async-docs' which has a cell execute timeout of 100ms. This is used to advance execution through long running cells.</p> <p>The suppress-error tag is inserted in code cells to enable with generating documentation. The symbol '\u26a0' is an indicator that the error was suppressed. Normally this is due to the timeout but there is no distinction on the type of error.</p>"},{"location":"about/contributing/#useful-links","title":"Useful links","text":"<p>These links are not relevant for docstrings.</p> <ul> <li>footnotes</li> <li>tooltips</li> </ul>"},{"location":"about/contributing/#releasing-async-kernel","title":"Releasing Async kernel","text":"<p>To make a new release go to the new_release.yml action and click 'Run workflow'.</p>"},{"location":"about/contributing/#new_releaseyml","title":"new_release.yml","text":"<p>The workflow does the following:</p> <ol> <li>Creates and merges a PR with the updated changelog generated with git-cliff.</li> <li>Starts a new Github release which adds a tag 'v' to the head of the main branch."},{"location":"about/contributing/#publish-to-pypiyml","title":"publish-to-pypi.yml","text":"<p>The publish-to-pypi<sup>1</sup> workflow will start automatically on completion of the \"new_release.yml\". It performs the following steps.</p> <ol> <li>Builds the distribution.</li> <li>Waits for manual approval to release.</li> <li>Uploads the release files to PyPi.</li> <li>Uploads the release files to the Github release.</li> </ol> <p>Once the new PR is available merge the PR into the main branch. Normally this will also trigger publication of the new release.</p>"},{"location":"about/contributing/#publish","title":"Publish","text":"<p>publish-to-pypi.yml is the workflow that publishes the release. It starts on a push to the main branch but can also be manually triggered. It will always publish to TestPyPI on a push. If the git head has a tag starting with 'v' it will also publish to PyPi. If it is published to PyPI successfully, it will also create a Github release.</p>"},{"location":"about/contributing/#run-ci-checks-locally","title":"Run ci checks locally","text":"<p>You can run tests locally to see if there is anything that might be caught by CI.</p> <pre><code>uvx prek run -a\nuv run pytest -vv --cov --cov-fail-under=100\nuv run basedpyright\nuv run mkdocs build -s\n</code></pre> <p>Note</p> <p>CI checks also run for a matrix of OS's and python versions. So even if all tests pass locally, tests can still fail for another os or python version.</p> <ol> <li> <p>This workflow also runs on push to the main branch, but will instead publish to TestPyPI.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Alan Fleming.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished \nto do so, subject to the following conditions:\n\nThe above copyright notice, shall be included in all copies or substantial \nportions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Notebooks<sup>1</sup> in this documentation show the result of each cell after executing for a short duration (~100ms).</p> <p>You can download the notebook with the button at the top right of the page for the notebook.</p> <p>You can also try async-kernel with Jupyterlite directly in your browser at https://fleming79.github.io/echo-kernel.</p> <ol> <li> <p>Further detail about how notebooks are generated is provided here.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebooks/caller/","title":"Caller","text":"In\u00a0[1]: Copied! <pre># A magic method provided by async kernel\n%callers\n</pre> # A magic method provided by async kernel %callers <pre>     Name    Running Protected     Thread             Caller       </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell           \u2713       \ud83d\udd10       MainThread   139954601605360 \u2190 current</pre> <pre>\n</pre> <pre>Control         \u2713       \ud83d\udd10        Control     139954539994608</pre> <pre>\n</pre> In\u00a0[2]: Copied! <pre>from async_kernel import Caller\n\nCaller()\n</pre> from async_kernel import Caller  Caller() <pre>Caller&lt;Shell at 139954566661424 asyncio \ud83c\udfc3 running 1 child&gt;</pre> In\u00a0[3]: suppress-error Copied! <pre>import random\nimport time\n\nimport ipywidgets as ipw\n\noutputs = {}\nstop = ipw.RadioButtons(value=None, options=[\"Stop\"])\ndisplay(stop)\n\n\ndef my_func(n):\n    caller = Caller()\n    if not (out := outputs.get(caller)):\n        outputs[caller] = out = ipw.HTML(description=str(caller), style={\"description_width\": \"initial\"})\n        display(out)\n    sleep_time = random.random() / 4\n    out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"\n    time.sleep(sleep_time)\n    return n\n\n\nasync def run_forever():\n    n = 0\n    while not stop.value:\n        n += 1\n        yield Caller().to_thread(my_func, n)\n\n\nasync for fut in Caller().as_completed(run_forever()):\n    result = await fut\n    print(f\"Finished: {result}\", end=\"\\r\")\n</pre> import random import time  import ipywidgets as ipw  outputs = {} stop = ipw.RadioButtons(value=None, options=[\"Stop\"]) display(stop)   def my_func(n):     caller = Caller()     if not (out := outputs.get(caller)):         outputs[caller] = out = ipw.HTML(description=str(caller), style={\"description_width\": \"initial\"})         display(out)     sleep_time = random.random() / 4     out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"     time.sleep(sleep_time)     return n   async def run_forever():     n = 0     while not stop.value:         n += 1         yield Caller().to_thread(my_func, n)   async for fut in Caller().as_completed(run_forever()):     result = await fut     print(f\"Finished: {result}\", end=\"\\r\") <pre>RadioButtons(options=('Stop',), value=None)</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539034432 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539029584 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539005616 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539004368 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539009456 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539059328 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539061680 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539015696 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539057936 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre>HTML(value='', description='Caller&lt;async_kernel_caller at 139954539010368 asyncio \ud83c\udfc3 running &gt;', style=HTMLStyl\u2026</pre> <pre></pre> In\u00a0[4]: Copied! <pre>%callers\n</pre> %callers <pre>           Name          Running Protected          Thread                 Caller       </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell                       \u2713       \ud83d\udd10            MainThread       139954601605360 \u2190 current</pre> <pre>\n</pre> <pre>Control                     \u2713       \ud83d\udd10             Control         139954539994608</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539029824</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539034672</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539004608</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539005904</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539010416</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539014064</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539019152</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539058176</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539060768</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139954539061920</pre> <pre>\n</pre>"},{"location":"notebooks/caller/#caller","title":"Caller\u00b6","text":"<p><code>Caller</code> is a class that makes it easy to call code in different threads/tasks.</p> <p>One caller instance is created per thread and can start children callers in new threads by name or using a pool of workers with the 'to_thread' method.</p>"},{"location":"notebooks/caller/#pending","title":"Pending\u00b6","text":"<p>If a method call returns an <code>async_kernel.Pending</code> the result of the call can be obtained by awaiting the pending.</p>"},{"location":"notebooks/caller/#usage-by-the-kernel","title":"Usage by the kernel\u00b6","text":"<p>The kernel uses two <code>Caller</code> instances; one each for <code>shell</code> and <code>control</code>. The shell thread event loop is normally the <code>MainThread</code>, but could be any thread depending on where the kernel was started. The control event loop is always named <code>ControlThread</code> and is a child of the shell caller. The shell caller is accessible at <code>kernel.caller</code> while the kerenel is running.</p>"},{"location":"notebooks/caller/#example","title":"Example\u00b6","text":"<p>This example requires ipywidgets!</p>"},{"location":"notebooks/concurrency/","title":"Concurrency","text":"In\u00a0[1]: Copied! <pre>from async_kernel import utils\nfrom async_kernel.typing import MsgType\n\nkernel = utils.get_kernel()\n\nkernel.get_run_mode(MsgType.comm_msg)\n</pre> from async_kernel import utils from async_kernel.typing import MsgType  kernel = utils.get_kernel()  kernel.get_run_mode(MsgType.comm_msg) <pre>&lt;RunMode.queue: 'queue'&gt;</pre> <p>Below is a list of the run modes according to the message type and channel (SocketID).</p> In\u00a0[2]: Copied! <pre>data = kernel.all_concurrency_run_modes()\ntry:\n    import pandas as pd\nexcept ImportError:\n    print(data)\nelse:\n    data = pd.DataFrame(data)\n    data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")\n    data = data.pivot(index=\"MsgType\", columns=[\"SocketID\"], values=\"RunMode\")  # noqa: PD010\n    data = data.reindex([\"shell\", \"control\"], axis=1)\n    display(data)\n</pre> data = kernel.all_concurrency_run_modes() try:     import pandas as pd except ImportError:     print(data) else:     data = pd.DataFrame(data)     data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")     data = data.pivot(index=\"MsgType\", columns=[\"SocketID\"], values=\"RunMode\")  # noqa: PD010     data = data.reindex([\"shell\", \"control\"], axis=1)     display(data) SocketID shell control MsgType comm_close direct direct comm_info_request direct direct comm_msg queue queue comm_open direct direct complete_request thread thread create_subshell_request NaN thread debug_request NaN queue delete_subshell_request NaN thread execute_request queue queue history_request thread thread inspect_request thread thread interrupt_request direct direct is_complete_request thread thread kernel_info_request direct direct list_subshell_request NaN direct shutdown_request NaN direct In\u00a0[3]: Copied! <pre>async def demo():\n    import threading\n\n    from aiologic import Event\n    from ipywidgets import Button\n\n    print(f\"Thread name: '{threading.current_thread().name}'\")\n    button = Button(description=\"Finish\")\n    event = Event()\n    button.on_click(lambda _: event.set())\n    display(button)\n    await event\n    button.close()\n    print(f\"Finished ... thread name: '{threading.current_thread().name}'\")\n    return \"Finished\"\n</pre> async def demo():     import threading      from aiologic import Event     from ipywidgets import Button      print(f\"Thread name: '{threading.current_thread().name}'\")     button = Button(description=\"Finish\")     event = Event()     button.on_click(lambda _: event.set())     display(button)     await event     button.close()     print(f\"Finished ... thread name: '{threading.current_thread().name}'\")     return \"Finished\" <p>Lets run it normally (queue)</p> In\u00a0[4]: suppress-error Copied! <pre>await demo()\n</pre> await demo() <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[5]: suppress-error Copied! <pre># task\n# Tip: try running this cell while the previous cell is still busy.\nawait demo()\n</pre> # task # Tip: try running this cell while the previous cell is still busy. await demo() <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[6]: thread suppress-error Copied! <pre># This time we'll use the tag to run the cell in a Thread\nawait demo()\n</pre> # This time we'll use the tag to run the cell in a Thread await demo() <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[7]: Copied! <pre># thread\n%callers # magic provided by async kernel\n</pre> # thread %callers # magic provided by async kernel <pre>           Name          Running Protected          Thread                 Caller       </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell                       \u2713       \ud83d\udd10            MainThread       139761250482416</pre> <pre>\n</pre> <pre>Control                     \u2713       \ud83d\udd10             Control         139761189267040</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139760212565680 \u2190 current</pre> <pre>\n</pre>"},{"location":"notebooks/concurrency/#concurrency","title":"Concurrency\u00b6","text":"<p>Async kernel handles message requests concurrently.</p> <p>How the request is handled is a function of the channel and message type.</p> <p>The following <code>RunModes</code> are provided.</p> <ul> <li>direct: Run the handler directly in the message loop (recommend only for short running code)</li> <li>queue: Run in a queue (default for the <code>shell</code> channel)</li> <li>task: Run in a task (default for the <code>control</code> channel)</li> <li>thread: Run in a worker thread</li> </ul> <p>The kernel decides the run mode dynamically with the method get_run_mode.</p>"},{"location":"notebooks/concurrency/#execute-request-run-mode","title":"Execute request run mode\u00b6","text":"<p>There are a few options to modify how code cells are run.</p> <ul> <li>Metadata</li> <li>Directly in code</li> <li>tags</li> <li>Message header (in custom messages)</li> </ul> <p>Warning</p> <p>Only Jupyter lab is known to allow concurrent execution of cells.</p>"},{"location":"notebooks/concurrency/#code-for-example","title":"Code for example\u00b6","text":"<ul> <li>This example requires ipywidgets</li> <li>Ensure you are running an async kernel</li> </ul> <p>Lets define a function that we'll reuse for the remainder of the notebook.</p>"},{"location":"notebooks/concurrency/#run-mode-task","title":"Run mode: task\u00b6","text":"<p>The <code>task</code> mode instructs the kernel to execute the code in a task separate to the queue, Both <code>task</code> and <code>thread</code> execute modes can be started when the kernel is busy executing. There is no imposed limitation on the number of tasks (or threads) that can be run concurrently.</p> <p>See also the Caller example on how to call directly.</p>"},{"location":"notebooks/concurrency/#run-mode-thread","title":"Run mode: thread\u00b6","text":""},{"location":"notebooks/simple_example/","title":"Simple example","text":"In\u00a0[1]: Copied! <pre>import ipywidgets as ipw\nfrom aiologic import REvent\n\n\nasync def demo():\n    %callers\n\n    b = ipw.Button(description=\"Continue\")\n    event = REvent()\n    b.on_click(lambda _: event.set())\n    display(b)\n    for i in range(1, 3):\n        event.clear()\n        b.description = f\"Continue {i}\"\n        print(f\"Waiting {i}\", end=\"\\r\")\n        await event\n    b.close()\n    print(\"\\nDone!\")\n</pre> import ipywidgets as ipw from aiologic import REvent   async def demo():     %callers      b = ipw.Button(description=\"Continue\")     event = REvent()     b.on_click(lambda _: event.set())     display(b)     for i in range(1, 3):         event.clear()         b.description = f\"Continue {i}\"         print(f\"Waiting {i}\", end=\"\\r\")         await event     b.close()     print(\"\\nDone!\") In\u00a0[2]: suppress-error Copied! <pre>await demo()\n</pre> await demo() <pre>     Name    Running Protected     Thread             Caller       </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell           \u2713       \ud83d\udd10       MainThread   139875287617312 \u2190 current</pre> <pre>\n</pre> <pre>Control         \u2713       \ud83d\udd10        Control     139875224790912</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[3]: suppress-error Copied! <pre># task\nawait demo()\n</pre> # task await demo() <pre>     Name    Running Protected     Thread             Caller       </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell           \u2713       \ud83d\udd10       MainThread   139875287617312 \u2190 current</pre> <pre>\n</pre> <pre>Control         \u2713       \ud83d\udd10        Control     139875224790912</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[4]: suppress-error Copied! <pre># thread\nawait demo()\n</pre> # thread await demo() <pre>           Name          Running Protected          Thread                 Caller       </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell                       \u2713       \ud83d\udd10            MainThread       139875287617312</pre> <pre>\n</pre> <pre>Control                     \u2713       \ud83d\udd10             Control         139875224790912</pre> <pre>\n</pre> <pre>async_kernel_caller         \u2713                async_kernel_caller   139875219338784 \u2190 current</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre>"},{"location":"notebooks/simple_example/#overview","title":"Overview\u00b6","text":"<p>This example demonstrates different ways that the same code can be executed. This is an overview of the four cells shown in the animation below.</p> <ol> <li>Define the coroutine function.<ol> <li>Cell 'magic' <code>%callers</code> prints a list of Caller instances and the thread in which it is executing.</li> <li>Creates an aiologic REvent.</li> <li>A button is created and and it runs a loop twice:<ol> <li>Prints a statement.</li> <li>Clears the event.</li> <li>Waits for the button click to set the event.</li> </ol> </li> </ol> </li> <li>Execute <code>demo</code> normally.</li> <li>Execute <code>demo</code> concurrently in a task.</li> <li>Execute <code>demo</code> in a thread.</li> </ol> <p></p>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides documentation for each module in async kernel.</p>"},{"location":"reference/#highlights","title":"Highlights","text":"<ul> <li>Kernel - The kernel.</li> <li>Caller - Simplifies event loop management and call scheduling (thread-safe).</li> <li>Pending - Represents a pending result that can be set, awaited and cancelled (thread-safe).</li> <li>command_line - The command line interface.</li> </ul>"},{"location":"reference/asyncshell/","title":"asyncshell","text":"<p>Classes:</p> <ul> <li> <code>AsyncInteractiveShell</code>           \u2013            <p>An IPython InteractiveShell adapted to work with Async kernel.</p> </li> <li> <code>AsyncInteractiveSubshell</code>           \u2013            <p>An asynchronous interactive subshell for managing isolated execution contexts within an async kernel.</p> </li> <li> <code>KernelInterruptError</code>           \u2013            <p>Raised to interrupt the kernel.</p> </li> <li> <code>AsyncDisplayHook</code>           \u2013            <p>A displayhook subclass that publishes data using iopub_send.</p> </li> <li> <code>AsyncDisplayPublisher</code>           \u2013            <p>A display publisher that publishes data using iopub_send.</p> </li> <li> <code>SubshellManager</code>           \u2013            <p>Manages all instances of subshells.</p> </li> <li> <code>KernelMagics</code>           \u2013            <p>Extra magics for async kernel.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>__all__</code>           \u2013            </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncInteractiveShell']\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell","title":"AsyncInteractiveShell","text":"<p>               Bases: <code>InteractiveShell</code></p> <p>An IPython InteractiveShell adapted to work with Async kernel.</p> Notable differences <ul> <li>All execute requests are run asynchronously.</li> <li>Supports a soft timeout specified via tags <code>timeout=&lt;value in seconds&gt;</code><sup>1</sup>.</li> <li>Not all features are support (see \"not-supported\" features listed below).</li> <li><code>user_ns</code> and <code>user_global_ns</code> are same dictionary which is a fixed <code>LastUpdatedDict</code>.</li> </ul> <ol> <li> <p>When the execution time exceeds the timeout value, the code execution will \"move on\".\u00a0\u21a9</p> </li> </ol> Referenced by: <ul> <li> Reference <ul> <li> kernel <ul> <li> <code></code>\u00a0Kernel </li> <li> <code></code>\u00a0kernel </li> </ul> </li> <li> typing <ul> <li> <code></code>\u00a0Tags </li> <li> <code></code>\u00a0typing </li> </ul> </li> </ul> </li> </ul> Returned by: <ul> <li> Reference <ul> <li> asyncshell <code></code>\u00a0SubshellManager <code></code>\u00a0get_shell </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0shell </li> </ul> </li> </ul> Subclassed by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveSubshell </li> </ul> <p>Methods:</p> <ul> <li> <code>init_hooks</code>             \u2013              <p>Initialize hooks.</p> </li> <li> <code>execute_request</code>             \u2013              <p>Handle a execute request.</p> </li> <li> <code>do_complete_request</code>             \u2013              <p>Handle a completion request.</p> </li> <li> <code>is_complete_request</code>             \u2013              <p>Handle an is_complete request.</p> </li> <li> <code>inspect_request</code>             \u2013              <p>Handle a inspect request.</p> </li> <li> <code>history_request</code>             \u2013              <p>Handle a history request.</p> </li> <li> <code>init_magics</code>             \u2013              <p>Initialize magics.</p> </li> <li> <code>enable_matplotlib</code>             \u2013              <p>Enable interactive matplotlib and inline figure support.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timeout</code>           \u2013            <p>A timeout in seconds to complete execute requests.</p> </li> <li> <code>stop_on_error_time_offset</code>           \u2013            <p>An offset to add to the cancellation time to catch late arriving execute requests.</p> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class AsyncInteractiveShell(InteractiveShell):\n    \"\"\"\n    An IPython InteractiveShell adapted to work with [Async kernel][async_kernel.kernel.Kernel].\n\n    Notable differences:\n        - All [execute requests][async_kernel.asyncshell.AsyncInteractiveShell.execute_request] are run asynchronously.\n        - Supports a soft timeout specified via tags `timeout=&lt;value in seconds&gt;`[^1].\n        - Not all features are support (see \"not-supported\" features listed below).\n        - `user_ns` and `user_global_ns` are same dictionary which is a fixed `LastUpdatedDict`.\n\n        [^1]: When the execution time exceeds the timeout value, the code execution will \"move on\".\n    \"\"\"\n\n    DEFAULT_MATPLOTLIB_BACKENDS = [\"inline\", \"ipympl\"]\n\n    _execution_count = 0\n    _resetting = False\n    displayhook_class = Type(AsyncDisplayHook)\n    display_pub_class = Type(AsyncDisplayPublisher)\n    displayhook: Instance[AsyncDisplayHook]\n    display_pub: Instance[AsyncDisplayPublisher]\n    compiler_class = Type(XCachingCompiler)\n    compile: Instance[XCachingCompiler]\n    kernel: Instance[Kernel] = Instance(\"async_kernel.Kernel\", (), read_only=True)\n\n    pending_manager = Fixed(ShellPendingManager)\n    subshell_id = Fixed(lambda _: None)\n\n    user_ns_hidden: Fixed[Self, dict] = Fixed(lambda c: c[\"owner\"]._get_default_ns())\n    user_global_ns: Fixed[Self, dict] = Fixed(lambda c: c[\"owner\"]._user_ns)  # pyright: ignore[reportIncompatibleMethodOverride]\n\n    _user_ns: Fixed[Self, LastUpdatedDict] = Fixed(LastUpdatedDict)  # pyright: ignore[reportIncompatibleVariableOverride]\n    _main_mod_cache = Fixed(dict)\n    _stop_on_error_pool: Fixed[Self, set[Callable[[], object]]] = Fixed(set)\n    _stop_on_error_info: Fixed[Self, dict[Literal[\"time\", \"execution_count\"], Any]] = Fixed(dict)\n\n    timeout = CFloat(0.0)\n    \"A timeout in seconds to complete [execute requests][async_kernel.asyncshell.AsyncInteractiveShell.execute_request].\"\n\n    stop_on_error_time_offset = Float(0.0)\n    \"An offset to add to the cancellation time to catch late arriving execute requests.\"\n\n    loop_runner_map = None\n    loop_runner = None\n    autoindent = False\n\n    @override\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}  kernel_name: {self.kernel.kernel_name!r} subshell_id: {self.subshell_id}&gt;\"\n\n    @override\n    def __init__(self, parent: None | Configurable = None) -&gt; None:\n        super().__init__(parent=parent)\n        with contextlib.suppress(AttributeError):\n            utils.mark_thread_pydev_do_not_trace(self.history_manager.save_thread)  # pyright: ignore[reportOptionalMemberAccess]\n\n    def _get_default_ns(self):\n        # Copied from `InteractiveShell.init_user_ns`\n        history = self.history_manager\n        return {\n            \"_ih\": getattr(history, \"input_hist_parsed\", False),\n            \"_oh\": getattr(history, \"output_hist\", None),\n            \"_dh\": getattr(history, \"dir_hist\", \".\"),\n            \"In\": getattr(history, \"input_hist_parsed\", False),\n            \"Out\": getattr(history, \"output_hist\", False),\n            \"get_ipython\": self.get_ipython,\n            \"exit\": self.exiter,\n            \"quit\": self.exiter,\n            \"open\": _modified_open_,\n        }\n\n    @default(\"banner1\")\n    def _default_banner1(self) -&gt; str:\n        return (\n            f\"Python {sys.version}\\n\"\n            f\"Async kernel ({self.kernel.kernel_name})\\n\"\n            f\"IPython shell {IPython.core.release.version}\\n\"\n        )\n\n    @observe(\"exit_now\")\n    def _update_exit_now(self, _) -&gt; None:\n        \"\"\"Stop eventloop when `exit_now` fires.\"\"\"\n        if self.exit_now:\n            self.kernel.stop()\n\n    def ask_exit(self) -&gt; None:\n        if self.kernel.interface.raw_input(\"Are you sure you want to stop the kernel?\\ny/[n]\\n\") == \"y\":\n            self.exit_now = True\n\n    @override\n    def init_create_namespaces(self, user_module=None, user_ns=None) -&gt; None:\n        return\n\n    @override\n    def save_sys_module_state(self) -&gt; None:\n        return\n\n    @override\n    def init_sys_modules(self) -&gt; None:\n        return\n\n    @override\n    def init_user_ns(self) -&gt; None:\n        return\n\n    @override\n    def init_hooks(self):\n        \"\"\"Initialize hooks.\"\"\"\n        super().init_hooks()\n\n        def _show_in_pager(self, data: str | dict, start=0, screen_lines=0, pager_cmd=None) -&gt; None:\n            \"Handle IPython page calls\"\n            if isinstance(data, dict):\n                self.kernel.interface.iopub_send(\"display_data\", content=data)\n            else:\n                self.kernel.interface.iopub_send(\"stream\", content={\"name\": \"stdout\", \"text\": data})\n\n        self.set_hook(\"show_in_pager\", _show_in_pager, 99)\n\n    @property\n    @override\n    def execution_count(self) -&gt; int:\n        return self._execution_count\n\n    @execution_count.setter\n    def execution_count(self, value) -&gt; None:\n        return\n\n    @property\n    @override\n    def user_ns(self) -&gt; dict[Any, Any]:\n        ns = self._user_ns\n        if \"_ih\" not in self._user_ns:\n            ns.update(self._get_default_ns())\n        return ns\n\n    @user_ns.setter\n    def user_ns(self, ns) -&gt; None:\n        ns = dict(ns)\n        self.user_ns_hidden.clear()\n        self._user_ns.clear()\n        self.init_user_ns()\n        ns_ = self._get_default_ns()\n        self.user_ns_hidden.update(ns_)\n        self._user_ns.update(ns_)\n        self._user_ns.update(ns)\n\n    @property\n    @override\n    def ns_table(self) -&gt; dict[str, dict[Any, Any] | dict[str, Any]]:\n        return {\"user_global\": self.user_global_ns, \"user_local\": self.user_ns, \"builtin\": builtins.__dict__}\n\n    async def execute_request(\n        self,\n        code: str = \"\",\n        silent: bool = False,\n        store_history: bool = True,\n        user_expressions: dict[str, str] | None = None,\n        allow_stdin: bool = True,\n        stop_on_error: bool = True,\n        **_ignored,\n    ) -&gt; Content:\n        \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n        if (utils.get_job().get(\"received_time\", 0.0) &lt; self._stop_on_error_info.get(\"time\", 0)) and not silent:\n            return utils.error_to_content(RuntimeError(\"Aborting due to prior exception\")) | {\n                \"execution_count\": self._stop_on_error_info.get(\"execution_count\", 0)\n            }\n\n        tags: list[str] = utils.get_tags()\n        timeout: float = utils.get_timeout(tags=tags)\n        suppress_error: bool = Tags.suppress_error in tags\n        raises_exception: bool = Tags.raises_exception in tags\n        stop_on_error_override: bool = Tags.stop_on_error in tags\n\n        if stop_on_error_override:\n            stop_on_error = utils.get_tag_value(Tags.stop_on_error, stop_on_error)\n        elif suppress_error or raises_exception:\n            stop_on_error = False\n\n        if silent:\n            execution_count: int = self.execution_count\n        else:\n            execution_count = self._execution_count = self._execution_count + 1\n            self.kernel.iopub_send(\n                msg_or_type=\"execute_input\",\n                content={\"code\": code, \"execution_count\": execution_count},\n                ident=self.kernel.topic(\"execute_input\"),\n            )\n        caller = Caller()\n        err = None\n        with anyio.CancelScope() as scope:\n\n            def cancel():\n                if not silent:\n                    caller.call_direct(scope.cancel, \"Interrupted\")\n\n            result = None\n            try:\n                self.kernel.interface.interrupts.add(cancel)\n                if stop_on_error:\n                    self._stop_on_error_pool.add(cancel)\n                with anyio.fail_after(delay=timeout or None):\n                    result = await self.run_cell_async(\n                        raw_cell=code,\n                        store_history=store_history,\n                        silent=silent,\n                        transformed_cell=self.transform_cell(code),\n                        shell_futures=True,\n                    )\n            except (Exception, anyio.get_cancelled_exc_class()) as e:\n                # A safeguard to catch exceptions not caught by the shell.\n                err = KernelInterruptError() if self.kernel.interface.last_interrupt_frame else e\n            else:\n                err = result.error_before_exec or result.error_in_exec if result else KernelInterruptError()\n                if not err and Tags.raises_exception in tags:\n                    msg = \"An expected exception was not raised!\"\n                    err = RuntimeError(msg)\n            finally:\n                self._stop_on_error_pool.discard(cancel)\n                self.kernel.interface.interrupts.discard(cancel)\n                self.events.trigger(\"post_execute\")\n                if not silent:\n                    self.events.trigger(\"post_run_cell\", result)\n        if (err) and (suppress_error or (isinstance(err, anyio.get_cancelled_exc_class()) and (timeout != 0))):\n            # Suppress the error due to either:\n            # 1. tag\n            # 2. timeout\n            err = None\n        content = {\n            \"status\": \"error\" if err else \"ok\",\n            \"execution_count\": execution_count,\n            \"user_expressions\": self.user_expressions(user_expressions if user_expressions is not None else {}),\n        }\n        if err:\n            content |= utils.error_to_content(err)\n            if (not silent) and stop_on_error:\n                with anyio.CancelScope(shield=True):\n                    await Caller().checkpoint()\n                    self._stop_on_error_info[\"time\"] = time.monotonic() + (self.stop_on_error_time_offset)\n                    self._stop_on_error_info[\"execution_count\"] = execution_count\n                    self.log.info(\"An error occurred in a non-silent execution request\")\n                    if stop_on_error:\n                        for c in frozenset(self._stop_on_error_pool):\n                            c()\n        return content\n\n    async def do_complete_request(self, code: str, cursor_pos: int | None = None) -&gt; Content:\n        \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n\n        cursor_pos = cursor_pos or len(code)\n        with provisionalcompleter():\n            completions = self.Completer.completions(code, cursor_pos)\n            completions = list(rectify_completions(code, completions))\n        comps = [\n            {\n                \"start\": comp.start,\n                \"end\": comp.end,\n                \"text\": comp.text,\n                \"type\": comp.type,\n                \"signature\": comp.signature,\n            }\n            for comp in completions\n        ]\n        s, e = (completions[0].start, completions[0].end) if completions else (cursor_pos, cursor_pos)\n        matches = [c.text for c in completions]\n        return {\n            \"matches\": matches,\n            \"cursor_end\": e,\n            \"cursor_start\": s,\n            \"metadata\": {\"_jupyter_types_experimental\": comps},\n            \"status\": \"ok\",\n        }\n\n    async def is_complete_request(self, code: str) -&gt; Content:\n        \"\"\"Handle an [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n        status, indent_spaces = self.input_transformer_manager.check_complete(code)\n        content = {\"status\": status}\n        if status == \"incomplete\":\n            content[\"indent\"] = \" \" * indent_spaces\n        return content\n\n    async def inspect_request(self, code: str, cursor_pos: int = 0, detail_level: Literal[0, 1] = 0) -&gt; Content:\n        \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n        content = {\"data\": {}, \"metadata\": {}, \"found\": True}\n        try:\n            oname = token_at_cursor(code, cursor_pos)\n            bundle = self.object_inspect_mime(oname, detail_level=detail_level)\n            content[\"data\"] = bundle\n        except KeyError:\n            content[\"found\"] = False\n        return content\n\n    async def history_request(\n        self,\n        *,\n        output: bool = False,\n        raw: bool = True,\n        hist_access_type: str,\n        session: int = 0,\n        start: int = 1,\n        stop: int | None = None,\n        n: int = 10,\n        pattern: str = \"*\",\n        unique: bool = False,\n        **_ignored,\n    ) -&gt; Content:\n        \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n        history_manager: HistoryManager = self.history_manager  # pyright: ignore[reportAssignmentType]\n        assert history_manager\n        match hist_access_type:\n            case \"tail\":\n                hist = history_manager.get_tail(n=n, raw=raw, output=output, include_latest=False)\n            case \"range\":\n                hist = history_manager.get_range(session, start, stop, raw, output)\n            case \"search\":\n                hist = history_manager.search(pattern=pattern, raw=raw, output=output, n=n, unique=unique)\n            case _:\n                hist = []\n        return {\"history\": list(hist), \"status\": \"ok\"}\n\n    @override\n    def _showtraceback(self, etype, evalue, stb) -&gt; None:\n        if Tags.suppress_error in utils.get_tags():\n            if msg := utils.get_tag_value(Tags.suppress_error, \"\u26a0\"):\n                print(msg)\n            return\n        if utils.get_timeout() != 0.0 and etype is anyio.get_cancelled_exc_class():\n            etype, evalue, stb = TimeoutError, \"Cell execute timeout\", []\n        self.kernel.iopub_send(\n            msg_or_type=\"error\",\n            content={\"traceback\": stb, \"ename\": str(etype.__name__), \"evalue\": str(evalue)},\n        )\n\n    @override\n    def reset(self, new_session=True, aggressive=False):\n        if not self._resetting:\n            self._resetting = True\n            try:\n                super().reset(new_session, aggressive)\n                for pen in self.pending_manager.pending:\n                    pen.cancel()\n                if new_session:\n                    self._execution_count = 0\n                    self._stop_on_error_info.clear()\n            finally:\n                self._resetting = False\n\n    @override\n    def init_magics(self) -&gt; None:\n        \"\"\"Initialize magics.\"\"\"\n        super().init_magics()\n        self.register_magics(KernelMagics)\n\n    @override\n    def enable_gui(self, gui=None) -&gt; None:\n        if (gui is not None) and (gui not in (supported := self._list_matplotlib_backends_and_gui_loops())):\n            msg = f\"The gui {gui!r} is not one of the supported gui options for this thread! {supported}=\"\n            raise RuntimeError(msg)\n\n    @override\n    def enable_matplotlib(self, gui: str | None = None) -&gt; tuple[str | Any | None, Any | str]:  # pragma: no cover\n        \"\"\"\n        Enable interactive matplotlib and inline figure support.\n\n        This takes the following steps:\n\n        1. select the appropriate matplotlib backend\n        2. set up matplotlib for interactive use with that backend\n        3. configure formatters for inline figure display\n\n        Args:\n            gui:\n                If given, dictates the choice of matplotlib GUI backend to use\n                (should be one of IPython's supported backends, 'qt', 'osx', 'tk',\n                'gtk', 'wx' or 'inline', 'ipympl'), otherwise we use the default chosen by\n                matplotlib (as dictated by the matplotlib build-time options plus the\n                user's matplotlibrc configuration file).  Note that not all backends\n                make sense in all contexts, for example a terminal ipython can't\n                display figures inline.\n        \"\"\"\n        import matplotlib_inline.backend_inline  # noqa: PLC0415\n        from IPython.core import pylabtools as pt  # noqa: PLC0415\n\n        backends = self._list_matplotlib_backends_and_gui_loops()\n        gui = gui or backends[0]  # Use the\n        gui, backend = pt.find_gui_and_backend(gui, self.pylab_gui_select)\n        self.enable_gui(gui)\n        try:\n            pt.activate_matplotlib(backend)\n        except RuntimeError as e:\n            e.add_note(f\"This thread supports the gui {gui!s} but pyplot only supports one interactive backend.\")\n\n        matplotlib_inline.backend_inline.configure_inline_support(self, backend)\n\n        # Now we must activate the gui pylab wants to use, and fix %run to take\n        # plot updates into account\n        self.magics_manager.registry[\"ExecutionMagics\"].default_runner = pt.mpl_runner(self.safe_execfile)\n\n        return gui, backend\n\n    def _list_matplotlib_backends_and_gui_loops(self) -&gt; list[str | None]:\n        return [*get_runtime_matplotlib_guis(), *self.DEFAULT_MATPLOTLIB_BACKENDS]\n\n    @contextlib.contextmanager\n    def context(self) -&gt; Generator[None, Any, None]:\n        with self.pending_manager.context():\n            yield\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout = CFloat(0.0)\n</code></pre> <p>A timeout in seconds to complete execute requests.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.stop_on_error_time_offset","title":"stop_on_error_time_offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_on_error_time_offset = Float(0.0)\n</code></pre> <p>An offset to add to the cancellation time to catch late arriving execute requests.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.init_hooks","title":"init_hooks","text":"<pre><code>init_hooks()\n</code></pre> <p>Initialize hooks.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef init_hooks(self):\n    \"\"\"Initialize hooks.\"\"\"\n    super().init_hooks()\n\n    def _show_in_pager(self, data: str | dict, start=0, screen_lines=0, pager_cmd=None) -&gt; None:\n        \"Handle IPython page calls\"\n        if isinstance(data, dict):\n            self.kernel.interface.iopub_send(\"display_data\", content=data)\n        else:\n            self.kernel.interface.iopub_send(\"stream\", content={\"name\": \"stdout\", \"text\": data})\n\n    self.set_hook(\"show_in_pager\", _show_in_pager, 99)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.execute_request","title":"execute_request  <code>async</code>","text":"<pre><code>execute_request(\n    code: str = \"\",\n    silent: bool = False,\n    store_history: bool = True,\n    user_expressions: dict[str, str] | None = None,\n    allow_stdin: bool = True,\n    stop_on_error: bool = True,\n    **_ignored,\n) -&gt; Content\n</code></pre> <p>Handle a execute request.</p> Referenced by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveShell <code></code>\u00a0timeout </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>async def execute_request(\n    self,\n    code: str = \"\",\n    silent: bool = False,\n    store_history: bool = True,\n    user_expressions: dict[str, str] | None = None,\n    allow_stdin: bool = True,\n    stop_on_error: bool = True,\n    **_ignored,\n) -&gt; Content:\n    \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n    if (utils.get_job().get(\"received_time\", 0.0) &lt; self._stop_on_error_info.get(\"time\", 0)) and not silent:\n        return utils.error_to_content(RuntimeError(\"Aborting due to prior exception\")) | {\n            \"execution_count\": self._stop_on_error_info.get(\"execution_count\", 0)\n        }\n\n    tags: list[str] = utils.get_tags()\n    timeout: float = utils.get_timeout(tags=tags)\n    suppress_error: bool = Tags.suppress_error in tags\n    raises_exception: bool = Tags.raises_exception in tags\n    stop_on_error_override: bool = Tags.stop_on_error in tags\n\n    if stop_on_error_override:\n        stop_on_error = utils.get_tag_value(Tags.stop_on_error, stop_on_error)\n    elif suppress_error or raises_exception:\n        stop_on_error = False\n\n    if silent:\n        execution_count: int = self.execution_count\n    else:\n        execution_count = self._execution_count = self._execution_count + 1\n        self.kernel.iopub_send(\n            msg_or_type=\"execute_input\",\n            content={\"code\": code, \"execution_count\": execution_count},\n            ident=self.kernel.topic(\"execute_input\"),\n        )\n    caller = Caller()\n    err = None\n    with anyio.CancelScope() as scope:\n\n        def cancel():\n            if not silent:\n                caller.call_direct(scope.cancel, \"Interrupted\")\n\n        result = None\n        try:\n            self.kernel.interface.interrupts.add(cancel)\n            if stop_on_error:\n                self._stop_on_error_pool.add(cancel)\n            with anyio.fail_after(delay=timeout or None):\n                result = await self.run_cell_async(\n                    raw_cell=code,\n                    store_history=store_history,\n                    silent=silent,\n                    transformed_cell=self.transform_cell(code),\n                    shell_futures=True,\n                )\n        except (Exception, anyio.get_cancelled_exc_class()) as e:\n            # A safeguard to catch exceptions not caught by the shell.\n            err = KernelInterruptError() if self.kernel.interface.last_interrupt_frame else e\n        else:\n            err = result.error_before_exec or result.error_in_exec if result else KernelInterruptError()\n            if not err and Tags.raises_exception in tags:\n                msg = \"An expected exception was not raised!\"\n                err = RuntimeError(msg)\n        finally:\n            self._stop_on_error_pool.discard(cancel)\n            self.kernel.interface.interrupts.discard(cancel)\n            self.events.trigger(\"post_execute\")\n            if not silent:\n                self.events.trigger(\"post_run_cell\", result)\n    if (err) and (suppress_error or (isinstance(err, anyio.get_cancelled_exc_class()) and (timeout != 0))):\n        # Suppress the error due to either:\n        # 1. tag\n        # 2. timeout\n        err = None\n    content = {\n        \"status\": \"error\" if err else \"ok\",\n        \"execution_count\": execution_count,\n        \"user_expressions\": self.user_expressions(user_expressions if user_expressions is not None else {}),\n    }\n    if err:\n        content |= utils.error_to_content(err)\n        if (not silent) and stop_on_error:\n            with anyio.CancelScope(shield=True):\n                await Caller().checkpoint()\n                self._stop_on_error_info[\"time\"] = time.monotonic() + (self.stop_on_error_time_offset)\n                self._stop_on_error_info[\"execution_count\"] = execution_count\n                self.log.info(\"An error occurred in a non-silent execution request\")\n                if stop_on_error:\n                    for c in frozenset(self._stop_on_error_pool):\n                        c()\n    return content\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.do_complete_request","title":"do_complete_request  <code>async</code>","text":"<pre><code>do_complete_request(code: str, cursor_pos: int | None = None) -&gt; Content\n</code></pre> <p>Handle a completion request.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>async def do_complete_request(self, code: str, cursor_pos: int | None = None) -&gt; Content:\n    \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n\n    cursor_pos = cursor_pos or len(code)\n    with provisionalcompleter():\n        completions = self.Completer.completions(code, cursor_pos)\n        completions = list(rectify_completions(code, completions))\n    comps = [\n        {\n            \"start\": comp.start,\n            \"end\": comp.end,\n            \"text\": comp.text,\n            \"type\": comp.type,\n            \"signature\": comp.signature,\n        }\n        for comp in completions\n    ]\n    s, e = (completions[0].start, completions[0].end) if completions else (cursor_pos, cursor_pos)\n    matches = [c.text for c in completions]\n    return {\n        \"matches\": matches,\n        \"cursor_end\": e,\n        \"cursor_start\": s,\n        \"metadata\": {\"_jupyter_types_experimental\": comps},\n        \"status\": \"ok\",\n    }\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.is_complete_request","title":"is_complete_request  <code>async</code>","text":"<pre><code>is_complete_request(code: str) -&gt; Content\n</code></pre> <p>Handle an is_complete request.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>async def is_complete_request(self, code: str) -&gt; Content:\n    \"\"\"Handle an [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n    status, indent_spaces = self.input_transformer_manager.check_complete(code)\n    content = {\"status\": status}\n    if status == \"incomplete\":\n        content[\"indent\"] = \" \" * indent_spaces\n    return content\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.inspect_request","title":"inspect_request  <code>async</code>","text":"<pre><code>inspect_request(\n    code: str, cursor_pos: int = 0, detail_level: Literal[0, 1] = 0\n) -&gt; Content\n</code></pre> <p>Handle a inspect request.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>async def inspect_request(self, code: str, cursor_pos: int = 0, detail_level: Literal[0, 1] = 0) -&gt; Content:\n    \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n    content = {\"data\": {}, \"metadata\": {}, \"found\": True}\n    try:\n        oname = token_at_cursor(code, cursor_pos)\n        bundle = self.object_inspect_mime(oname, detail_level=detail_level)\n        content[\"data\"] = bundle\n    except KeyError:\n        content[\"found\"] = False\n    return content\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.history_request","title":"history_request  <code>async</code>","text":"<pre><code>history_request(\n    *,\n    output: bool = False,\n    raw: bool = True,\n    hist_access_type: str,\n    session: int = 0,\n    start: int = 1,\n    stop: int | None = None,\n    n: int = 10,\n    pattern: str = \"*\",\n    unique: bool = False,\n    **_ignored,\n) -&gt; Content\n</code></pre> <p>Handle a history request.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>async def history_request(\n    self,\n    *,\n    output: bool = False,\n    raw: bool = True,\n    hist_access_type: str,\n    session: int = 0,\n    start: int = 1,\n    stop: int | None = None,\n    n: int = 10,\n    pattern: str = \"*\",\n    unique: bool = False,\n    **_ignored,\n) -&gt; Content:\n    \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n    history_manager: HistoryManager = self.history_manager  # pyright: ignore[reportAssignmentType]\n    assert history_manager\n    match hist_access_type:\n        case \"tail\":\n            hist = history_manager.get_tail(n=n, raw=raw, output=output, include_latest=False)\n        case \"range\":\n            hist = history_manager.get_range(session, start, stop, raw, output)\n        case \"search\":\n            hist = history_manager.search(pattern=pattern, raw=raw, output=output, n=n, unique=unique)\n        case _:\n            hist = []\n    return {\"history\": list(hist), \"status\": \"ok\"}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.init_magics","title":"init_magics","text":"<pre><code>init_magics() -&gt; None\n</code></pre> <p>Initialize magics.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef init_magics(self) -&gt; None:\n    \"\"\"Initialize magics.\"\"\"\n    super().init_magics()\n    self.register_magics(KernelMagics)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.enable_matplotlib","title":"enable_matplotlib","text":"<pre><code>enable_matplotlib(gui: str | None = None) -&gt; tuple[str | Any | None, Any | str]\n</code></pre> <p>Enable interactive matplotlib and inline figure support.</p> <p>This takes the following steps:</p> <ol> <li>select the appropriate matplotlib backend</li> <li>set up matplotlib for interactive use with that backend</li> <li>configure formatters for inline figure display</li> </ol> <p>Parameters:</p> <ul> <li> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef enable_matplotlib(self, gui: str | None = None) -&gt; tuple[str | Any | None, Any | str]:  # pragma: no cover\n    \"\"\"\n    Enable interactive matplotlib and inline figure support.\n\n    This takes the following steps:\n\n    1. select the appropriate matplotlib backend\n    2. set up matplotlib for interactive use with that backend\n    3. configure formatters for inline figure display\n\n    Args:\n        gui:\n            If given, dictates the choice of matplotlib GUI backend to use\n            (should be one of IPython's supported backends, 'qt', 'osx', 'tk',\n            'gtk', 'wx' or 'inline', 'ipympl'), otherwise we use the default chosen by\n            matplotlib (as dictated by the matplotlib build-time options plus the\n            user's matplotlibrc configuration file).  Note that not all backends\n            make sense in all contexts, for example a terminal ipython can't\n            display figures inline.\n    \"\"\"\n    import matplotlib_inline.backend_inline  # noqa: PLC0415\n    from IPython.core import pylabtools as pt  # noqa: PLC0415\n\n    backends = self._list_matplotlib_backends_and_gui_loops()\n    gui = gui or backends[0]  # Use the\n    gui, backend = pt.find_gui_and_backend(gui, self.pylab_gui_select)\n    self.enable_gui(gui)\n    try:\n        pt.activate_matplotlib(backend)\n    except RuntimeError as e:\n        e.add_note(f\"This thread supports the gui {gui!s} but pyplot only supports one interactive backend.\")\n\n    matplotlib_inline.backend_inline.configure_inline_support(self, backend)\n\n    # Now we must activate the gui pylab wants to use, and fix %run to take\n    # plot updates into account\n    self.magics_manager.registry[\"ExecutionMagics\"].default_runner = pt.mpl_runner(self.safe_execfile)\n\n    return gui, backend\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.enable_matplotlib(gui)","title":"<code>gui</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If given, dictates the choice of matplotlib GUI backend to use (should be one of IPython's supported backends, 'qt', 'osx', 'tk', 'gtk', 'wx' or 'inline', 'ipympl'), otherwise we use the default chosen by matplotlib (as dictated by the matplotlib build-time options plus the user's matplotlibrc configuration file).  Note that not all backends make sense in all contexts, for example a terminal ipython can't display figures inline.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveSubshell","title":"AsyncInteractiveSubshell","text":"<p>               Bases: <code>AsyncInteractiveShell</code></p> <p>An asynchronous interactive subshell for managing isolated execution contexts within an async kernel.</p> <p>Each subshell has a unique <code>user_ns</code>, but shares its <code>user_global_ns</code> with the main shell (which is also the <code>user_ns</code> of the main shell).</p> <p>Call <code>subshell.stop(force=True)</code> to stop a protected subshell when it is no longer required.</p> <p>Attributes:</p> <ul> <li> <code>stopped</code>           \u2013            <p>Indicates whether the subshell has been stopped.</p> </li> <li> <code>protected</code>           \u2013            <p>If True, prevents the subshell from being stopped unless forced.</p> </li> <li> <code>pending_manager</code>           \u2013            <p>Tracks pending started in the context of the subshell.</p> </li> <li> <code>subshell_id</code>               (<code>Fixed[Self, str]</code>)           \u2013            <p>Unique identifier for the subshell.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>stop</code>             \u2013              <p>Stops the subshell, deactivating pending operations and removing it from the manager.</p> </li> </ul> See also <ul> <li>async_kernel.utils.get_subshell_id</li> <li>async_kernel.utils.subshell_context</li> </ul> Referenced by: <ul> <li> Reference asyncshell <ul> <li> <code></code>\u00a0SubshellManager </li> <li> <code></code>\u00a0asyncshell </li> </ul> </li> </ul> Returned by: <ul> <li> Reference <ul> <li> asyncshell <code></code>\u00a0SubshellManager <ul> <li> <code></code>\u00a0create_subshell </li> <li> <code></code>\u00a0get_shell </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0shell </li> </ul> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class AsyncInteractiveSubshell(AsyncInteractiveShell):\n    \"\"\"\n    An asynchronous interactive subshell for managing isolated execution contexts within an async kernel.\n\n    Each subshell has a unique `user_ns`, but shares its `user_global_ns` with the main shell\n    (which is also the `user_ns` of the main shell).\n\n    Call [`subshell.stop(force=True)`][async_kernel.asyncshell.AsyncInteractiveSubshell.stop] to stop a\n    protected subshell when it is no longer required.\n\n    Attributes:\n        stopped: Indicates whether the subshell has been stopped.\n        protected: If True, prevents the subshell from being stopped unless forced.\n        pending_manager: Tracks pending started in the context of the subshell.\n        subshell_id: Unique identifier for the subshell.\n\n    Methods:\n        stop: Stops the subshell, deactivating pending operations and removing it from the manager.\n\n    See also:\n        - [async_kernel.utils.get_subshell_id][]\n        - [async_kernel.utils.subshell_context][]\n    \"\"\"\n\n    stopped = traitlets.Bool(read_only=True)\n    protected = traitlets.Bool(read_only=True)\n    subshell_id: Fixed[Self, str] = Fixed(lambda c: c[\"owner\"].pending_manager.id)\n\n    @override\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} kernel_name: {self.kernel.kernel_name!r}  subshell_id: {self.subshell_id}{'  stopped' if self.stopped else ''}&gt;\"\n\n    @property\n    @override\n    def user_global_ns(self) -&gt; dict:  # pyright: ignore[reportIncompatibleVariableOverride]\n        return (\n            self.kernel.main_shell.user_global_ns.copy() if self._resetting else self.kernel.main_shell.user_global_ns\n        )\n\n    @override\n    def __init__(self, *, protected: bool = True) -&gt; None:\n        super().__init__(parent=self.kernel.main_shell)\n        self.set_trait(\"protected\", protected)\n        self.stop_on_error_time_offset = self.kernel.main_shell.stop_on_error_time_offset\n        self.kernel.subshell_manager.subshells[self.subshell_id] = self\n\n    def stop(self, *, force=False) -&gt; None:\n        \"Stop this subshell.\"\n        if force or not self.protected:\n            for pen in self.pending_manager.pending:\n                pen.cancel(f\"Subshell {self.subshell_id} is stopping.\")\n            self.reset(new_session=False)\n            self.kernel.subshell_manager.subshells.pop(self.subshell_id, None)\n            self.set_trait(\"stopped\", True)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveSubshell.stop","title":"stop","text":"<pre><code>stop(*, force=False) -&gt; None\n</code></pre> <p>Stop this subshell.</p> Referenced by: <ul> <li> Reference asyncshell <ul> <li> <code></code>\u00a0AsyncInteractiveSubshell </li> <li> <code></code>\u00a0SubshellManager <ul> <li> <code></code>\u00a0create_subshell </li> <li> <code></code>\u00a0stop_all_subshells </li> </ul> </li> </ul> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def stop(self, *, force=False) -&gt; None:\n    \"Stop this subshell.\"\n    if force or not self.protected:\n        for pen in self.pending_manager.pending:\n            pen.cancel(f\"Subshell {self.subshell_id} is stopping.\")\n        self.reset(new_session=False)\n        self.kernel.subshell_manager.subshells.pop(self.subshell_id, None)\n        self.set_trait(\"stopped\", True)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelInterruptError","title":"KernelInterruptError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised to interrupt the kernel.</p> Referenced by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0BaseKernelInterface </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0interrupt </li> </ul> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class KernelInterruptError(Exception):\n    \"Raised to interrupt the kernel.\"\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook","title":"AsyncDisplayHook","text":"<p>               Bases: <code>DisplayHook</code></p> <p>A displayhook subclass that publishes data using iopub_send.</p> <p>This is intended to work with an InteractiveShell instance. It sends a dict of different representations of the object.</p> <p>Methods:</p> <ul> <li> <code>start_displayhook</code>             \u2013              <p>Start the display hook.</p> </li> <li> <code>write_output_prompt</code>             \u2013              <p>Write the output prompt.</p> </li> <li> <code>write_format_data</code>             \u2013              <p>Write format data to the message.</p> </li> <li> <code>finish_displayhook</code>             \u2013              <p>Finish up all displayhook activities.</p> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class AsyncDisplayHook(DisplayHook):\n    \"\"\"\n    A displayhook subclass that publishes data using [iopub_send][async_kernel.kernel.Kernel.iopub_send].\n\n    This is intended to work with an InteractiveShell instance. It sends a dict of different\n    representations of the object.\n    \"\"\"\n\n    kernel = Fixed(lambda _: utils.get_kernel())\n    content: Dict[str, Any] = Dict()\n\n    @property\n    @override\n    def prompt_count(self) -&gt; int:\n        return self.kernel.shell.execution_count\n\n    @override\n    def start_displayhook(self) -&gt; None:\n        \"\"\"Start the display hook.\"\"\"\n        self.content = {}\n\n    @override\n    def write_output_prompt(self) -&gt; None:\n        \"\"\"Write the output prompt.\"\"\"\n        self.content[\"execution_count\"] = self.prompt_count\n\n    @override\n    def write_format_data(self, format_dict, md_dict=None) -&gt; None:\n        \"\"\"Write format data to the message.\"\"\"\n        self.content[\"data\"] = format_dict\n        self.content[\"metadata\"] = md_dict\n\n    @override\n    def finish_displayhook(self) -&gt; None:\n        \"\"\"Finish up all displayhook activities.\"\"\"\n        if self.content:\n            self.kernel.iopub_send(\"display_data\", content=self.content)\n            self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.start_displayhook","title":"start_displayhook","text":"<pre><code>start_displayhook() -&gt; None\n</code></pre> <p>Start the display hook.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef start_displayhook(self) -&gt; None:\n    \"\"\"Start the display hook.\"\"\"\n    self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_output_prompt","title":"write_output_prompt","text":"<pre><code>write_output_prompt() -&gt; None\n</code></pre> <p>Write the output prompt.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_output_prompt(self) -&gt; None:\n    \"\"\"Write the output prompt.\"\"\"\n    self.content[\"execution_count\"] = self.prompt_count\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_format_data","title":"write_format_data","text":"<pre><code>write_format_data(format_dict, md_dict=None) -&gt; None\n</code></pre> <p>Write format data to the message.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_format_data(self, format_dict, md_dict=None) -&gt; None:\n    \"\"\"Write format data to the message.\"\"\"\n    self.content[\"data\"] = format_dict\n    self.content[\"metadata\"] = md_dict\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.finish_displayhook","title":"finish_displayhook","text":"<pre><code>finish_displayhook() -&gt; None\n</code></pre> <p>Finish up all displayhook activities.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef finish_displayhook(self) -&gt; None:\n    \"\"\"Finish up all displayhook activities.\"\"\"\n    if self.content:\n        self.kernel.iopub_send(\"display_data\", content=self.content)\n        self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher","title":"AsyncDisplayPublisher","text":"<p>               Bases: <code>DisplayPublisher</code></p> <p>A display publisher that publishes data using iopub_send.</p> <p>Methods:</p> <ul> <li> <code>publish</code>             \u2013              <p>Publish a display-data message.</p> </li> <li> <code>clear_output</code>             \u2013              <p>Clear output associated with the current execution (cell).</p> </li> <li> <code>register_hook</code>             \u2013              <p>Register a hook for when publish is called.</p> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class AsyncDisplayPublisher(DisplayPublisher):\n    \"\"\"A display publisher that publishes data using [iopub_send][async_kernel.kernel.Kernel.iopub_send].\"\"\"\n\n    topic: ClassVar = b\"display_data\"\n\n    def __init__(self, shell=None, *args, **kwargs) -&gt; None:\n        super().__init__(shell, *args, **kwargs)\n        self._hooks = []\n\n    @override\n    def publish(  # pyright: ignore[reportIncompatibleMethodOverride]\n        self,\n        data: dict[str, Any],\n        metadata: dict | None = None,\n        *,\n        transient: dict | None = None,\n        update: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Publish a display-data message.\n\n        Args:\n            data: A mime-bundle dict, keyed by mime-type.\n            metadata: Metadata associated with the data.\n            transient: Transient data that may only be relevant during a live display, such as display_id.\n                Transient data should not be persisted to documents.\n            update: If True, send an update_display_data message instead of display_data.\n\n        [Reference](https://jupyter-client.readthedocs.io/en/stable/messaging.html#update-display-data)\n        \"\"\"\n        content = {\"data\": data, \"metadata\": metadata or {}, \"transient\": transient or {}} | kwargs\n        msg_type = \"update_display_data\" if update else \"display_data\"\n        msg = utils.get_kernel().interface.msg(msg_type, content=content, parent=utils.get_parent())\n        for hook in self._hooks:\n            try:\n                msg = hook(msg)\n            except Exception:\n                pass\n            if msg is None:\n                return\n        utils.get_kernel().iopub_send(msg)\n\n    @override\n    def clear_output(self, wait: bool = False) -&gt; None:\n        \"\"\"\n        Clear output associated with the current execution (cell).\n\n        Args:\n            wait: If True, the output will not be cleared immediately,\n                instead waiting for the next display before clearing.\n                This reduces bounce during repeated clear &amp; display loops.\n        \"\"\"\n        utils.get_kernel().iopub_send(msg_or_type=\"clear_output\", content={\"wait\": wait}, ident=self.topic)\n\n    def register_hook(self, hook: Callable[[dict], dict | None]) -&gt; None:\n        \"\"\"Register a hook for when publish is called.\n\n        The hook should return the message or None.\n        Only return `None` when the message should *not* be sent.\n        \"\"\"\n        self._hooks.append(hook)\n\n    def unregister_hook(self, hook: Callable[[dict], dict | None]) -&gt; None:\n        while hook in self._hooks:\n            self._hooks.remove(hook)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish","title":"publish","text":"<pre><code>publish(\n    data: dict[str, Any],\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None\n</code></pre> <p>Publish a display-data message.</p> <p>Parameters:</p> <p>Reference</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef publish(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self,\n    data: dict[str, Any],\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Publish a display-data message.\n\n    Args:\n        data: A mime-bundle dict, keyed by mime-type.\n        metadata: Metadata associated with the data.\n        transient: Transient data that may only be relevant during a live display, such as display_id.\n            Transient data should not be persisted to documents.\n        update: If True, send an update_display_data message instead of display_data.\n\n    [Reference](https://jupyter-client.readthedocs.io/en/stable/messaging.html#update-display-data)\n    \"\"\"\n    content = {\"data\": data, \"metadata\": metadata or {}, \"transient\": transient or {}} | kwargs\n    msg_type = \"update_display_data\" if update else \"display_data\"\n    msg = utils.get_kernel().interface.msg(msg_type, content=content, parent=utils.get_parent())\n    for hook in self._hooks:\n        try:\n            msg = hook(msg)\n        except Exception:\n            pass\n        if msg is None:\n            return\n    utils.get_kernel().iopub_send(msg)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(data)","title":"<code>data</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>A mime-bundle dict, keyed by mime-type.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(metadata)","title":"<code>metadata</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata associated with the data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(transient)","title":"<code>transient</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Transient data that may only be relevant during a live display, such as display_id. Transient data should not be persisted to documents.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(update)","title":"<code>update</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, send an update_display_data message instead of display_data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output","title":"clear_output","text":"<pre><code>clear_output(wait: bool = False) -&gt; None\n</code></pre> <p>Clear output associated with the current execution (cell).</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef clear_output(self, wait: bool = False) -&gt; None:\n    \"\"\"\n    Clear output associated with the current execution (cell).\n\n    Args:\n        wait: If True, the output will not be cleared immediately,\n            instead waiting for the next display before clearing.\n            This reduces bounce during repeated clear &amp; display loops.\n    \"\"\"\n    utils.get_kernel().iopub_send(msg_or_type=\"clear_output\", content={\"wait\": wait}, ident=self.topic)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output(wait)","title":"<code>wait</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the output will not be cleared immediately, instead waiting for the next display before clearing. This reduces bounce during repeated clear &amp; display loops.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.register_hook","title":"register_hook","text":"<pre><code>register_hook(hook: Callable[[dict], dict | None]) -&gt; None\n</code></pre> <p>Register a hook for when publish is called.</p> <p>The hook should return the message or None. Only return <code>None</code> when the message should not be sent.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def register_hook(self, hook: Callable[[dict], dict | None]) -&gt; None:\n    \"\"\"Register a hook for when publish is called.\n\n    The hook should return the message or None.\n    Only return `None` when the message should *not* be sent.\n    \"\"\"\n    self._hooks.append(hook)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager","title":"SubshellManager","text":"<p>Manages all instances of subshells.</p> <p>Warning:</p> <pre><code>**Do NOT instantiate directly.** Instead access the instance via [async_kernel.kernel.Kernel.subshell_manager][].\n</code></pre> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0subshell_manager </li> </ul> <p>Methods:</p> <ul> <li> <code>create_subshell</code>             \u2013              <p>Create a new instance of the default subshell class.</p> </li> <li> <code>get_shell</code>             \u2013              <p>Get a subshell or the main shell.</p> </li> <li> <code>delete_subshell</code>             \u2013              <p>Stop a subshell unless it is protected.</p> </li> <li> <code>stop_all_subshells</code>             \u2013              <p>Stop all current subshells.</p> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class SubshellManager:\n    \"\"\"\n    Manages all instances of [subshells][async_kernel.asyncshell.AsyncInteractiveSubshell].\n\n    Warning:\n\n        **Do NOT instantiate directly.** Instead access the instance via [async_kernel.kernel.Kernel.subshell_manager][].\n    \"\"\"\n\n    __slots__ = [\"__weakref__\"]\n\n    main_shell: Fixed[Self, AsyncInteractiveShell] = Fixed(lambda _: utils.get_kernel().main_shell)\n    _main_shell_pending_manager_id: Fixed[Self, str] = Fixed(lambda c: c[\"owner\"].main_shell.pending_manager.id)\n    subshells: dict[str, AsyncInteractiveSubshell] = {}\n    default_subshell_class = AsyncInteractiveSubshell\n\n    def create_subshell(self, *, protected: bool = True) -&gt; AsyncInteractiveSubshell:\n        \"\"\"\n        Create a new instance of the default subshell class.\n\n        Call [`subshell.stop(force=True)`][async_kernel.asyncshell.AsyncInteractiveSubshell.stop] to stop a\n        protected subshell when it is no longer required.\n\n        Args:\n            protected: Protect the subshell from accidental deletion.\n        \"\"\"\n        return self.default_subshell_class(protected=protected)\n\n    def list_subshells(self) -&gt; list[str]:\n        return list(self.subshells)\n\n    if TYPE_CHECKING:\n\n        @overload\n        def get_shell(self, subshell_id: str) -&gt; AsyncInteractiveSubshell: ...\n        @overload\n        def get_shell(self, subshell_id: None = ...) -&gt; AsyncInteractiveShell: ...\n\n    def get_shell(\n        self,\n        subshell_id: str | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ) -&gt; AsyncInteractiveShell | AsyncInteractiveSubshell:\n        \"\"\"\n        Get a subshell or the main shell.\n\n        Args:\n            subshell_id: The id of an existing subshell.\n        \"\"\"\n        if subshell_id is NoValue:\n            subshell_id = ShellPendingManager.active_id()\n        if subshell_id is None or subshell_id == self._main_shell_pending_manager_id:\n            return self.main_shell\n        return self.subshells[subshell_id]\n\n    def delete_subshell(self, subshell_id: str) -&gt; None:\n        \"\"\"\n        Stop a subshell unless it is protected.\n\n        Args:\n            subshell_id: The id of an existing subshell to stop.\n        \"\"\"\n        if subshell := self.subshells.get(subshell_id):\n            subshell.stop()\n\n    def stop_all_subshells(self, *, force: bool = False) -&gt; None:\n        \"\"\"Stop all current subshells.\n\n        Args:\n            force: Passed to [async_kernel.asyncshell.AsyncInteractiveSubshell.stop][].\n        \"\"\"\n        for subshell in set(self.subshells.values()):\n            subshell.stop(force=force)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.create_subshell","title":"create_subshell","text":"<pre><code>create_subshell(*, protected: bool = True) -&gt; AsyncInteractiveSubshell\n</code></pre> <p>Create a new instance of the default subshell class.</p> <p>Call <code>subshell.stop(force=True)</code> to stop a protected subshell when it is no longer required.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def create_subshell(self, *, protected: bool = True) -&gt; AsyncInteractiveSubshell:\n    \"\"\"\n    Create a new instance of the default subshell class.\n\n    Call [`subshell.stop(force=True)`][async_kernel.asyncshell.AsyncInteractiveSubshell.stop] to stop a\n    protected subshell when it is no longer required.\n\n    Args:\n        protected: Protect the subshell from accidental deletion.\n    \"\"\"\n    return self.default_subshell_class(protected=protected)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.create_subshell(protected)","title":"<code>protected</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Protect the subshell from accidental deletion.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.get_shell","title":"get_shell","text":"<pre><code>get_shell(subshell_id: str) -&gt; AsyncInteractiveSubshell\n</code></pre><pre><code>get_shell(subshell_id: None = ...) -&gt; AsyncInteractiveShell\n</code></pre> <pre><code>get_shell(\n    subshell_id: str | None | NoValue = NoValue,\n) -&gt; AsyncInteractiveShell | AsyncInteractiveSubshell\n</code></pre> <p>Get a subshell or the main shell.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def get_shell(\n    self,\n    subshell_id: str | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n) -&gt; AsyncInteractiveShell | AsyncInteractiveSubshell:\n    \"\"\"\n    Get a subshell or the main shell.\n\n    Args:\n        subshell_id: The id of an existing subshell.\n    \"\"\"\n    if subshell_id is NoValue:\n        subshell_id = ShellPendingManager.active_id()\n    if subshell_id is None or subshell_id == self._main_shell_pending_manager_id:\n        return self.main_shell\n    return self.subshells[subshell_id]\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.get_shell(subshell_id)","title":"<code>subshell_id</code>","text":"(<code>str | None | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>The id of an existing subshell.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.delete_subshell","title":"delete_subshell","text":"<pre><code>delete_subshell(subshell_id: str) -&gt; None\n</code></pre> <p>Stop a subshell unless it is protected.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def delete_subshell(self, subshell_id: str) -&gt; None:\n    \"\"\"\n    Stop a subshell unless it is protected.\n\n    Args:\n        subshell_id: The id of an existing subshell to stop.\n    \"\"\"\n    if subshell := self.subshells.get(subshell_id):\n        subshell.stop()\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.delete_subshell(subshell_id)","title":"<code>subshell_id</code>","text":"(<code>str</code>)           \u2013            <p>The id of an existing subshell to stop.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.stop_all_subshells","title":"stop_all_subshells","text":"<pre><code>stop_all_subshells(*, force: bool = False) -&gt; None\n</code></pre> <p>Stop all current subshells.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def stop_all_subshells(self, *, force: bool = False) -&gt; None:\n    \"\"\"Stop all current subshells.\n\n    Args:\n        force: Passed to [async_kernel.asyncshell.AsyncInteractiveSubshell.stop][].\n    \"\"\"\n    for subshell in set(self.subshells.values()):\n        subshell.stop(force=force)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.SubshellManager.stop_all_subshells(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Passed to async_kernel.asyncshell.AsyncInteractiveSubshell.stop.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics","title":"KernelMagics","text":"<p>               Bases: <code>Magics</code></p> <p>Extra magics for async kernel.</p> <p>Methods:</p> <ul> <li> <code>connect_info</code>             \u2013              <p>Print information for connecting other clients to this kernel.</p> </li> <li> <code>callers</code>             \u2013              <p>Print a table of Callers, indicating its status including:  -running - protected - on the current thread.</p> </li> <li> <code>subshell</code>             \u2013              <p>Print subshell info ref.</p> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@magics_class\nclass KernelMagics(Magics):\n    \"\"\"Extra magics for async kernel.\"\"\"\n\n    shell: AsyncInteractiveShell  # pyright: ignore[reportIncompatibleVariableOverride]\n\n    @line_magic\n    def connect_info(self, _) -&gt; None:\n        \"\"\"Print information for connecting other clients to this kernel.\"\"\"\n        kernel = utils.get_kernel()\n        connection_file = pathlib.Path(kernel.connection_file)\n        # if it's in the default dir, truncate to basename\n        if jupyter_runtime_dir() == str(connection_file.parent):\n            connection_file = connection_file.name\n        info = kernel.get_connection_info()\n        print(\n            orjson.dumps(info, option=orjson.OPT_INDENT_2).decode(),\n            \"Paste the above JSON into a file, and connect with:\\n\"\n            + \"    $&gt; jupyter &lt;app&gt; --existing &lt;file&gt;\\n\"\n            + \"or, if you are local, you can connect with just:\\n\"\n            + f\"    $&gt; jupyter &lt;app&gt; --existing {connection_file}\\n\"\n            + \"or even just:\\n\"\n            + \"    $&gt; jupyter &lt;app&gt; --existing\\n\"\n            + \"if this is the most recent Jupyter kernel you have started.\",\n        )\n\n    @line_magic\n    def callers(self, _) -&gt; None:\n        \"Print a table of [Callers][async_kernel.caller.Caller], indicating its status including:  -running - protected - on the current thread.\"\n        callers = Caller.all_callers(running_only=False)\n        n = max(len(c.name) for c in callers) + 6\n        m = max(len(repr(c.id)) for c in callers) + 6\n        t = max(len(str(c.thread.name)) for c in callers) + 6\n        lines = [\n            \"\".join([\"Name\".center(n), \"Running \", \"Protected\", \"Thread\".center(t), \"Caller\".center(m)]),\n            \"\u2500\" * (n + m + t + 22),\n        ]\n        for caller in callers:\n            running = (\"\u2713\" if caller.running else \"\u2717\").center(8)\n            protected = \"   \ud83d\udd10    \" if caller.protected else \"         \"\n            name = caller.name + \" \" * (n - len(caller.name))\n            thread = str(caller.thread.name).center(t)\n            caller_id = str(caller.id)\n            if caller.id == Caller.id_current():\n                caller_id += \" \u2190 current\"\n            lines.append(\"\".join([name, running.center(8), protected, thread, caller_id]))\n        print(*lines, sep=\"\\n\")\n\n    @line_magic\n    def subshell(self, _) -&gt; None:\n        \"\"\"Print subshell info [ref](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#list-subshells).\n\n        See also:\n            - [async_kernel.utils.get_kernel][]\n        \"\"\"\n        kernel = utils.get_kernel()\n        subshells = kernel.subshell_manager.list_subshells()\n        subshell_list = (\n            f\"\\t----- {len(subshells)} x subshell -----\\n\" + \"\\n\".join(subshells) if subshells else \"-- No subshells --\"\n        )\n        print(f\"Current shell:\\t{kernel.shell}\\n\\n{subshell_list}\")\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.connect_info","title":"connect_info","text":"<pre><code>connect_info(_) -&gt; None\n</code></pre> <p>Print information for connecting other clients to this kernel.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef connect_info(self, _) -&gt; None:\n    \"\"\"Print information for connecting other clients to this kernel.\"\"\"\n    kernel = utils.get_kernel()\n    connection_file = pathlib.Path(kernel.connection_file)\n    # if it's in the default dir, truncate to basename\n    if jupyter_runtime_dir() == str(connection_file.parent):\n        connection_file = connection_file.name\n    info = kernel.get_connection_info()\n    print(\n        orjson.dumps(info, option=orjson.OPT_INDENT_2).decode(),\n        \"Paste the above JSON into a file, and connect with:\\n\"\n        + \"    $&gt; jupyter &lt;app&gt; --existing &lt;file&gt;\\n\"\n        + \"or, if you are local, you can connect with just:\\n\"\n        + f\"    $&gt; jupyter &lt;app&gt; --existing {connection_file}\\n\"\n        + \"or even just:\\n\"\n        + \"    $&gt; jupyter &lt;app&gt; --existing\\n\"\n        + \"if this is the most recent Jupyter kernel you have started.\",\n    )\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.callers","title":"callers","text":"<pre><code>callers(_) -&gt; None\n</code></pre> <p>Print a table of Callers, indicating its status including:  -running - protected - on the current thread.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef callers(self, _) -&gt; None:\n    \"Print a table of [Callers][async_kernel.caller.Caller], indicating its status including:  -running - protected - on the current thread.\"\n    callers = Caller.all_callers(running_only=False)\n    n = max(len(c.name) for c in callers) + 6\n    m = max(len(repr(c.id)) for c in callers) + 6\n    t = max(len(str(c.thread.name)) for c in callers) + 6\n    lines = [\n        \"\".join([\"Name\".center(n), \"Running \", \"Protected\", \"Thread\".center(t), \"Caller\".center(m)]),\n        \"\u2500\" * (n + m + t + 22),\n    ]\n    for caller in callers:\n        running = (\"\u2713\" if caller.running else \"\u2717\").center(8)\n        protected = \"   \ud83d\udd10    \" if caller.protected else \"         \"\n        name = caller.name + \" \" * (n - len(caller.name))\n        thread = str(caller.thread.name).center(t)\n        caller_id = str(caller.id)\n        if caller.id == Caller.id_current():\n            caller_id += \" \u2190 current\"\n        lines.append(\"\".join([name, running.center(8), protected, thread, caller_id]))\n    print(*lines, sep=\"\\n\")\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.subshell","title":"subshell","text":"<pre><code>subshell(_) -&gt; None\n</code></pre> <p>Print subshell info ref.</p> See also <ul> <li>async_kernel.utils.get_kernel</li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef subshell(self, _) -&gt; None:\n    \"\"\"Print subshell info [ref](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#list-subshells).\n\n    See also:\n        - [async_kernel.utils.get_kernel][]\n    \"\"\"\n    kernel = utils.get_kernel()\n    subshells = kernel.subshell_manager.list_subshells()\n    subshell_list = (\n        f\"\\t----- {len(subshells)} x subshell -----\\n\" + \"\\n\".join(subshells) if subshells else \"-- No subshells --\"\n    )\n    print(f\"Current shell:\\t{kernel.shell}\\n\\n{subshell_list}\")\n</code></pre>"},{"location":"reference/caller/","title":"caller","text":"<p>Classes:</p> <ul> <li> <code>PendingGroup</code>           \u2013            <p>An asynchronous context manager for tracking async_kernel.pending.Pending created in the context.</p> </li> <li> <code>Caller</code>           \u2013            <p>Caller is an advanced asynchronous context manager and scheduler for managing function calls within an async kernel environment.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.PendingGroup","title":"PendingGroup","text":"<p>               Bases: <code>PendingTracker</code>, <code>AsyncContextManagerMixin</code></p> <p>An asynchronous context manager for tracking async_kernel.pending.Pending created in the context.</p> <p>If any pending is set with an exception, the pending group and all tracked pending will be cancelled. The context will exit once all registered pending are complete or when after the cancellation_timeout period has elapsed.</p> Features <ul> <li>The context will exit after all tracked pending are done or removed.</li> <li>Cancelled or failed pending will cancel all other pending in the group.</li> <li>Pending can be manually removed from the group while the group is active.</li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> Usage <p>Enter the async context and create new pending.</p> <pre><code>async with PendingGroup() as pg:\n    assert pg.caller.to_thread(lambda: None) in pg.pending\n</code></pre> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller </li> <li> pending <code></code>\u00a0Pending <code></code>\u00a0trackers </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>cancel</code>             \u2013              <p>Cancel the pending group (thread-safe).</p> </li> <li> <code>cancelled</code>             \u2013              <p>Return True if the pending group is cancelled.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cancellation_timeout</code>           \u2013            <p>The maximum time to wait for cancelled pending to be done.</p> </li> <li> <code>caller</code>               (<code>Fixed[Self, Caller]</code>)           \u2013            <p>The caller where the pending group was instantiated.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class PendingGroup(PendingTracker, anyio.AsyncContextManagerMixin):\n    \"\"\"\n    An asynchronous context manager for tracking [async_kernel.pending.Pending][] created in the context.\n\n    If any pending is set with an exception, the pending group and all tracked pending\n    will be cancelled. The context will exit once all registered pending are complete or\n    when after the [cancellation_timeout][] period has elapsed.\n\n    Features:\n        - The context will exit after all tracked pending are done or removed.\n        - Cancelled or failed pending will cancel all other pending in the group.\n        - Pending can be manually removed from the group while the group is active.\n\n    Args:\n        shield: [Shield][anyio.CancelScope.shield] from external cancellation.\n\n    Usage:\n        Enter the async context and create new pending.\n\n        ```python\n        async with PendingGroup() as pg:\n            assert pg.caller.to_thread(lambda: None) in pg.pending\n        ```\n    \"\"\"\n\n    _parent_id: None | str = None\n    _cancel_scope: anyio.CancelScope\n    _cancelled: str | None = None\n    _leaving_context: bool = False\n    _failed: Fixed[Self, list[Pending]] = Fixed(list)\n    cancellation_timeout = 10\n    \"The maximum time to wait for cancelled pending to be done.\"\n\n    caller: Fixed[Self, Caller] = Fixed(lambda _: async_kernel.Caller())\n    \"The caller where the pending group was instantiated.\"\n\n    def __init__(self, *, shield: bool = False) -&gt; None:\n        self.caller  # noqa: B018\n        self._shield = shield\n        super().__init__()\n\n    @override\n    def _activate(self) -&gt; Token[str | None]:\n        self._parent_id = None if (parent_id := self._id_contextvar.get()) == self.id else parent_id\n        return super()._activate()\n\n    @contextlib.asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        if self._leaving_context:\n            msg = f\"Re-entry of {self.__class__} is not supported!\"\n            raise InvalidStateError(msg)\n        self._cancel_scope = anyio.CancelScope(shield=self._shield)\n        self._all_done = create_async_event()\n        token = self._activate()\n        try:\n            with self._cancel_scope:\n                try:\n                    yield self\n                    self._leaving_context = True\n                    if self._pending:\n                        await self._all_done\n                except (anyio.get_cancelled_exc_class(), Exception) as e:\n                    self.cancel(f\"An error occurred: {e!r}\")\n                    raise\n            if self._cancelled is not None:\n                if exceptions := [e for pen in self._failed if isinstance(e := pen.exception(), Exception)]:\n                    msg = \"One or more exceptions occurred in this context!\"\n                    raise ExceptionGroup(msg, exceptions)\n                raise PendingCancelled(self._cancelled)\n        finally:\n            self._leaving_context = True\n            self._deactivate(token)\n            self._instances.pop(self.id, None)\n            if self._pending:\n                if self._all_done or self._all_done.cancelled():\n                    self._all_done = create_async_event()\n                if self._pending and not self._all_done:\n                    with anyio.CancelScope(shield=True), anyio.move_on_after(self.cancellation_timeout):\n                        await self._all_done\n\n    @override\n    def add(self, pen: Pending) -&gt; None:\n        if pen not in self._pending:\n            self._pending.add(pen)\n            pen.add_done_callback(self._on_pending_done)\n        if (id_ := self._parent_id) and (parent := self._instances.get(id_)):\n            parent.add(pen)\n\n    @override\n    def _on_pending_done(self, pen: Pending) -&gt; None:\n        try:\n            self._pending.remove(pen)\n            if not pen.cancelled() and (pen.exception()):\n                self._failed.append(pen)\n                self.cancel(f\"Exception in member: {pen}\")\n        except KeyError:\n            pass\n        if self._leaving_context and not self._pending:\n            self._all_done.set()\n\n    @enable_signal_safety\n    def cancel(self, msg: str | None = None) -&gt; bool:\n        \"Cancel the pending group (thread-safe).\"\n        self._cancelled = \"\\n\".join(((self._cancelled or \"\"), msg or \"\"))\n        if not self._cancel_scope.cancel_called:\n            self.caller.call_direct(self._cancel_scope.cancel, msg)\n            for pen_ in self.pending:\n                pen_.cancel(msg)\n        return self.cancelled()\n\n    def cancelled(self) -&gt; bool:\n        \"\"\"Return True if the pending group is cancelled.\"\"\"\n        return bool(self._cancelled)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.PendingGroup(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield from external cancellation.</p>"},{"location":"reference/caller/#async_kernel.caller.PendingGroup.cancellation_timeout","title":"cancellation_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cancellation_timeout = 10\n</code></pre> <p>The maximum time to wait for cancelled pending to be done.</p> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0PendingGroup </li> <li> pending <code></code>\u00a0PendingGroup </li> </ul> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.PendingGroup.caller","title":"caller  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>caller: Fixed[Self, Caller] = Fixed(lambda _: Caller())\n</code></pre> <p>The caller where the pending group was instantiated.</p>"},{"location":"reference/caller/#async_kernel.caller.PendingGroup.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; bool\n</code></pre> <p>Cancel the pending group (thread-safe).</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>@enable_signal_safety\ndef cancel(self, msg: str | None = None) -&gt; bool:\n    \"Cancel the pending group (thread-safe).\"\n    self._cancelled = \"\\n\".join(((self._cancelled or \"\"), msg or \"\"))\n    if not self._cancel_scope.cancel_called:\n        self.caller.call_direct(self._cancel_scope.cancel, msg)\n        for pen_ in self.pending:\n            pen_.cancel(msg)\n    return self.cancelled()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.PendingGroup.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Return True if the pending group is cancelled.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Return True if the pending group is cancelled.\"\"\"\n    return bool(self._cancelled)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller","title":"Caller","text":"<p>               Bases: <code>AsyncContextManagerMixin</code></p> <p>Caller is an advanced asynchronous context manager and scheduler for managing function calls within an async kernel environment.</p> Features <ul> <li>Manages a pool of worker threads and async contexts for efficient scheduling and execution.</li> <li>Supports synchronous and asynchronous startup, shutdown, and cleanup of idle workers.</li> <li>Provides thread-safe scheduling of functions (sync/async), with support for delayed and queued execution.</li> <li>Integrates with ZeroMQ (zmq) for PUB socket communication.</li> <li>Tracks child caller instances, enabling hierarchical shutdown and resource management.</li> <li>Offers mechanisms for direct calls, queued calls, and thread offloading.</li> <li>Implements <code>as_completed</code> and <code>wait</code> utilities for monitoring and collecting results from scheduled tasks.</li> <li>Handles cancellation, exceptions, and context propagation robustly.</li> </ul> Usage <ul> <li>Use Caller to manage async/sync function execution, worker threads, and task scheduling in complex async applications.</li> <li>Integrate with ZeroMQ for PUB socket communication.</li> <li>Leverage child management for hierarchical resource cleanup.</li> <li>Use <code>as_completed</code> and <code>wait</code> for efficient result collection and monitoring.</li> </ul> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> asyncshell <code></code>\u00a0KernelMagics </li> <li> typing <ul> <li> <code></code>\u00a0CallerCreateOptions </li> <li> <code></code>\u00a0CallerState </li> <li> <code></code>\u00a0typing </li> </ul> </li> </ul> </li> <li> Usage Usage Caller </li> </ul> Returned by: <ul> <li> Reference <ul> <li> caller <ul> <li> <code></code>\u00a0Caller <code></code>\u00a0all_callers </li> <li> <code></code>\u00a0PendingGroup <code></code>\u00a0caller </li> </ul> </li> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0callers </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0callers </li> </ul> </li> <li> pending <code></code>\u00a0PendingGroup <code></code>\u00a0caller </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>Create or retrieve a Caller instance.</p> </li> <li> <code>start_sync</code>             \u2013              <p>Start synchronously.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the caller cancelling all incomplete tasks.</p> </li> <li> <code>__asynccontextmanager__</code>             \u2013              <p>The asynchronous context for caller.</p> </li> <li> <code>id_current</code>             \u2013              <p>The id that is used for a caller for the current thread in CPython or context in Pyodide.</p> </li> <li> <code>get_existing</code>             \u2013              <p>A classmethod to get the caller instance from the corresponding thread if it exists.</p> </li> <li> <code>current_pending</code>             \u2013              <p>A classmethod that returns the current result when called from inside a function scheduled by Caller.</p> </li> <li> <code>all_callers</code>             \u2013              <p>A classmethod to get a list of the callers.</p> </li> <li> <code>get</code>             \u2013              <p>Retrieves an existing child caller by name and backend, or creates a new one if not found.</p> </li> <li> <code>schedule_call</code>             \u2013              <p>Schedule <code>func</code> to be called inside a task running in the callers thread (thread-safe).</p> </li> <li> <code>call_later</code>             \u2013              <p>Schedule func to be called in caller's event loop copying the current context.</p> </li> <li> <code>call_soon</code>             \u2013              <p>Schedule func to be executed.</p> </li> <li> <code>call_using_backend</code>             \u2013              <p>Schedule func to be executed using the specified backend.</p> </li> <li> <code>call_direct</code>             \u2013              <p>Schedule <code>func</code> to be called in caller's event loop directly.</p> </li> <li> <code>to_thread</code>             \u2013              <p>Call func in a worker thread using the same backend as the current instance.</p> </li> <li> <code>queue_get</code>             \u2013              <p>Returns <code>Pending</code> instance for <code>func</code> where the queue is running.</p> </li> <li> <code>queue_call</code>             \u2013              <p>Queue the execution of <code>func</code> in a queue unique to it and the caller instance (thread-safe).</p> </li> <li> <code>queue_close</code>             \u2013              <p>Close the execution queue associated with <code>func</code> (thread-safe).</p> </li> <li> <code>checkpoint</code>             \u2013              <p>Yield to the event loop.</p> </li> <li> <code>as_completed</code>             \u2013              <p>An iterator to get result as they complete.</p> </li> <li> <code>wait</code>             \u2013              <p>Wait for the results given by items to complete.</p> </li> <li> <code>create_pending_group</code>             \u2013              <p>Create a new PendingGroup instance.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>MAX_IDLE_POOL_INSTANCES</code>           \u2013            <p>The number of <code>pool</code> instances to leave idle (See also to_thread).</p> </li> <li> <code>IDLE_WORKER_SHUTDOWN_DURATION</code>           \u2013            <p>The minimum duration in seconds for a worker to remain in the worker pool before it is shutdown.</p> </li> <li> <code>stopped</code>           \u2013            <p>A thread-safe Event for when the caller is stopped.</p> </li> <li> <code>log</code>               (<code>LoggerAdapter[Any]</code>)           \u2013            </li> <li> <code>iopub_sockets</code>               (<code>dict[int, Socket]</code>)           \u2013            </li> <li> <code>iopub_url</code>               (<code>ClassVar</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the thread when the caller was created.</p> </li> <li> <code>id</code>               (<code>int</code>)           \u2013            <p>The id for the caller.</p> </li> <li> <code>backend</code>               (<code>Backend</code>)           \u2013            <p>The backend used by caller.</p> </li> <li> <code>backend_options</code>               (<code>dict | None</code>)           \u2013            <p>Options used to create the backend.</p> </li> <li> <code>loop</code>               (<code>Loop | None</code>)           \u2013            <p>The gui event loop if there is one.</p> </li> <li> <code>loop_options</code>               (<code>dict | None</code>)           \u2013            <p>Options used to create the gui event loop.</p> </li> <li> <code>protected</code>               (<code>bool</code>)           \u2013            <p>Returns <code>True</code> if the caller is protected from stopping.</p> </li> <li> <code>zmq_context</code>               (<code>Context | None</code>)           \u2013            <p>A zmq socket, which if present indicates that an iopub socket is loaded.</p> </li> <li> <code>running</code>           \u2013            <p>Returns <code>True</code> when the caller is available to run requests.</p> </li> <li> <code>children</code>               (<code>frozenset[Self]</code>)           \u2013            <p>A frozenset copy of the instances that were created by the caller.</p> </li> <li> <code>thread</code>               (<code>Thread</code>)           \u2013            <p>The thread where the caller is running.</p> </li> <li> <code>parent</code>               (<code>Self | None</code>)           \u2013            <p>The parent caller if it exists.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>class Caller(anyio.AsyncContextManagerMixin):\n    \"\"\"\n    Caller is an advanced asynchronous context manager and scheduler for managing function calls within an async kernel environment.\n\n    Features:\n        - Manages a pool of worker threads and async contexts for efficient scheduling and execution.\n        - Supports synchronous and asynchronous startup, shutdown, and cleanup of idle workers.\n        - Provides thread-safe scheduling of functions (sync/async), with support for delayed and queued execution.\n        - Integrates with ZeroMQ (zmq) for PUB socket communication.\n        - Tracks child caller instances, enabling hierarchical shutdown and resource management.\n        - Offers mechanisms for direct calls, queued calls, and thread offloading.\n        - Implements `as_completed` and `wait` utilities for monitoring and collecting results from scheduled tasks.\n        - Handles cancellation, exceptions, and context propagation robustly.\n\n    Usage:\n        - Use Caller to manage async/sync function execution, worker threads, and task scheduling in complex async applications.\n        - Integrate with ZeroMQ for PUB socket communication.\n        - Leverage child management for hierarchical resource cleanup.\n        - Use `as_completed` and `wait` for efficient result collection and monitoring.\n    \"\"\"\n\n    MAX_IDLE_POOL_INSTANCES = 10\n    \"The number of `pool` instances to leave idle (See also [to_thread][async_kernel.caller.Caller.to_thread]).\"\n    IDLE_WORKER_SHUTDOWN_DURATION = 0 if \"pytest\" in sys.modules else 60\n    \"\"\"\n    The minimum duration in seconds for a worker to remain in the worker pool before it is shutdown.\n\n    Set to 0 to disable (default when running tests).\n    \"\"\"\n\n    CALLER_MAIN_THREAD_ID: int = id(threading.main_thread())\n\n    _caller_token = contextvars.ContextVar(\"caller_tokens\", default=CALLER_MAIN_THREAD_ID)\n    _instances: ClassVar[dict[int, Self]] = {}\n    _lock: ClassVar = BinarySemaphore()\n\n    _thread: threading.Thread\n    _caller_id: int\n    _name: str\n    _idle_time: float = 0.0\n    _backend: Backend\n    _backend_options: dict[str, Any] | None\n    _loop: Loop | None\n    _loop_options: dict[str, Any] | None\n    _protected = False\n    _use_safe_checkpoint = False\n    _state: CallerState = CallerState.initial\n    _state_reprs: ClassVar[dict] = {\n        CallerState.initial: \"\u2757 not running\",\n        CallerState.start_sync: \"starting sync\",\n        CallerState.running: \"\ud83c\udfc3 running\",\n        CallerState.stopping: \"\ud83c\udfc1 stopping\",\n        CallerState.stopped: \"\ud83c\udfc1 stopped\",\n    }\n    _zmq_context: zmq.Context[Any] | None = None\n\n    _parent_ref: weakref.ref[Self] | None = None\n\n    # Fixed\n    _child_lock = Fixed(BinarySemaphore)\n    _children: Fixed[Self, set[Self]] = Fixed(set)\n    _tasks: Fixed[Self, set[asyncio.Task]] = Fixed(set)\n    _worker_pool: Fixed[Self, deque[Self]] = Fixed(deque)\n    _queue_map: Fixed[Self, dict[int, Pending]] = Fixed(dict)\n    _queue: Fixed[Self, SingleConsumerAsyncQueue[Pending | tuple[Callable, tuple, dict]]] = Fixed(\n        lambda c: SingleConsumerAsyncQueue(c[\"owner\"].backend, reject=c[\"owner\"]._reject)\n    )\n\n    stopped = Fixed(Event)\n    \"A thread-safe Event for when the caller is stopped.\"\n\n    _pending_var: contextvars.ContextVar[Pending | None] = contextvars.ContextVar(\"_pending_var\", default=None)\n\n    log: logging.LoggerAdapter[Any]\n    \"\"\n    iopub_sockets: ClassVar[dict[int, zmq.Socket]] = {}\n    \"\"\n    iopub_url: ClassVar = \"inproc://iopub\"\n    \"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"The name of the thread when the caller was created.\"\n        return self._name\n\n    @property\n    def id(self) -&gt; int:\n        \"The id for the caller.\"\n        return self._caller_id\n\n    @property\n    def backend(self) -&gt; Backend:\n        \"The backend used by caller.\"\n        return self._backend\n\n    @property\n    def backend_options(self) -&gt; dict | None:\n        \"Options used to create the backend.\"\n        return self._backend_options\n\n    @property\n    def loop(self) -&gt; Loop | None:\n        \"The gui event loop if there is one.\"\n        return self._loop\n\n    @property\n    def loop_options(self) -&gt; dict | None:\n        \"Options used to create the gui event loop.\"\n        return self._loop_options\n\n    @property\n    def protected(self) -&gt; bool:\n        \"Returns `True` if the caller is protected from stopping.\"\n        return self._protected\n\n    @property\n    def zmq_context(self) -&gt; zmq.Context | None:\n        \"A zmq socket, which if present indicates that an iopub socket is loaded.\"\n        return self._zmq_context\n\n    @property\n    def running(self):\n        \"Returns `True` when the caller is available to run requests.\"\n        return self._state is CallerState.running\n\n    @property\n    def children(self) -&gt; frozenset[Self]:\n        \"\"\"A frozenset copy of the instances that were created by the caller.\n\n        Notes:\n            - When the parent is stopped, all children are stopped.\n            - All children are stopped prior to the parent exiting its async context.\n        \"\"\"\n        return frozenset(self._children)\n\n    @property\n    def thread(self) -&gt; threading.Thread:\n        \"The thread where the caller is running.\"\n        return self._thread\n\n    @property\n    def parent(self) -&gt; Self | None:\n        \"The parent caller if it exists.\"\n        if (ref := self._parent_ref) and (inst := ref()) and not inst.stopped:\n            return inst\n        return None\n\n    @override\n    def __repr__(self) -&gt; str:\n        n = len(self._children)\n        children = \"\" if not n else (\"1 child\" if n == 1 else f\"{n} children\")\n        info = f\"{self.name} at {id(self)}\"\n        return f\"Caller&lt;{info!s} {self.backend} {self._state_reprs.get(self._state)} {children}&gt;\"\n\n    def __new__(\n        cls,\n        modifier: Literal[\"CurrentThread\", \"MainThread\", \"NewThread\", \"manual\"] = \"CurrentThread\",\n        /,\n        **kwargs: Unpack[CallerCreateOptions],\n    ) -&gt; Self:\n        \"\"\"\n        Create or retrieve a Caller instance.\n\n        Args:\n            modifier: Specifies how the Caller instance should be created or retrieved.\n\n                - \"CurrentThread\": Automatically create or retrieve the instance.\n                - \"MainThread\": Use the main thread for the Caller.\n                - \"NewThread\": Create a new thread.\n                - \"manual\": Manually create a new instance for the current thread.\n\n            **kwargs: Additional options for Caller creation, such as:\n                - name: The name to use.\n                - backend: The async backend to use.\n                - backend_options: Options for the backend.\n                - protected: Whether the Caller is protected.\n                - zmq_context: ZeroMQ context.\n                - log: Logger instance.\n\n        Returns:\n            Self: The created or retrieved Caller instance.\n\n        Raises:\n            RuntimeError: If the backend is not provided and backend can't be determined.\n            ValueError: If the thread and caller's name do not match.\n        \"\"\"\n        with cls._lock:\n            name, backend = kwargs.get(\"name\", \"\"), kwargs.get(\"backend\")\n            match modifier:\n                case \"CurrentThread\" | \"manual\":\n                    caller_id = cls.id_current()\n                case \"MainThread\":\n                    caller_id = cls.CALLER_MAIN_THREAD_ID\n                case \"NewThread\":\n                    caller_id = None\n\n            # Locate existing\n            if caller_id is not None and (caller := cls._instances.get(caller_id)):\n                if modifier == \"manual\":\n                    msg = f\"An instance already exists for {caller_id=}\"\n                    raise RuntimeError(msg)\n                if name and name != caller.name:\n                    msg = f\"The thread and caller's name do not match! {name=} {caller=}\"\n                    raise ValueError(msg)\n                if backend and backend != caller.backend:\n                    msg = f\"The backend does not match! {backend=} {caller.backend=}\"\n                    raise ValueError(msg)\n                return caller\n\n            # create a new instance\n            inst = super().__new__(cls)\n            inst._name = name\n            inst._backend = Backend(backend or current_async_library())\n            inst._loop = Loop(loop) if (loop := kwargs.get(\"loop\")) else None\n            inst._backend_options = kwargs.get(\"backend_options\")\n            inst._loop_options = kwargs.get(\"loop_options\")\n            inst._protected = kwargs.get(\"protected\", False)\n            inst._zmq_context = kwargs.get(\"zmq_context\")\n            inst.log = kwargs.get(\"log\") or logging.LoggerAdapter(logging.getLogger())\n            if (sys.platform == \"emscripten\") and (caller_id is None):\n                caller_id = id(inst)\n            if caller_id is not None:\n                inst._caller_id = caller_id\n                inst._thread = threading.current_thread()\n\n            # finalize\n            if modifier != \"manual\":\n                inst.start_sync()\n            assert inst._caller_id\n            assert inst._caller_id not in cls._instances\n            cls._instances[inst._caller_id] = inst\n        return inst\n\n    def start_sync(self) -&gt; None:\n        \"Start synchronously.\"\n\n        assert self._state is CallerState.initial\n        self._state = CallerState.start_sync\n\n        async def run_caller_in_context() -&gt; None:\n            if self._state is CallerState.start_sync:\n                self._state = CallerState.initial\n                async with self:\n                    await self.stopped\n\n        if getattr(self, \"_caller_id\", None) is not None:\n            # An event loop for the current thread.\n\n            if self.backend == Backend.asyncio:\n                self._tasks.add(asyncio.create_task(run_caller_in_context()))\n            else:\n                # trio\n                token = current_token()\n\n                def to_thread():\n                    utils.mark_thread_pydev_do_not_trace()\n                    try:\n                        anyio.from_thread.run(run_caller_in_context, token=token)\n                    except (BaseExceptionGroup, BaseException) as e:\n                        if not \"shutdown\" not in str(e):\n                            raise\n\n                threading.Thread(target=to_thread, daemon=False).start()\n        else:\n            name = self.name or \"async_kernel_caller\"\n            settings = RunSettings(\n                backend=self.backend,\n                loop=self.loop,\n                backend_options=self.backend_options,\n                loop_options=self.loop_options,\n            )\n            args = [run_caller_in_context, (), settings]\n            self._thread = threading.Thread(target=async_kernel.event_loop.run, args=args, name=name, daemon=True)\n            self._caller_id = id(self._thread)\n            self._thread.start()\n\n    def stop(self, *, force: bool = False) -&gt; CallerState:\n        \"\"\"\n        Stop the caller cancelling all incomplete tasks.\n\n        Args:\n            force: If the caller is protected the call is a no-op unless force=True.\n        \"\"\"\n        if (self._protected and not force) or self._state is CallerState.stopping:\n            return self._state\n        set_stop = self._state in [CallerState.initial, CallerState.start_sync]\n        self._state = CallerState.stopping\n        self._instances.pop(self._caller_id, None)\n        if parent := self.parent:\n            try:\n                parent._worker_pool.remove(self)\n            except ValueError:\n                pass\n        for child in self.children:\n            child.stop(force=True)\n        if queue := getattr(self, \"_guest_queue\", None):\n            queue.stop()\n        self._queue.stop()\n        for func in tuple(self._queue_map):\n            self.queue_close(func)\n        if set_stop:\n            self.stopped.set()\n            self._state = CallerState.stopped\n        return self._state\n\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        \"The asynchronous context for caller.\"\n        if (state := self._state) is not CallerState.initial:\n            if state is CallerState.start_sync:\n                msg = 'Already starting! Did you mean to use Caller(\"manual\")?'\n            else:\n                msg = \"Caller cannot be been re-entered!\"\n            raise RuntimeError(msg)\n        if not self._name:\n            self._name = threading.current_thread().name\n        async with anyio.create_task_group() as tg:\n            socket = None\n            self._state = CallerState.running\n            tg.start_soon(self._scheduler, self.backend, self._queue, tg)\n            if self._zmq_context:\n                socket = self._zmq_context.socket(1)  # zmq.SocketType.PUB\n                socket.linger = 50\n                socket.connect(self.iopub_url)\n                self.iopub_sockets[self._caller_id] = socket\n            try:\n                yield self\n            finally:\n                if stop_guest := getattr(self, \"_stop_guest\", None):\n                    with anyio.CancelScope(shield=True):\n                        await stop_guest()\n                self.stop(force=True)\n                if socket:\n                    self.iopub_sockets.pop(self._caller_id, None)\n                    socket.close()\n                with anyio.CancelScope(shield=True):\n                    while self._children:\n                        await self._children.pop().stopped\n                    if parent := self.parent:\n                        parent._children.discard(self)\n                    self._state = CallerState.stopped\n                    self.stopped.set()\n                    await self.checkpoint()\n\n    async def _scheduler(self, backend: Backend, queue: SingleConsumerAsyncQueue, tg: TaskGroup) -&gt; None:\n        \"\"\"\n        Asynchronous scheduler coroutine responsible for managing and executing tasks from an internal queue.\n\n        This method sets up a PUB socket for sending iopub messages, processes queued tasks (either callables or tuples with runnables),\n        and handles coroutine execution. It waits for new tasks when the queue is empty and ensures proper cleanup and exception\n        handling on shutdown.\n\n        Args:\n            backend: The backend where the scheduler is operating.\n            tg: The task group used to manage concurrent tasks.\n            task_status: Used to signal when the scheduler has started.\n\n        Raises:\n            Exception: Logs and handles exceptions raised during direct callable execution.\n            PendingCancelled: Sets this exception on pending results in the queue upon shutdown.\n        \"\"\"\n        kwgs = {}\n        asyncio_backend = backend == Backend.asyncio\n        if asyncio_backend:\n            loop = asyncio.get_running_loop()\n            coro = asyncio.sleep(0)\n            try:\n                await loop.create_task(coro, eager_start=True)  # pyright: ignore[reportCallIssue]\n                kwgs[\"eager_start\"] = True\n            except Exception:\n                coro.close()\n        try:\n            async for item in queue:\n                result = None\n                if not isinstance(item, Pending):\n                    try:\n                        result = item[0](*item[1], **item[2])\n                        if inspect.iscoroutine(result):\n                            await result\n                    except Exception as e:\n                        self.log.exception(\"Direct call failed\", exc_info=e)\n                else:\n                    if asyncio_backend:\n                        task = loop.create_task(self._call_scheduled(item), context=item.context, **kwgs)  # pyright: ignore[reportPossiblyUnboundVariable]\n                        if not task.done():\n                            self._tasks.add(task)\n                            task.add_done_callback(self._tasks.discard)\n                        del task\n                    else:\n                        item.context.run(tg.start_soon, self._call_scheduled, item)\n                del item, result\n        finally:\n            if asyncio_backend:\n                for task in self._tasks:\n                    task.cancel()\n            tg.cancel_scope.cancel()\n\n    async def _call_scheduled(self, pen: Pending) -&gt; None:\n        \"\"\"\n        Asynchronously executes the function associated with the given instance, handling cancellation, delays, and exceptions.\n\n        Args:\n            pen: The [async_kernel.Pending][] object containing metadata about the function to execute, its arguments, and execution state.\n\n        Workflow:\n            - Sets the current instance in a context variable.\n            - If the instance is cancelled before starting, sets a `PendingCancelled` error.\n            - Otherwise, enters a cancellation scope:\n                - Registers a canceller for the instance.\n                - Waits for a specified delay if present in metadata.\n                - Calls the function (sync or async) with provided arguments.\n                - Sets the result or exception on the instance as appropriate.\n            - Handles cancellation and other exceptions, logging errors as needed.\n            - Resets the context variable after execution.\n        \"\"\"\n        md = pen.metadata\n        token_pending = self._pending_var.set(pen)\n        token_ident = self._caller_token.set(self._caller_id)\n        try:\n            if pen.cancelled():\n                if not pen.done():\n                    pen.set_exception(PendingCancelled(\"Cancelled before started.\"))\n            else:\n                with anyio.CancelScope() as scope:\n                    pen.set_canceller(lambda msg: self.call_direct(scope.cancel, msg))\n                    # Call later.\n                    if (delay := md.get(\"delay\")) and ((delay := delay - time.monotonic() + md[\"start_time\"]) &gt; 0):\n                        await anyio.sleep(delay)\n                    # Call now.\n                    try:\n                        result = md[\"func\"](*md[\"args\"], **md[\"kwargs\"])\n                        if inspect.iscoroutine(result):\n                            result = await result\n                        pen.set_result(result)\n                    # Cancelled.\n                    except anyio.get_cancelled_exc_class() as e:\n                        if not pen.cancelled():\n                            pen.cancel()\n                        pen.set_exception(e)\n                    # Catch exceptions.\n                    except Exception as e:\n                        pen.set_exception(e)\n        except Exception as e:\n            pen.set_exception(e)\n        finally:\n            self._pending_var.reset(token_pending)\n            self._caller_token.reset(token_ident)\n\n    @staticmethod\n    def _reject(item: tuple | Pending) -&gt; None:\n        if isinstance(item, Pending):\n            item.cancel(\"The caller has been closed\", _force=True)\n\n    @classmethod\n    def _start_idle_worker_cleanup_thead(cls) -&gt; None:\n        \"A single thread to shutdown idle workers that have not been used for an extended duration.\"\n        if cls.IDLE_WORKER_SHUTDOWN_DURATION &gt; 0 and not hasattr(cls, \"_thread_cleanup_idle_workers\"):\n\n            def _cleanup_workers():\n                utils.mark_thread_pydev_do_not_trace()\n                n = 0\n                cutoff = time.monotonic()\n                time.sleep(cls.IDLE_WORKER_SHUTDOWN_DURATION)\n                for caller in tuple(cls._instances.values()):\n                    for worker in frozenset(caller._worker_pool):\n                        n += 1\n                        if worker._idle_time &lt; cutoff:\n                            with contextlib.suppress(IndexError):\n                                caller._worker_pool.remove(worker)\n                                worker.stop()\n                if n:\n                    _cleanup_workers()\n                else:\n                    del cls._thread_cleanup_idle_workers\n\n            cls._thread_cleanup_idle_workers = threading.Thread(target=_cleanup_workers, daemon=True)\n            cls._thread_cleanup_idle_workers.start()\n\n    @classmethod\n    def id_current(cls) -&gt; int:\n        \"The id that is used for a caller for the current thread in CPython or context in Pyodide.\"\n        if sys.platform == \"emscripten\":\n            return cls._caller_token.get()\n        return id(threading.current_thread())\n\n    @classmethod\n    def get_existing(cls, caller_id: int | None = None, /) -&gt; Self | None:\n        \"\"\"\n        A [classmethod][] to get the caller instance from the corresponding thread if it exists.\n\n        Args:\n            caller_id: The id of the caller which in CPython is also the the id of the thread in which it is running.\n        \"\"\"\n        caller_id = cls.id_current() if caller_id is None else caller_id\n        with cls._lock:\n            return cls._instances.get(caller_id)\n\n    @classmethod\n    def current_pending(cls) -&gt; Pending[Any] | None:\n        \"\"\"A [classmethod][] that returns the current result when called from inside a function scheduled by Caller.\"\"\"\n        return cls._pending_var.get()\n\n    @classmethod\n    def all_callers(cls, running_only: bool = True) -&gt; list[Caller]:\n        \"\"\"\n        A [classmethod][] to get a list of the callers.\n\n        Args:\n            running_only: Restrict the list to callers that are active (running in an async context).\n        \"\"\"\n        return [caller for caller in Caller._instances.values() if caller.running or not running_only]\n\n    def get(self, **kwargs: Unpack[CallerCreateOptions]) -&gt; Self:\n        \"\"\"\n        Retrieves an existing child caller by name and backend, or creates a new one if not found.\n\n        Args:\n            **kwargs: Options for creating or retrieving a caller instance.\n                - name: The name of the child caller to retrieve.\n                - backend: The backend to match or assign to the caller.\n                - backend_options: Options for the backend.\n                - zmq_context: ZeroMQ context to use.\n\n        Returns:\n            Self: The retrieved or newly created caller instance.\n\n        Raises:\n            RuntimeError: If a caller with the specified name exists but the backend does not match.\n\n        Notes:\n            - The returned caller is added to `children` and stopped with this instance.\n            - If 'backend' and 'zmq_context' are not specified they are copied from this instance.\n        \"\"\"\n\n        with self._child_lock:\n            if name := kwargs.get(\"name\"):\n                for caller in self.children:\n                    if caller.name == name:\n                        if (backend := kwargs.get(\"backend\")) and caller.backend != backend:\n                            msg = f\"Backend mismatch! {backend=} {caller.backend=}\"\n                            raise RuntimeError(msg)\n                        if (loop := kwargs.get(\"loop\")) and caller.loop != loop:\n                            msg = f\"Event loop mismatch! {loop=} {caller.loop=}\"\n                            raise RuntimeError(msg)\n                        return caller\n            if \"backend\" not in kwargs:\n                kwargs[\"backend\"] = self._backend\n                kwargs[\"backend_options\"] = self.backend_options\n            if \"zmq_context\" not in kwargs and self._zmq_context:\n                kwargs[\"zmq_context\"] = self._zmq_context\n            caller = self.__class__(\"NewThread\", **kwargs)\n            self._children.add(caller)\n            caller._parent_ref = weakref.ref(self)\n            return caller\n\n    def schedule_call(\n        self,\n        func: Callable[..., CoroutineType[Any, Any, T] | T],\n        args: tuple,\n        kwargs: dict,\n        context: contextvars.Context | None = None,\n        trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = PendingTracker,\n        backend: NoValue | Backend = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        /,\n        **metadata: Any,\n    ) -&gt; Pending[T]:\n        \"\"\"\n        Schedule `func` to be called inside a task running in the callers thread (thread-safe).\n\n        The methods [call_soon][Caller.call_soon] and [call_later][Caller.call_later]\n        use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.\n\n        Args:\n            func: The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.\n            args: Arguments corresponding to in the call to  `func`.\n            kwargs: Keyword arguments to use with in the call to `func`.\n            context: The context to use, if not provided the current context is used.\n            trackers: The tracker subclasses of active trackers which to add the pending.\n            **metadata: Additional metadata to store in the instance.\n        \"\"\"\n        pen = Pending(trackers, context, func=func, args=args, kwargs=kwargs, caller=self, **metadata)\n        if backend is NoValue or (backend := Backend(backend)) is self.backend:\n            self._queue.append(pen)\n        else:\n            if not hasattr(self, \"_guest_queue\"):\n                self._guest_queue = SingleConsumerAsyncQueue(backend, reject=self._reject)\n                self.schedule_call(\n                    self._guest_backend_loop, (), {\"backend\": backend, \"queue\": self._guest_queue}, None, ()\n                )\n            self._guest_queue.append(pen)\n        return pen\n\n    async def _guest_backend_loop(self, backend: Backend, queue: SingleConsumerAsyncQueue) -&gt; None:\n        async def _guest_scheduler() -&gt; None:\n            async with anyio.create_task_group() as tg:\n                tg.start_soon(self._scheduler, Backend(backend), queue, tg)\n\n        if self._state is CallerState.running:\n            # Prefer callbacks from the host.\n            host = Host.current(self.thread)\n            run_soon_threadsafe_queue = SingleConsumerAsyncQueue(self.backend)\n            start_guest_run = get_start_guest_run(backend)\n            start_guest_run(\n                _guest_scheduler,\n                done_callback=lambda _: run_soon_threadsafe_queue.stop(),\n                run_sync_soon_threadsafe=host.run_sync_soon_threadsafe if host else run_soon_threadsafe_queue.append,\n                run_sync_soon_not_threadsafe=host.run_sync_soon_not_threadsafe if host else None,\n                host_uses_signal_set_wakeup_fd=host.host_uses_signal_set_wakeup_fd if host else True,\n            )\n            if pen := self.current_pending():\n                self._stop_guest = lambda: [queue.stop(), pen.wait(result=False)][1]\n            with anyio.CancelScope(shield=True):\n                async for func in run_soon_threadsafe_queue:\n                    try:\n                        func()\n                    except Exception:\n                        pass\n\n    def call_later(\n        self,\n        delay: float,\n        func: Callable[P, T | CoroutineType[Any, Any, T]],\n        /,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Pending[T]:\n        \"\"\"\n        Schedule func to be called in caller's event loop copying the current context.\n\n        Args:\n            func: The function.\n            delay: The minimum delay to add between submission and execution.\n            *args: Arguments to use with `func`.\n            **kwargs: Keyword arguments to use with `func`.\n\n        Info:\n            All call arguments are packed into the instance's metadata.\n        \"\"\"\n        return self.schedule_call(func, args, kwargs, delay=delay, start_time=time.monotonic())\n\n    def call_soon(\n        self,\n        func: Callable[P, T | CoroutineType[Any, Any, T]],\n        /,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Pending[T]:\n        \"\"\"\n        Schedule func to be executed.\n\n        Args:\n            func: The function.\n            *args: Arguments to use with `func`.\n            **kwargs: Keyword arguments to use with `func`.\n        \"\"\"\n        return self.schedule_call(func, args, kwargs)\n\n    def call_using_backend(\n        self,\n        backend: Backend | Literal[\"asyncio\", \"trio\"],\n        func: Callable[P, T | CoroutineType[Any, Any, T]],\n        /,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Pending[T]:\n        \"\"\"\n        Schedule func to be executed using the specified backend.\n\n        This methods enables coroutines written for a specific function to be run irresective\n        of the callers backend.\n\n        - `backend == caller.backend` - `func` is executed via [Caller.call_soon][].\n        - `backend != caller.backend` - `func` is executed with a backend running as a guest.\n\n        Args:\n            backend: The backend in which `func` must be executed.\n            func: The function.\n            *args: Arguments to use with `func`.\n            **kwargs: Keyword arguments to use with `func`.\n\n        Notes:\n\n            - **Only use this to execute coroutines that require a specific backend to run in the callers thread.**\n            - Where possible use a separate caller/thread with [Caller.get][] instead.\n        \"\"\"\n        return self.schedule_call(func, args, kwargs, None, PendingTracker, Backend(backend))\n\n    def call_direct(\n        self,\n        func: Callable[P, T | CoroutineType[Any, Any, T]],\n        /,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Schedule `func` to be called in caller's event loop directly.\n\n        Use this for short-running function calls only.\n\n        Args:\n            func: The function.\n            *args: Arguments to use with `func`.\n            **kwargs: Keyword arguments to use with `func`.\n\n        Warning:\n\n            **Use this method for lightweight calls only!**\n        \"\"\"\n        self._queue.append((func, args, kwargs))\n\n    def to_thread(\n        self,\n        func: Callable[P, T | CoroutineType[Any, Any, T]],\n        /,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Pending[T]:\n        \"\"\"\n        Call func in a worker thread using the same backend as the current instance.\n\n        Args:\n            func: The function.\n            *args: Arguments to use with func.\n            **kwargs: Keyword arguments to use with func.\n\n        Notes:\n            - A minimum number of caller instances are retained for this method.\n            - Async code run inside func should use taskgroups for creating task.\n        \"\"\"\n\n        def _to_thread_on_done(_) -&gt; None:\n            if not caller.stopped and self.running:\n                if len(self._worker_pool) &lt; self.MAX_IDLE_POOL_INSTANCES:\n                    caller._idle_time = time.monotonic()\n                    self._worker_pool.append(caller)\n                    self._start_idle_worker_cleanup_thead()\n                else:\n                    caller.stop()\n\n        try:\n            caller = self._worker_pool.popleft()\n        except IndexError:\n            caller = self.get()\n        pen = caller.call_soon(func, *args, **kwargs)\n        pen.add_done_callback(_to_thread_on_done)\n        return pen\n\n    def queue_get(self, func: Callable) -&gt; Pending[None] | None:\n        \"\"\"Returns `Pending` instance for `func` where the queue is running.\n\n        Warning:\n            - This instance loops until the instance is closed or func is garbage collected.\n            - The pending has been modified such that waiting it will wait for the queue to be empty.\n            - `queue_close` is the preferred means to shutdown the queue.\n        \"\"\"\n        return self._queue_map.get(hash(func))\n\n    def queue_call(\n        self,\n        func: Callable[P, T | CoroutineType[Any, Any, T]],\n        /,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Pending[T]:\n        \"\"\"\n        Queue the execution of `func` in a queue unique to it and the caller instance (thread-safe).\n\n        The returned pending is 'resettable' and will provide the result of the most recent successful\n        call once the queue has been emptied. Exceptions are not set, instead the result would be `None`.\n\n        Args:\n            func: The function.\n            *args: Arguments to use with `func`.\n            **kwargs: Keyword arguments to use with `func`.\n\n        Returns:\n            Pending: The pending where the queue loop is running.\n\n        Warning:\n            - Do not assume the result corresponds to the function call.\n            - The returned pending returns the last result of the queue call once the queue becomes empty.\n\n        Notes:\n            - The queue runs in a *task* wrapped with a [async_kernel.pending.Pending][] that remains running until one of the following occurs:\n                1. The pending is cancelled.\n                2. The method [Caller.queue_close][] is called with `func` or `func`'s hash.\n                3. `func` is deleted (utilising [weakref.finalize][]).\n            - The [context][contextvars.Context] of the initial call is used for subsequent queue calls.\n            - Exceptions are 'swallowed'; the last successful result is set on the pending.\n        \"\"\"\n        key = hash(func)\n        if not (pen_ := self._queue_map.get(key)):\n            queue = SingleConsumerAsyncQueue[tuple[Callable, tuple, dict]](self.backend)\n            with contextlib.suppress(TypeError):\n                weakref.finalize(func.__self__ if inspect.ismethod(func) else func, self.queue_close, key)\n\n            async def queue_loop() -&gt; None:\n                pen = self.current_pending()\n                assert pen\n                result = None\n                try:\n                    async for item in queue:\n                        try:\n                            result = item[0](*item[1], **item[2])\n                            if inspect.iscoroutine(object=result):\n                                result = await result\n                        except (anyio.get_cancelled_exc_class(), Exception) as e:\n                            if pen.cancelled():\n                                raise\n                            self.log.exception(\"Execution %s failed\", item, exc_info=e)\n                        if not queue.queue:\n                            pen.set_result(result, reset=True)\n                            item = result = None  # noqa: PLW2901\n                finally:\n                    self._queue_map.pop(key)\n\n            self._queue_map[key] = pen_ = self.schedule_call(queue_loop, (), {}, key=key, queue=queue)\n        pen_.metadata[\"queue\"].append((func, args, kwargs))\n        return pen_.add_to_trackers()  # pyright: ignore[reportReturnType]\n\n    def queue_close(self, func: Callable | int) -&gt; None:\n        \"\"\"\n        Close the execution queue associated with `func` (thread-safe).\n\n        Args:\n            func: The queue of the function to close.\n        \"\"\"\n        key = func if isinstance(func, int) else hash(func)\n        if pen := self._queue_map.pop(key, None):\n            pen.metadata[\"queue\"].stop()\n            pen.cancel()\n\n    async def checkpoint(self) -&gt; None:\n        \"Yield to the event loop.\"\n        if not self._use_safe_checkpoint:\n            try:\n                if self.backend is Backend.trio:\n                    await trio_checkpoint()\n                else:\n                    await asyncio_checkpoint()\n            except Exception:\n                self._use_safe_checkpoint = True\n            else:\n                return\n        await async_checkpoint(force=True)\n\n    async def as_completed(\n        self,\n        items: Iterable[Awaitable[T]] | AsyncGenerator[Awaitable[T]],\n        *,\n        max_concurrent: NoValue | int = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        cancel_unfinished: bool = True,\n    ) -&gt; AsyncGenerator[Pending[T], Any]:\n        \"\"\"\n        An iterator to get result as they complete.\n\n        Args:\n            items: Either a container with existing results or generator of Pendings.\n            max_concurrent: The maximum number of concurrent results to monitor at a time.\n                This is useful when `items` is a generator utilising [Caller.to_thread][].\n                By default this will limit to `Caller.MAX_IDLE_POOL_INSTANCES`.\n            cancel_unfinished: Cancel any `pending` when exiting.\n\n        Tip:\n            1. Pass a generator if you wish to limit the number result jobs when calling to_thread/to_task etc.\n            2. Pass a container with all results when the limiter is not relevant.\n        \"\"\"\n        resume = noop\n        queue: SingleConsumerAsyncQueue[Pending[T]] = SingleConsumerAsyncQueue(self.backend)\n        unfinished: set[Pending[T]] = set()\n        pen_current = self.current_pending()\n        if isinstance(items, set | list | tuple):\n            max_concurrent_ = 0\n        else:\n            max_concurrent_ = self.MAX_IDLE_POOL_INSTANCES if max_concurrent is NoValue else int(max_concurrent)\n\n        async def scheduler():\n            nonlocal resume\n            gen = items if isinstance(items, AsyncGenerator) else iter(items)\n            is_async = isinstance(gen, AsyncGenerator)\n            while not queue.stopped and (pen := await anext(gen, None) if is_async else next(gen, None)) is not None:\n                if pen is pen_current:\n                    queue.stop()\n                    msg = \"Waiting for the pending in which it is running would result in deadlock!\"\n                    raise RuntimeError(msg)\n                if not isinstance(pen, Pending):\n                    pen = cast(\"Pending[T]\", self.call_soon(await_for, pen))\n                pen.add_done_callback(queue.append)\n                if not pen.done():\n                    unfinished.add(pen)\n                    if max_concurrent_ and len(unfinished) == max_concurrent_:\n                        waiter = create_async_waiter()\n                        resume = waiter.wake\n                        if len(unfinished) == max_concurrent_:\n                            await waiter\n                        resume = noop\n\n        pen_ = self.call_soon(scheduler)\n        try:\n            async for pen in queue:\n                unfinished.discard(pen)\n                yield pen\n                if pen_.done() and not unfinished and not queue.queue:\n                    break\n                else:\n                    if max_concurrent_ and len(unfinished) &lt; max_concurrent_:\n                        resume()\n            pen_.result()\n        finally:\n            queue.stop()\n            pen_.cancel()\n            for pen in unfinished:\n                pen.remove_done_callback(queue.append)\n                if cancel_unfinished:\n                    pen.cancel(\"Cancelled by as_completed\")\n            with anyio.CancelScope():\n                await pen_.wait(result=False)\n\n    async def wait(\n        self,\n        items: Iterable[Awaitable[T]],\n        *,\n        timeout: float | None = None,\n        return_when: Literal[\"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"] = \"ALL_COMPLETED\",\n    ) -&gt; tuple[set[Pending[T]], set[Pending[T]]]:\n        \"\"\"\n        Wait for the results given by items to complete.\n\n        Returns two sets of the results: (done, pending).\n\n        Args:\n            items: An iterable of results to wait for.\n            timeout: The maximum time before returning.\n            return_when: The same options as available for [asyncio.wait][].\n\n        Example:\n            ```python\n            done, pending = await asyncio.wait(items)\n            ```\n        Info:\n            - This does not raise a TimeoutError!\n            - Pendings that aren't done when the timeout occurs are returned in the second set.\n        \"\"\"\n        pending: set[Pending[T]] = set()\n        done = set()\n        for item in items:\n            if isinstance(item, Pending):\n                done.add(item) if item.done() else pending.add(item)\n            else:\n                pending.add(self.call_soon(await_for, item))\n        if done:\n            if return_when == \"FIRST_COMPLETED\":\n                return done, pending\n            if return_when == \"FIRST_EXCEPTION\":\n                for pen in done:\n                    if pen.cancelled() or pen.exception():\n                        return done, pending\n        if pending:\n            with anyio.move_on_after(timeout):\n                async for pen in self.as_completed(pending.copy(), cancel_unfinished=False):\n                    pending.discard(pen)\n                    done.add(pen)\n                    if return_when == \"FIRST_COMPLETED\":\n                        break\n                    if return_when == \"FIRST_EXCEPTION\" and (pen.cancelled() or pen.exception()):\n                        break\n        return done, pending\n\n    def create_pending_group(self, *, shield: bool = False):\n        \"\"\"\n        Create a new [PendingGroup][async_kernel.pending.PendingGroup] instance.\n\n        The pending group will wait for all pending created in its context to complete (except for those that opt out).\n        If any pending result in exception, the pending group and all registered pending are cancelled.\n        If the pending group context is cancelled or results in exception, all pending in the group are\n        also cancelled.\n\n        Args:\n            shield: Shield the pending group from external cancellation.\n\n        Usage:\n\n            ```python\n            async with Caller().create_pending_group() as pg:\n                pg.caller.to_thread(my_func)\n                ...\n            ```\n        \"\"\"\n        return PendingGroup(shield=shield)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.MAX_IDLE_POOL_INSTANCES","title":"MAX_IDLE_POOL_INSTANCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_IDLE_POOL_INSTANCES = 10\n</code></pre> <p>The number of <code>pool</code> instances to leave idle (See also to_thread).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.IDLE_WORKER_SHUTDOWN_DURATION","title":"IDLE_WORKER_SHUTDOWN_DURATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE_WORKER_SHUTDOWN_DURATION = 0 if 'pytest' in modules else 60\n</code></pre> <p>The minimum duration in seconds for a worker to remain in the worker pool before it is shutdown.</p> <p>Set to 0 to disable (default when running tests).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stopped","title":"stopped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopped = Fixed(Event)\n</code></pre> <p>A thread-safe Event for when the caller is stopped.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: LoggerAdapter[Any]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.iopub_sockets","title":"iopub_sockets  <code>class-attribute</code>","text":"<pre><code>iopub_sockets: dict[int, Socket] = {}\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.iopub_url","title":"iopub_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub_url: ClassVar = 'inproc://iopub'\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the thread when the caller was created.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>The id for the caller.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: Backend\n</code></pre> <p>The backend used by caller.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.backend_options","title":"backend_options  <code>property</code>","text":"<pre><code>backend_options: dict | None\n</code></pre> <p>Options used to create the backend.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.loop","title":"loop  <code>property</code>","text":"<pre><code>loop: Loop | None\n</code></pre> <p>The gui event loop if there is one.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.loop_options","title":"loop_options  <code>property</code>","text":"<pre><code>loop_options: dict | None\n</code></pre> <p>Options used to create the gui event loop.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.protected","title":"protected  <code>property</code>","text":"<pre><code>protected: bool\n</code></pre> <p>Returns <code>True</code> if the caller is protected from stopping.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.zmq_context","title":"zmq_context  <code>property</code>","text":"<pre><code>zmq_context: Context | None\n</code></pre> <p>A zmq socket, which if present indicates that an iopub socket is loaded.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre> <p>Returns <code>True</code> when the caller is available to run requests.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.children","title":"children  <code>property</code>","text":"<pre><code>children: frozenset[Self]\n</code></pre> <p>A frozenset copy of the instances that were created by the caller.</p> Notes <ul> <li>When the parent is stopped, all children are stopped.</li> <li>All children are stopped prior to the parent exiting its async context.</li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller.thread","title":"thread  <code>property</code>","text":"<pre><code>thread: Thread\n</code></pre> <p>The thread where the caller is running.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Self | None\n</code></pre> <p>The parent caller if it exists.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__","title":"__new__","text":"<pre><code>__new__(\n    modifier: Literal[\n        \"CurrentThread\", \"MainThread\", \"NewThread\", \"manual\"\n    ] = \"CurrentThread\",\n    /,\n    **kwargs: Unpack[CallerCreateOptions],\n) -&gt; Self\n</code></pre> <p>Create or retrieve a Caller instance.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The created or retrieved Caller instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the backend is not provided and backend can't be determined.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the thread and caller's name do not match.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __new__(\n    cls,\n    modifier: Literal[\"CurrentThread\", \"MainThread\", \"NewThread\", \"manual\"] = \"CurrentThread\",\n    /,\n    **kwargs: Unpack[CallerCreateOptions],\n) -&gt; Self:\n    \"\"\"\n    Create or retrieve a Caller instance.\n\n    Args:\n        modifier: Specifies how the Caller instance should be created or retrieved.\n\n            - \"CurrentThread\": Automatically create or retrieve the instance.\n            - \"MainThread\": Use the main thread for the Caller.\n            - \"NewThread\": Create a new thread.\n            - \"manual\": Manually create a new instance for the current thread.\n\n        **kwargs: Additional options for Caller creation, such as:\n            - name: The name to use.\n            - backend: The async backend to use.\n            - backend_options: Options for the backend.\n            - protected: Whether the Caller is protected.\n            - zmq_context: ZeroMQ context.\n            - log: Logger instance.\n\n    Returns:\n        Self: The created or retrieved Caller instance.\n\n    Raises:\n        RuntimeError: If the backend is not provided and backend can't be determined.\n        ValueError: If the thread and caller's name do not match.\n    \"\"\"\n    with cls._lock:\n        name, backend = kwargs.get(\"name\", \"\"), kwargs.get(\"backend\")\n        match modifier:\n            case \"CurrentThread\" | \"manual\":\n                caller_id = cls.id_current()\n            case \"MainThread\":\n                caller_id = cls.CALLER_MAIN_THREAD_ID\n            case \"NewThread\":\n                caller_id = None\n\n        # Locate existing\n        if caller_id is not None and (caller := cls._instances.get(caller_id)):\n            if modifier == \"manual\":\n                msg = f\"An instance already exists for {caller_id=}\"\n                raise RuntimeError(msg)\n            if name and name != caller.name:\n                msg = f\"The thread and caller's name do not match! {name=} {caller=}\"\n                raise ValueError(msg)\n            if backend and backend != caller.backend:\n                msg = f\"The backend does not match! {backend=} {caller.backend=}\"\n                raise ValueError(msg)\n            return caller\n\n        # create a new instance\n        inst = super().__new__(cls)\n        inst._name = name\n        inst._backend = Backend(backend or current_async_library())\n        inst._loop = Loop(loop) if (loop := kwargs.get(\"loop\")) else None\n        inst._backend_options = kwargs.get(\"backend_options\")\n        inst._loop_options = kwargs.get(\"loop_options\")\n        inst._protected = kwargs.get(\"protected\", False)\n        inst._zmq_context = kwargs.get(\"zmq_context\")\n        inst.log = kwargs.get(\"log\") or logging.LoggerAdapter(logging.getLogger())\n        if (sys.platform == \"emscripten\") and (caller_id is None):\n            caller_id = id(inst)\n        if caller_id is not None:\n            inst._caller_id = caller_id\n            inst._thread = threading.current_thread()\n\n        # finalize\n        if modifier != \"manual\":\n            inst.start_sync()\n        assert inst._caller_id\n        assert inst._caller_id not in cls._instances\n        cls._instances[inst._caller_id] = inst\n    return inst\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(modifier)","title":"<code>modifier</code>","text":"(<code>Literal['CurrentThread', 'MainThread', 'NewThread', 'manual']</code>, default:                   <code>'CurrentThread'</code> )           \u2013            <p>Specifies how the Caller instance should be created or retrieved.</p> <ul> <li>\"CurrentThread\": Automatically create or retrieve the instance.</li> <li>\"MainThread\": Use the main thread for the Caller.</li> <li>\"NewThread\": Create a new thread.</li> <li>\"manual\": Manually create a new instance for the current thread.</li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[CallerCreateOptions]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional options for Caller creation, such as: - name: The name to use. - backend: The async backend to use. - backend_options: Options for the backend. - protected: Whether the Caller is protected. - zmq_context: ZeroMQ context. - log: Logger instance.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_sync","title":"start_sync","text":"<pre><code>start_sync() -&gt; None\n</code></pre> <p>Start synchronously.</p> Referenced by: <ul> <li> Usage Usage Caller Modifier </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def start_sync(self) -&gt; None:\n    \"Start synchronously.\"\n\n    assert self._state is CallerState.initial\n    self._state = CallerState.start_sync\n\n    async def run_caller_in_context() -&gt; None:\n        if self._state is CallerState.start_sync:\n            self._state = CallerState.initial\n            async with self:\n                await self.stopped\n\n    if getattr(self, \"_caller_id\", None) is not None:\n        # An event loop for the current thread.\n\n        if self.backend == Backend.asyncio:\n            self._tasks.add(asyncio.create_task(run_caller_in_context()))\n        else:\n            # trio\n            token = current_token()\n\n            def to_thread():\n                utils.mark_thread_pydev_do_not_trace()\n                try:\n                    anyio.from_thread.run(run_caller_in_context, token=token)\n                except (BaseExceptionGroup, BaseException) as e:\n                    if not \"shutdown\" not in str(e):\n                        raise\n\n            threading.Thread(target=to_thread, daemon=False).start()\n    else:\n        name = self.name or \"async_kernel_caller\"\n        settings = RunSettings(\n            backend=self.backend,\n            loop=self.loop,\n            backend_options=self.backend_options,\n            loop_options=self.loop_options,\n        )\n        args = [run_caller_in_context, (), settings]\n        self._thread = threading.Thread(target=async_kernel.event_loop.run, args=args, name=name, daemon=True)\n        self._caller_id = id(self._thread)\n        self._thread.start()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop","title":"stop","text":"<pre><code>stop(*, force: bool = False) -&gt; CallerState\n</code></pre> <p>Stop the caller cancelling all incomplete tasks.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def stop(self, *, force: bool = False) -&gt; CallerState:\n    \"\"\"\n    Stop the caller cancelling all incomplete tasks.\n\n    Args:\n        force: If the caller is protected the call is a no-op unless force=True.\n    \"\"\"\n    if (self._protected and not force) or self._state is CallerState.stopping:\n        return self._state\n    set_stop = self._state in [CallerState.initial, CallerState.start_sync]\n    self._state = CallerState.stopping\n    self._instances.pop(self._caller_id, None)\n    if parent := self.parent:\n        try:\n            parent._worker_pool.remove(self)\n        except ValueError:\n            pass\n    for child in self.children:\n        child.stop(force=True)\n    if queue := getattr(self, \"_guest_queue\", None):\n        queue.stop()\n    self._queue.stop()\n    for func in tuple(self._queue_map):\n        self.queue_close(func)\n    if set_stop:\n        self.stopped.set()\n        self._state = CallerState.stopped\n    return self._state\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the caller is protected the call is a no-op unless force=True.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__asynccontextmanager__","title":"__asynccontextmanager__  <code>async</code>","text":"<pre><code>__asynccontextmanager__() -&gt; AsyncGenerator[Self]\n</code></pre> <p>The asynchronous context for caller.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@asynccontextmanager\nasync def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n    \"The asynchronous context for caller.\"\n    if (state := self._state) is not CallerState.initial:\n        if state is CallerState.start_sync:\n            msg = 'Already starting! Did you mean to use Caller(\"manual\")?'\n        else:\n            msg = \"Caller cannot be been re-entered!\"\n        raise RuntimeError(msg)\n    if not self._name:\n        self._name = threading.current_thread().name\n    async with anyio.create_task_group() as tg:\n        socket = None\n        self._state = CallerState.running\n        tg.start_soon(self._scheduler, self.backend, self._queue, tg)\n        if self._zmq_context:\n            socket = self._zmq_context.socket(1)  # zmq.SocketType.PUB\n            socket.linger = 50\n            socket.connect(self.iopub_url)\n            self.iopub_sockets[self._caller_id] = socket\n        try:\n            yield self\n        finally:\n            if stop_guest := getattr(self, \"_stop_guest\", None):\n                with anyio.CancelScope(shield=True):\n                    await stop_guest()\n            self.stop(force=True)\n            if socket:\n                self.iopub_sockets.pop(self._caller_id, None)\n                socket.close()\n            with anyio.CancelScope(shield=True):\n                while self._children:\n                    await self._children.pop().stopped\n                if parent := self.parent:\n                    parent._children.discard(self)\n                self._state = CallerState.stopped\n                self.stopped.set()\n                await self.checkpoint()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.id_current","title":"id_current  <code>classmethod</code>","text":"<pre><code>id_current() -&gt; int\n</code></pre> <p>The id that is used for a caller for the current thread in CPython or context in Pyodide.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef id_current(cls) -&gt; int:\n    \"The id that is used for a caller for the current thread in CPython or context in Pyodide.\"\n    if sys.platform == \"emscripten\":\n        return cls._caller_token.get()\n    return id(threading.current_thread())\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_existing","title":"get_existing  <code>classmethod</code>","text":"<pre><code>get_existing(caller_id: int | None = None) -&gt; Self | None\n</code></pre> <p>A classmethod to get the caller instance from the corresponding thread if it exists.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef get_existing(cls, caller_id: int | None = None, /) -&gt; Self | None:\n    \"\"\"\n    A [classmethod][] to get the caller instance from the corresponding thread if it exists.\n\n    Args:\n        caller_id: The id of the caller which in CPython is also the the id of the thread in which it is running.\n    \"\"\"\n    caller_id = cls.id_current() if caller_id is None else caller_id\n    with cls._lock:\n        return cls._instances.get(caller_id)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_existing(caller_id)","title":"<code>caller_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The id of the caller which in CPython is also the the id of the thread in which it is running.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.current_pending","title":"current_pending  <code>classmethod</code>","text":"<pre><code>current_pending() -&gt; Pending[Any] | None\n</code></pre> <p>A classmethod that returns the current result when called from inside a function scheduled by Caller.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef current_pending(cls) -&gt; Pending[Any] | None:\n    \"\"\"A [classmethod][] that returns the current result when called from inside a function scheduled by Caller.\"\"\"\n    return cls._pending_var.get()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers","title":"all_callers  <code>classmethod</code>","text":"<pre><code>all_callers(running_only: bool = True) -&gt; list[Caller]\n</code></pre> <p>A classmethod to get a list of the callers.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef all_callers(cls, running_only: bool = True) -&gt; list[Caller]:\n    \"\"\"\n    A [classmethod][] to get a list of the callers.\n\n    Args:\n        running_only: Restrict the list to callers that are active (running in an async context).\n    \"\"\"\n    return [caller for caller in Caller._instances.values() if caller.running or not running_only]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers(running_only)","title":"<code>running_only</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Restrict the list to callers that are active (running in an async context).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get","title":"get","text":"<pre><code>get(**kwargs: Unpack[CallerCreateOptions]) -&gt; Self\n</code></pre> <p>Retrieves an existing child caller by name and backend, or creates a new one if not found.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The retrieved or newly created caller instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If a caller with the specified name exists but the backend does not match.</p> </li> </ul> Notes <ul> <li>The returned caller is added to <code>children</code> and stopped with this instance.</li> <li>If 'backend' and 'zmq_context' are not specified they are copied from this instance.</li> </ul> Referenced by: <ul> <li> Usage Usage Caller Caller.get </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def get(self, **kwargs: Unpack[CallerCreateOptions]) -&gt; Self:\n    \"\"\"\n    Retrieves an existing child caller by name and backend, or creates a new one if not found.\n\n    Args:\n        **kwargs: Options for creating or retrieving a caller instance.\n            - name: The name of the child caller to retrieve.\n            - backend: The backend to match or assign to the caller.\n            - backend_options: Options for the backend.\n            - zmq_context: ZeroMQ context to use.\n\n    Returns:\n        Self: The retrieved or newly created caller instance.\n\n    Raises:\n        RuntimeError: If a caller with the specified name exists but the backend does not match.\n\n    Notes:\n        - The returned caller is added to `children` and stopped with this instance.\n        - If 'backend' and 'zmq_context' are not specified they are copied from this instance.\n    \"\"\"\n\n    with self._child_lock:\n        if name := kwargs.get(\"name\"):\n            for caller in self.children:\n                if caller.name == name:\n                    if (backend := kwargs.get(\"backend\")) and caller.backend != backend:\n                        msg = f\"Backend mismatch! {backend=} {caller.backend=}\"\n                        raise RuntimeError(msg)\n                    if (loop := kwargs.get(\"loop\")) and caller.loop != loop:\n                        msg = f\"Event loop mismatch! {loop=} {caller.loop=}\"\n                        raise RuntimeError(msg)\n                    return caller\n        if \"backend\" not in kwargs:\n            kwargs[\"backend\"] = self._backend\n            kwargs[\"backend_options\"] = self.backend_options\n        if \"zmq_context\" not in kwargs and self._zmq_context:\n            kwargs[\"zmq_context\"] = self._zmq_context\n        caller = self.__class__(\"NewThread\", **kwargs)\n        self._children.add(caller)\n        caller._parent_ref = weakref.ref(self)\n        return caller\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.get(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[CallerCreateOptions]</code>, default:                   <code>{}</code> )           \u2013            <p>Options for creating or retrieving a caller instance. - name: The name of the child caller to retrieve. - backend: The backend to match or assign to the caller. - backend_options: Options for the backend. - zmq_context: ZeroMQ context to use.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call","title":"schedule_call","text":"<pre><code>schedule_call(\n    func: Callable[..., CoroutineType[Any, Any, T] | T],\n    args: tuple,\n    kwargs: dict,\n    context: Context | None = None,\n    trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = PendingTracker,\n    backend: NoValue | Backend = NoValue,\n    /,\n    **metadata: Any,\n) -&gt; Pending[T]\n</code></pre> <p>Schedule <code>func</code> to be called inside a task running in the callers thread (thread-safe).</p> <p>The methods call_soon and call_later use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def schedule_call(\n    self,\n    func: Callable[..., CoroutineType[Any, Any, T] | T],\n    args: tuple,\n    kwargs: dict,\n    context: contextvars.Context | None = None,\n    trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = PendingTracker,\n    backend: NoValue | Backend = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    /,\n    **metadata: Any,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule `func` to be called inside a task running in the callers thread (thread-safe).\n\n    The methods [call_soon][Caller.call_soon] and [call_later][Caller.call_later]\n    use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.\n\n    Args:\n        func: The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.\n        args: Arguments corresponding to in the call to  `func`.\n        kwargs: Keyword arguments to use with in the call to `func`.\n        context: The context to use, if not provided the current context is used.\n        trackers: The tracker subclasses of active trackers which to add the pending.\n        **metadata: Additional metadata to store in the instance.\n    \"\"\"\n    pen = Pending(trackers, context, func=func, args=args, kwargs=kwargs, caller=self, **metadata)\n    if backend is NoValue or (backend := Backend(backend)) is self.backend:\n        self._queue.append(pen)\n    else:\n        if not hasattr(self, \"_guest_queue\"):\n            self._guest_queue = SingleConsumerAsyncQueue(backend, reject=self._reject)\n            self.schedule_call(\n                self._guest_backend_loop, (), {\"backend\": backend, \"queue\": self._guest_queue}, None, ()\n            )\n        self._guest_queue.append(pen)\n    return pen\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(func)","title":"<code>func</code>","text":"(<code>Callable[..., CoroutineType[Any, Any, T] | T]</code>)           \u2013            <p>The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(args)","title":"<code>args</code>","text":"(<code>tuple</code>)           \u2013            <p>Arguments corresponding to in the call to  <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(kwargs)","title":"<code>kwargs</code>","text":"(<code>dict</code>)           \u2013            <p>Keyword arguments to use with in the call to <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(context)","title":"<code>context</code>","text":"(<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>The context to use, if not provided the current context is used.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(trackers)","title":"<code>trackers</code>","text":"(<code>type[PendingTracker] | tuple[type[PendingTracker], ...]</code>, default:                   <code>PendingTracker</code> )           \u2013            <p>The tracker subclasses of active trackers which to add the pending.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(**metadata)","title":"<code>**metadata</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional metadata to store in the instance.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later","title":"call_later","text":"<pre><code>call_later(\n    delay: float,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Pending[T]\n</code></pre> <p>Schedule func to be called in caller's event loop copying the current context.</p> <p>Parameters:</p> Info <p>All call arguments are packed into the instance's metadata.</p> Referenced by: <ul> <li> Reference caller <code></code>\u00a0Caller <code></code>\u00a0schedule_call </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_later(\n    self,\n    delay: float,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule func to be called in caller's event loop copying the current context.\n\n    Args:\n        func: The function.\n        delay: The minimum delay to add between submission and execution.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n\n    Info:\n        All call arguments are packed into the instance's metadata.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs, delay=delay, start_time=time.monotonic())\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(delay)","title":"<code>delay</code>","text":"(<code>float</code>)           \u2013            <p>The minimum delay to add between submission and execution.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon","title":"call_soon","text":"<pre><code>call_soon(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Pending[T]\n</code></pre> <p>Schedule func to be executed.</p> <p>Parameters:</p> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0call_using_backend </li> <li> <code></code>\u00a0schedule_call </li> </ul> </li> <li> typing <code></code>\u00a0RunMode </li> </ul> </li> <li> Usage Message handling Run mode </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_soon(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule func to be executed.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_using_backend","title":"call_using_backend","text":"<pre><code>call_using_backend(\n    backend: Backend | Literal[\"asyncio\", \"trio\"],\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Pending[T]\n</code></pre> <p>Schedule func to be executed using the specified backend.</p> <p>This methods enables coroutines written for a specific function to be run irresective of the callers backend.</p> <ul> <li><code>backend == caller.backend</code> - <code>func</code> is executed via Caller.call_soon.</li> <li><code>backend != caller.backend</code> - <code>func</code> is executed with a backend running as a guest.</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Notes:</p> <pre><code>- **Only use this to execute coroutines that require a specific backend to run in the callers thread.**\n- Where possible use a separate caller/thread with [Caller.get][] instead.\n</code></pre> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_using_backend(\n    self,\n    backend: Backend | Literal[\"asyncio\", \"trio\"],\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule func to be executed using the specified backend.\n\n    This methods enables coroutines written for a specific function to be run irresective\n    of the callers backend.\n\n    - `backend == caller.backend` - `func` is executed via [Caller.call_soon][].\n    - `backend != caller.backend` - `func` is executed with a backend running as a guest.\n\n    Args:\n        backend: The backend in which `func` must be executed.\n        func: The function.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n\n    Notes:\n\n        - **Only use this to execute coroutines that require a specific backend to run in the callers thread.**\n        - Where possible use a separate caller/thread with [Caller.get][] instead.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs, None, PendingTracker, Backend(backend))\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_using_backend(backend)","title":"<code>backend</code>","text":"(<code>Backend | Literal['asyncio', 'trio']</code>)           \u2013            <p>The backend in which <code>func</code> must be executed.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_using_backend(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_using_backend(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_using_backend(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct","title":"call_direct","text":"<pre><code>call_direct(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; None\n</code></pre> <p>Schedule <code>func</code> to be called in caller's event loop directly.</p> <p>Use this for short-running function calls only.</p> <p>Parameters:</p> <p>Warning:</p> <pre><code>**Use this method for lightweight calls only!**\n</code></pre> Referenced by: <ul> <li> Usage Message handling Run mode </li> <li> Reference typing <code></code>\u00a0RunMode </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_direct(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"\n    Schedule `func` to be called in caller's event loop directly.\n\n    Use this for short-running function calls only.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n\n    Warning:\n\n        **Use this method for lightweight calls only!**\n    \"\"\"\n    self._queue.append((func, args, kwargs))\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread","title":"to_thread","text":"<pre><code>to_thread(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Pending[T]\n</code></pre> <p>Call func in a worker thread using the same backend as the current instance.</p> <p>Parameters:</p> Notes <ul> <li>A minimum number of caller instances are retained for this method.</li> <li>Async code run inside func should use taskgroups for creating task.</li> </ul> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0MAX_IDLE_POOL_INSTANCES </li> <li> <code></code>\u00a0as_completed </li> </ul> </li> <li> typing <code></code>\u00a0RunMode </li> </ul> </li> <li> Usage <ul> <li> Message handling Run mode </li> <li> Usage <ul> <li> Blocking code </li> <li> Caller Caller.to_thread </li> </ul> </li> </ul> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def to_thread(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Call func in a worker thread using the same backend as the current instance.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Notes:\n        - A minimum number of caller instances are retained for this method.\n        - Async code run inside func should use taskgroups for creating task.\n    \"\"\"\n\n    def _to_thread_on_done(_) -&gt; None:\n        if not caller.stopped and self.running:\n            if len(self._worker_pool) &lt; self.MAX_IDLE_POOL_INSTANCES:\n                caller._idle_time = time.monotonic()\n                self._worker_pool.append(caller)\n                self._start_idle_worker_cleanup_thead()\n            else:\n                caller.stop()\n\n    try:\n        caller = self._worker_pool.popleft()\n    except IndexError:\n        caller = self.get()\n    pen = caller.call_soon(func, *args, **kwargs)\n    pen.add_done_callback(_to_thread_on_done)\n    return pen\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_get","title":"queue_get","text":"<pre><code>queue_get(func: Callable) -&gt; Pending[None] | None\n</code></pre> <p>Returns <code>Pending</code> instance for <code>func</code> where the queue is running.</p> Warning <ul> <li>This instance loops until the instance is closed or func is garbage collected.</li> <li>The pending has been modified such that waiting it will wait for the queue to be empty.</li> <li><code>queue_close</code> is the preferred means to shutdown the queue.</li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_get(self, func: Callable) -&gt; Pending[None] | None:\n    \"\"\"Returns `Pending` instance for `func` where the queue is running.\n\n    Warning:\n        - This instance loops until the instance is closed or func is garbage collected.\n        - The pending has been modified such that waiting it will wait for the queue to be empty.\n        - `queue_close` is the preferred means to shutdown the queue.\n    \"\"\"\n    return self._queue_map.get(hash(func))\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call","title":"queue_call","text":"<pre><code>queue_call(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Pending[T]\n</code></pre> <p>Queue the execution of <code>func</code> in a queue unique to it and the caller instance (thread-safe).</p> <p>The returned pending is 'resettable' and will provide the result of the most recent successful call once the queue has been emptied. Exceptions are not set, instead the result would be <code>None</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Pending</code> (              <code>Pending[T]</code> )          \u2013            <p>The pending where the queue loop is running.</p> </li> </ul> Warning <ul> <li>Do not assume the result corresponds to the function call.</li> <li>The returned pending returns the last result of the queue call once the queue becomes empty.</li> </ul> Notes <ul> <li>The queue runs in a task wrapped with a async_kernel.pending.Pending that remains running until one of the following occurs:<ol> <li>The pending is cancelled.</li> <li>The method Caller.queue_close is called with <code>func</code> or <code>func</code>'s hash.</li> <li><code>func</code> is deleted (utilising weakref.finalize).</li> </ol> </li> <li>The context of the initial call is used for subsequent queue calls.</li> <li>Exceptions are 'swallowed'; the last successful result is set on the pending.</li> </ul> Referenced by: <ul> <li> Usage Message handling Run mode </li> <li> Reference typing <code></code>\u00a0RunMode </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_call(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Queue the execution of `func` in a queue unique to it and the caller instance (thread-safe).\n\n    The returned pending is 'resettable' and will provide the result of the most recent successful\n    call once the queue has been emptied. Exceptions are not set, instead the result would be `None`.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n\n    Returns:\n        Pending: The pending where the queue loop is running.\n\n    Warning:\n        - Do not assume the result corresponds to the function call.\n        - The returned pending returns the last result of the queue call once the queue becomes empty.\n\n    Notes:\n        - The queue runs in a *task* wrapped with a [async_kernel.pending.Pending][] that remains running until one of the following occurs:\n            1. The pending is cancelled.\n            2. The method [Caller.queue_close][] is called with `func` or `func`'s hash.\n            3. `func` is deleted (utilising [weakref.finalize][]).\n        - The [context][contextvars.Context] of the initial call is used for subsequent queue calls.\n        - Exceptions are 'swallowed'; the last successful result is set on the pending.\n    \"\"\"\n    key = hash(func)\n    if not (pen_ := self._queue_map.get(key)):\n        queue = SingleConsumerAsyncQueue[tuple[Callable, tuple, dict]](self.backend)\n        with contextlib.suppress(TypeError):\n            weakref.finalize(func.__self__ if inspect.ismethod(func) else func, self.queue_close, key)\n\n        async def queue_loop() -&gt; None:\n            pen = self.current_pending()\n            assert pen\n            result = None\n            try:\n                async for item in queue:\n                    try:\n                        result = item[0](*item[1], **item[2])\n                        if inspect.iscoroutine(object=result):\n                            result = await result\n                    except (anyio.get_cancelled_exc_class(), Exception) as e:\n                        if pen.cancelled():\n                            raise\n                        self.log.exception(\"Execution %s failed\", item, exc_info=e)\n                    if not queue.queue:\n                        pen.set_result(result, reset=True)\n                        item = result = None  # noqa: PLW2901\n            finally:\n                self._queue_map.pop(key)\n\n        self._queue_map[key] = pen_ = self.schedule_call(queue_loop, (), {}, key=key, queue=queue)\n    pen_.metadata[\"queue\"].append((func, args, kwargs))\n    return pen_.add_to_trackers()  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close","title":"queue_close","text":"<pre><code>queue_close(func: Callable | int) -&gt; None\n</code></pre> <p>Close the execution queue associated with <code>func</code> (thread-safe).</p> <p>Parameters:</p> Referenced by: <ul> <li> Reference caller <code></code>\u00a0Caller <code></code>\u00a0queue_call </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_close(self, func: Callable | int) -&gt; None:\n    \"\"\"\n    Close the execution queue associated with `func` (thread-safe).\n\n    Args:\n        func: The queue of the function to close.\n    \"\"\"\n    key = func if isinstance(func, int) else hash(func)\n    if pen := self._queue_map.pop(key, None):\n        pen.metadata[\"queue\"].stop()\n        pen.cancel()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close(func)","title":"<code>func</code>","text":"(<code>Callable | int</code>)           \u2013            <p>The queue of the function to close.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.checkpoint","title":"checkpoint  <code>async</code>","text":"<pre><code>checkpoint() -&gt; None\n</code></pre> <p>Yield to the event loop.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def checkpoint(self) -&gt; None:\n    \"Yield to the event loop.\"\n    if not self._use_safe_checkpoint:\n        try:\n            if self.backend is Backend.trio:\n                await trio_checkpoint()\n            else:\n                await asyncio_checkpoint()\n        except Exception:\n            self._use_safe_checkpoint = True\n        else:\n            return\n    await async_checkpoint(force=True)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed","title":"as_completed  <code>async</code>","text":"<pre><code>as_completed(\n    items: Iterable[Awaitable[T]] | AsyncGenerator[Awaitable[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,\n    cancel_unfinished: bool = True,\n) -&gt; AsyncGenerator[Pending[T], Any]\n</code></pre> <p>An iterator to get result as they complete.</p> <p>Parameters:</p> Tip <ol> <li>Pass a generator if you wish to limit the number result jobs when calling to_thread/to_task etc.</li> <li>Pass a container with all results when the limiter is not relevant.</li> </ol> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def as_completed(\n    self,\n    items: Iterable[Awaitable[T]] | AsyncGenerator[Awaitable[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    cancel_unfinished: bool = True,\n) -&gt; AsyncGenerator[Pending[T], Any]:\n    \"\"\"\n    An iterator to get result as they complete.\n\n    Args:\n        items: Either a container with existing results or generator of Pendings.\n        max_concurrent: The maximum number of concurrent results to monitor at a time.\n            This is useful when `items` is a generator utilising [Caller.to_thread][].\n            By default this will limit to `Caller.MAX_IDLE_POOL_INSTANCES`.\n        cancel_unfinished: Cancel any `pending` when exiting.\n\n    Tip:\n        1. Pass a generator if you wish to limit the number result jobs when calling to_thread/to_task etc.\n        2. Pass a container with all results when the limiter is not relevant.\n    \"\"\"\n    resume = noop\n    queue: SingleConsumerAsyncQueue[Pending[T]] = SingleConsumerAsyncQueue(self.backend)\n    unfinished: set[Pending[T]] = set()\n    pen_current = self.current_pending()\n    if isinstance(items, set | list | tuple):\n        max_concurrent_ = 0\n    else:\n        max_concurrent_ = self.MAX_IDLE_POOL_INSTANCES if max_concurrent is NoValue else int(max_concurrent)\n\n    async def scheduler():\n        nonlocal resume\n        gen = items if isinstance(items, AsyncGenerator) else iter(items)\n        is_async = isinstance(gen, AsyncGenerator)\n        while not queue.stopped and (pen := await anext(gen, None) if is_async else next(gen, None)) is not None:\n            if pen is pen_current:\n                queue.stop()\n                msg = \"Waiting for the pending in which it is running would result in deadlock!\"\n                raise RuntimeError(msg)\n            if not isinstance(pen, Pending):\n                pen = cast(\"Pending[T]\", self.call_soon(await_for, pen))\n            pen.add_done_callback(queue.append)\n            if not pen.done():\n                unfinished.add(pen)\n                if max_concurrent_ and len(unfinished) == max_concurrent_:\n                    waiter = create_async_waiter()\n                    resume = waiter.wake\n                    if len(unfinished) == max_concurrent_:\n                        await waiter\n                    resume = noop\n\n    pen_ = self.call_soon(scheduler)\n    try:\n        async for pen in queue:\n            unfinished.discard(pen)\n            yield pen\n            if pen_.done() and not unfinished and not queue.queue:\n                break\n            else:\n                if max_concurrent_ and len(unfinished) &lt; max_concurrent_:\n                    resume()\n        pen_.result()\n    finally:\n        queue.stop()\n        pen_.cancel()\n        for pen in unfinished:\n            pen.remove_done_callback(queue.append)\n            if cancel_unfinished:\n                pen.cancel(\"Cancelled by as_completed\")\n        with anyio.CancelScope():\n            await pen_.wait(result=False)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(items)","title":"<code>items</code>","text":"(<code>Iterable[Awaitable[T]] | AsyncGenerator[Awaitable[T]]</code>)           \u2013            <p>Either a container with existing results or generator of Pendings.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(max_concurrent)","title":"<code>max_concurrent</code>","text":"(<code>NoValue | int</code>, default:                   <code>NoValue</code> )           \u2013            <p>The maximum number of concurrent results to monitor at a time. This is useful when <code>items</code> is a generator utilising Caller.to_thread. By default this will limit to <code>Caller.MAX_IDLE_POOL_INSTANCES</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(cancel_unfinished)","title":"<code>cancel_unfinished</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Cancel any <code>pending</code> when exiting.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    items: Iterable[Awaitable[T]],\n    *,\n    timeout: float | None = None,\n    return_when: Literal[\n        \"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"\n    ] = \"ALL_COMPLETED\",\n) -&gt; tuple[set[Pending[T]], set[Pending[T]]]\n</code></pre> <p>Wait for the results given by items to complete.</p> <p>Returns two sets of the results: (done, pending).</p> <p>Parameters:</p> Example <pre><code>done, pending = await asyncio.wait(items)\n</code></pre> <p>Info:     - This does not raise a TimeoutError!     - Pendings that aren't done when the timeout occurs are returned in the second set.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def wait(\n    self,\n    items: Iterable[Awaitable[T]],\n    *,\n    timeout: float | None = None,\n    return_when: Literal[\"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"] = \"ALL_COMPLETED\",\n) -&gt; tuple[set[Pending[T]], set[Pending[T]]]:\n    \"\"\"\n    Wait for the results given by items to complete.\n\n    Returns two sets of the results: (done, pending).\n\n    Args:\n        items: An iterable of results to wait for.\n        timeout: The maximum time before returning.\n        return_when: The same options as available for [asyncio.wait][].\n\n    Example:\n        ```python\n        done, pending = await asyncio.wait(items)\n        ```\n    Info:\n        - This does not raise a TimeoutError!\n        - Pendings that aren't done when the timeout occurs are returned in the second set.\n    \"\"\"\n    pending: set[Pending[T]] = set()\n    done = set()\n    for item in items:\n        if isinstance(item, Pending):\n            done.add(item) if item.done() else pending.add(item)\n        else:\n            pending.add(self.call_soon(await_for, item))\n    if done:\n        if return_when == \"FIRST_COMPLETED\":\n            return done, pending\n        if return_when == \"FIRST_EXCEPTION\":\n            for pen in done:\n                if pen.cancelled() or pen.exception():\n                    return done, pending\n    if pending:\n        with anyio.move_on_after(timeout):\n            async for pen in self.as_completed(pending.copy(), cancel_unfinished=False):\n                pending.discard(pen)\n                done.add(pen)\n                if return_when == \"FIRST_COMPLETED\":\n                    break\n                if return_when == \"FIRST_EXCEPTION\" and (pen.cancelled() or pen.exception()):\n                    break\n    return done, pending\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(items)","title":"<code>items</code>","text":"(<code>Iterable[Awaitable[T]]</code>)           \u2013            <p>An iterable of results to wait for.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum time before returning.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(return_when)","title":"<code>return_when</code>","text":"(<code>Literal['FIRST_COMPLETED', 'FIRST_EXCEPTION', 'ALL_COMPLETED']</code>, default:                   <code>'ALL_COMPLETED'</code> )           \u2013            <p>The same options as available for asyncio.wait.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.create_pending_group","title":"create_pending_group","text":"<pre><code>create_pending_group(*, shield: bool = False)\n</code></pre> <p>Create a new PendingGroup instance.</p> <p>The pending group will wait for all pending created in its context to complete (except for those that opt out). If any pending result in exception, the pending group and all registered pending are cancelled. If the pending group context is cancelled or results in exception, all pending in the group are also cancelled.</p> <p>Parameters:</p> <p>Usage:</p> <pre><code>```python\nasync with Caller().create_pending_group() as pg:\n    pg.caller.to_thread(my_func)\n    ...\n```\n</code></pre> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def create_pending_group(self, *, shield: bool = False):\n    \"\"\"\n    Create a new [PendingGroup][async_kernel.pending.PendingGroup] instance.\n\n    The pending group will wait for all pending created in its context to complete (except for those that opt out).\n    If any pending result in exception, the pending group and all registered pending are cancelled.\n    If the pending group context is cancelled or results in exception, all pending in the group are\n    also cancelled.\n\n    Args:\n        shield: Shield the pending group from external cancellation.\n\n    Usage:\n\n        ```python\n        async with Caller().create_pending_group() as pg:\n            pg.caller.to_thread(my_func)\n            ...\n        ```\n    \"\"\"\n    return PendingGroup(shield=shield)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.create_pending_group(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield the pending group from external cancellation.</p>"},{"location":"reference/comm/","title":"comm","text":"<p>Classes:</p> <ul> <li> <code>Comm</code>           \u2013            <p>An implementation of <code>comm.BaseComms</code> for async-kernel  (on pypi).</p> </li> </ul>"},{"location":"reference/comm/#async_kernel.comm.Comm","title":"Comm","text":"<p>               Bases: <code>BaseComm</code></p> <p>An implementation of <code>comm.BaseComms</code> for async-kernel  (on pypi).</p> Notes <ul> <li><code>kernel</code> is added/removed by the CommManager.</li> <li><code>kernel</code> is added to the CommManager by the kernel once the sockets have been opened.</li> <li>publish_msg is no-op when kernel is unset.</li> </ul> Referenced by: <ul> <li> Reference kernel <code></code>\u00a0Kernel </li> </ul> <p>Methods:</p> <ul> <li> <code>publish_msg</code>             \u2013              <p>Helper for sending a comm message on IOPub.</p> </li> <li> <code>handle_msg</code>             \u2013              <p>Handle a comm_msg message</p> </li> </ul> Source code in <code>src/async_kernel/comm.py</code> <pre><code>class Comm(BaseComm):\n    \"\"\"\n    An implementation of `comm.BaseComms` for async-kernel  ([on pypi](https://pypi.org/project/comm/)).\n\n    Notes:\n        - `kernel` is added/removed by the CommManager.\n        - `kernel` is added to the CommManager by the kernel once the sockets have been opened.\n        - publish_msg is no-op when kernel is unset.\n    \"\"\"\n\n    kernel: Kernel | None = None\n\n    @override\n    def publish_msg(\n        self,\n        msg_type: str,\n        data: MaybeDict = None,\n        metadata: MaybeDict = None,\n        buffers: BuffersType = None,\n        **keys,\n    ):\n        \"\"\"Helper for sending a comm message on IOPub.\"\"\"\n        if (kernel := self.kernel) is None:\n            # Only send when the kernel is set\n            return\n        content = {\"data\": {} if data is None else data, \"comm_id\": self.comm_id} | keys\n        kernel.iopub_send(\n            msg_or_type=msg_type,\n            content=content,\n            metadata=metadata,\n            parent=None,\n            ident=self.topic,\n            buffers=buffers,\n        )\n\n    @override\n    def handle_msg(self, msg: comm.base_comm.MessageType) -&gt; None:\n        \"\"\"Handle a comm_msg message\"\"\"\n        if self._msg_callback:\n            self._msg_callback(msg)\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.Comm.publish_msg","title":"publish_msg","text":"<pre><code>publish_msg(\n    msg_type: str,\n    data: MaybeDict = None,\n    metadata: MaybeDict = None,\n    buffers: BuffersType = None,\n    **keys,\n)\n</code></pre> <p>Helper for sending a comm message on IOPub.</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef publish_msg(\n    self,\n    msg_type: str,\n    data: MaybeDict = None,\n    metadata: MaybeDict = None,\n    buffers: BuffersType = None,\n    **keys,\n):\n    \"\"\"Helper for sending a comm message on IOPub.\"\"\"\n    if (kernel := self.kernel) is None:\n        # Only send when the kernel is set\n        return\n    content = {\"data\": {} if data is None else data, \"comm_id\": self.comm_id} | keys\n    kernel.iopub_send(\n        msg_or_type=msg_type,\n        content=content,\n        metadata=metadata,\n        parent=None,\n        ident=self.topic,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.Comm.handle_msg","title":"handle_msg","text":"<pre><code>handle_msg(msg: MessageType) -&gt; None\n</code></pre> <p>Handle a comm_msg message</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef handle_msg(self, msg: comm.base_comm.MessageType) -&gt; None:\n    \"\"\"Handle a comm_msg message\"\"\"\n    if self._msg_callback:\n        self._msg_callback(msg)\n</code></pre>"},{"location":"reference/command/","title":"command","text":"<p>Functions:</p> <ul> <li> <code>command_line</code>             \u2013              <p>Parses command-line arguments to manage kernel specs and start kernels.</p> </li> </ul>"},{"location":"reference/command/#async_kernel.command.command_line","title":"command_line","text":"<pre><code>command_line() -&gt; None\n</code></pre> <p>Parses command-line arguments to manage kernel specs and start kernels.</p> <p>This function uses <code>argparse</code> to handle command-line arguments for various kernel operations, including:</p> <ul> <li>Starting a kernel with a specified connection file.</li> <li>Adding a new kernel specification.</li> <li>Removing an existing kernel specification.</li> <li>Print version.</li> </ul> <p>The function determines the appropriate action based on the provided arguments and either starts a kernel, adds a kernel spec, or removes a kernel spec.  If no connection file is provided and no other action is specified, it prints the help message.</p> <p>When starting a kernel, it imports the specified kernel factory (or uses the default <code>Kernel</code> class) and configures the kernel instance with the provided arguments. It then starts the kernel within an <code>anyio</code> context, handling keyboard interrupts and other exceptions.</p> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>If an error occurs during kernel execution or if the program is interrupted.</p> </li> </ul> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> kernel <code></code>\u00a0Kernel </li> <li> kernelspec <code></code>\u00a0make_argv </li> </ul> </li> <li> Usage Command line and kernel configuration Start a kernel </li> </ul> Source code in <code>src/async_kernel/command.py</code> <pre><code>def command_line() -&gt; None:\n    \"\"\"\n    Parses command-line arguments to manage kernel specs and start kernels.\n\n    This function uses `argparse` to handle command-line arguments for\n    various kernel operations, including:\n\n    - Starting a kernel with a specified connection file.\n    - Adding a new kernel specification.\n    - Removing an existing kernel specification.\n    - Print version.\n\n    The function determines the appropriate action based on the provided\n    arguments and either starts a kernel, adds a kernel spec, or removes\n    a kernel spec.  If no connection file is provided and no other action\n    is specified, it prints the help message.\n\n    When starting a kernel, it imports the specified kernel factory (or uses\n    the default `Kernel` class) and configures the kernel instance with\n    the provided arguments. It then starts the kernel within an `anyio`\n    context, handling keyboard interrupts and other exceptions.\n\n    Raises:\n        SystemExit: If an error occurs during kernel execution or if the\n            program is interrupted.\n    \"\"\"\n    kernel_dir: Path = get_kernel_dir()\n    title = \"Async kernel\"\n    parser = argparse.ArgumentParser(\n        description=\"=\" * len(title)\n        + f\"\\n{title}\\n\"\n        + \"=\" * len(title)\n        + \"\\n\\n\"\n        + \"With the async-kernel command line tool you can:\\n\\n\"\n        + \"    - Add/remove kernel specs\\n\"\n        + \"    - start kernels\\n\\n\"\n        + \"Online help: https://fleming79.github.io/async-kernel/latest/commands/#command-line \\n\\n\"\n        + f\"Jupyter kernel directory: '{kernel_dir}'\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--connection_file\",\n        dest=\"connection_file\",\n        help=\"Start a kernel with a connection file. To start a kernel without a file use a period `.`.\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--add\",\n        dest=\"add\",\n        help=\"Write a kernel spec with the corresponding name. This will overwrite existing kernel specs of the same name.\",\n    )\n    kernels = [] if not kernel_dir.exists() else [item.name for item in kernel_dir.iterdir() if item.is_dir()]\n    parser.add_argument(\n        \"-r\",\n        \"--remove\",\n        dest=\"remove\",\n        help=f\"Remove existing kernel specs. Installed kernels: {kernels}.\",\n    )\n    parser.add_argument(\n        \"-V\",\n        \"--version\",\n        dest=\"version\",\n        help=\"Print version\",\n        action=\"store_true\",\n    )\n    args, unknownargs = parser.parse_known_args()\n    cl_names = set(vars(args))\n\n    # Convert unknownargs from flags to mappings\n    for v in (v.lstrip(\"-\") for v in unknownargs):\n        if \"=\" in v:\n            k, v_ = v.split(\"=\", maxsplit=1)\n            setattr(args, k, v_.strip(\"'\\\"\").strip())\n        else:\n            # https://docs.python.org/3/library/argparse.html#argparse.BooleanOptionalAction\n            setattr(args, v.removeprefix(\"no-\"), False) if v.startswith(\"no-\") else setattr(args, v, True)\n\n    # Add kernel spec\n    if args.add:\n        if not hasattr(args, \"kernel_name\"):\n            args.kernel_name = args.add\n        for name in cl_names:\n            delattr(args, name)\n        path = write_kernel_spec(**vars(args))\n        print(f\"Added kernel spec {path!s}\")\n\n    # Remove kernel spec\n    elif args.remove:\n        for name in args.remove.split(\",\"):\n            msg = \"removed\" if remove_kernel_spec(name) else \"not found!\"\n            print(f\"Kernel spec: '{name}' {msg}\")\n\n    # Version\n    elif args.version:\n        print(\"async-kernel\", async_kernel.__version__)\n\n    # Start kernel\n    elif args.connection_file:\n        settings = vars(args)\n        for k in cl_names.difference([\"connection_file\"]):\n            settings.pop(k, None)\n        if settings.get(\"connection_file\") in {None, \"\", \".\"}:\n            settings.pop(\"connection_file\", None)\n        factory: InterfaceStartType = import_start_interface(getattr(args, \"start_interface\", \"\"))\n        try:\n            factory(settings)\n            gc.collect()\n        except KeyboardInterrupt:\n            pass\n        except BaseException as e:\n            if \"Stopping kernel\" not in str(e):\n                traceback.print_exception(e, file=sys.stderr)\n                if sys.__stderr__ is not sys.stderr:\n                    traceback.print_exception(e, file=sys.__stderr__)\n                    sys.exit(1)\n        sys.exit(0)\n\n    # Print help\n    else:\n        parser.print_help()\n</code></pre>"},{"location":"reference/common/","title":"common","text":"<p>Classes:</p> <ul> <li> <code>Fixed</code>           \u2013            <p>A thread-safe descriptor factory for creating and caching an object.</p> </li> <li> <code>LastUpdatedDict</code>           \u2013            <p>A dictionary that moves the key to the beginning or end when the value is set.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>import_item</code>             \u2013              <p>Import an item from a module, given its dotted name.</p> </li> </ul>"},{"location":"reference/common/#async_kernel.common.Fixed","title":"Fixed","text":"<p>               Bases: <code>Generic[S, T]</code></p> <p>A thread-safe descriptor factory for creating and caching an object.</p> <p>The <code>Fixed</code> descriptor provisions for each instance of the owner class to dynamically load or import the managed class.  The managed instance is created on first access and then cached for subsequent access.</p> Type Hints <ul> <li><code>S</code>: Type of the owner class.</li> <li><code>T</code>: Type of the managed class.</li> </ul> Example <pre><code>class MyClass:\n    a: Fixed[Self, dict] = Fixed(dict)\n    b: Fixed[Self, int] = Fixed(lambda c: id(c[\"owner\"].a))\n    c: Fixed[Any, list[str]] = Fixed(list, created=lambda c: c[\"obj\"].append(c[\"name\"]))\n</code></pre> Returned by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0PendingGroup <code></code>\u00a0caller </li> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0callers </li> <li> <code></code>\u00a0interrupts </li> <li> <code></code>\u00a0kernel </li> </ul> </li> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0callers </li> <li> <code></code>\u00a0interrupts </li> <li> <code></code>\u00a0kernel </li> </ul> </li> <li> <code></code>\u00a0ZMQKernelInterface <ul> <li> <code></code>\u00a0ports </li> <li> <code></code>\u00a0sockets </li> </ul> </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0callers </li> <li> pending <ul> <li> <code></code>\u00a0PendingGroup <code></code>\u00a0caller </li> <li> <code></code>\u00a0PendingTracker <code></code>\u00a0id </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> caller <ul> <li> <code></code>\u00a0Caller <code></code>\u00a0stopped </li> <li> <code></code>\u00a0PendingGroup <code></code>\u00a0caller </li> </ul> </li> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0callers </li> <li> <code></code>\u00a0interrupts </li> <li> <code></code>\u00a0kernel </li> <li> <code></code>\u00a0wait_exit </li> </ul> </li> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0callers </li> <li> <code></code>\u00a0interrupts </li> <li> <code></code>\u00a0kernel </li> <li> <code></code>\u00a0wait_exit </li> </ul> </li> <li> <code></code>\u00a0ZMQKernelInterface <ul> <li> <code></code>\u00a0ports </li> <li> <code></code>\u00a0session </li> <li> <code></code>\u00a0sockets </li> </ul> </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0callers </li> <li> <code></code>\u00a0comm_manager </li> <li> <code></code>\u00a0debugger </li> <li> <code></code>\u00a0event_started </li> <li> <code></code>\u00a0event_stopped </li> <li> <code></code>\u00a0main_shell </li> <li> <code></code>\u00a0subshell_manager </li> </ul> </li> <li> pending <ul> <li> <code></code>\u00a0PendingGroup <code></code>\u00a0caller </li> <li> <code></code>\u00a0PendingTracker <code></code>\u00a0id </li> </ul> </li> </ul> </li> </ul> Source code in <code>src/async_kernel/common.py</code> <pre><code>class Fixed(Generic[S, T]):\n    \"\"\"\n    A thread-safe descriptor factory for creating and caching an object.\n\n    The ``Fixed`` descriptor provisions for each instance of the owner class\n    to dynamically load or import the managed class.  The managed instance\n    is created on first access and then cached for subsequent access.\n\n    Type Hints:\n        - ``S``: Type of the owner class.\n        - ``T``: Type of the managed class.\n\n    Example:\n        ```python\n        class MyClass:\n            a: Fixed[Self, dict] = Fixed(dict)\n            b: Fixed[Self, int] = Fixed(lambda c: id(c[\"owner\"].a))\n            c: Fixed[Any, list[str]] = Fixed(list, created=lambda c: c[\"obj\"].append(c[\"name\"]))\n        ```\n    \"\"\"\n\n    __slots__ = [\"create\", \"created\", \"instances\", \"lock\", \"name\"]\n\n    def __init__(\n        self,\n        obj: type[T] | Callable[[FixedCreate[S]], T] | str,\n        /,\n        *,\n        created: Callable[[FixedCreated[S, T]]] | None = None,\n    ) -&gt; None:\n        if isinstance(obj, str):\n            self.create = lambda _: import_item(obj)()\n        elif inspect.isclass(obj):\n            self.create = lambda _: obj()\n        elif callable(obj):\n            self.create = obj\n        else:\n            msg = f\"{obj=} is invalid! Use a lambda instead eg: lambda _: {obj}\"  # pyright: ignore[reportUnreachable]\n            raise TypeError(msg)\n        self.created = created\n        self.instances = {}\n        self.lock = Lock()\n\n    def __set_name__(self, owner_cls: type[S], name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, obj: S, objtype: type[S] | None = None) -&gt; T:\n        try:\n            return self.instances[id(obj)]\n        except KeyError:\n            if obj is None:\n                return self  # pyright: ignore[reportReturnType]\n            with self.lock:\n                try:\n                    return self.instances[id(obj)]\n                except KeyError:\n                    key = id(obj)\n                    instance: T = self.create({\"name\": self.name, \"owner\": obj})  # pyright: ignore[reportAssignmentType]\n                    self.instances[key] = instance\n                    weakref.finalize(obj, self.instances.pop, key)\n            if self.created:\n                try:\n                    self.created({\"owner\": obj, \"obj\": instance, \"name\": self.name})\n                except Exception:\n                    if log := getattr(obj, \"log\", None):\n                        msg = f\"Callback `created` failed for {obj.__class__}.{self.name}\"\n                        log.exception(msg, extra={\"obj\": self.created})\n            return instance\n\n    def __set__(self, obj: S, value: Self) -&gt; Never:\n        # Note: above we use `Self` for the `value` type hint to give a useful typing error\n        msg = f\"Setting `Fixed` parameter {obj.__class__.__name__}.{self.name} is forbidden!\"\n        raise AttributeError(msg)\n</code></pre>"},{"location":"reference/common/#async_kernel.common.LastUpdatedDict","title":"LastUpdatedDict","text":"<p>               Bases: <code>OrderedDict</code></p> <p>A dictionary that moves the key to the beginning or end when the value is set.</p> <p>Parameters:</p> <p>ref</p> Source code in <code>src/async_kernel/common.py</code> <pre><code>class LastUpdatedDict(OrderedDict):\n    \"\"\"\n    A dictionary that moves the key to the beginning or end when the value is set.\n\n    Args:\n        *args: As per [dict][].\n        last: Move the key to end if `True` or beginning if `False`.\n        **kwargs: As per [dict][].\n\n    [ref](https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes)\n    \"\"\"\n\n    _updating = False\n    _last = True\n\n    def __init__(self, *args: Mapping | Iterable, last: bool = True, **kwargs: Mapping) -&gt; None:\n        self._last = last\n        super().__init__(*args, **kwargs)\n\n    @override\n    def __setitem__(self, key, value) -&gt; None:\n        super().__setitem__(key, value)\n        if not self._updating:\n            self.move_to_end(key, self._last)\n\n    @override\n    def update(self, m, /, **kwargs) -&gt; None:  # pyright: ignore[reportIncompatibleMethodOverride]\n        self._updating = True\n        try:\n            super().update(m, **kwargs)\n        finally:\n            self._updating = False\n</code></pre>"},{"location":"reference/common/#async_kernel.common.LastUpdatedDict(*args)","title":"<code>*args</code>","text":"(<code>Mapping | Iterable</code>, default:                   <code>()</code> )           \u2013            <p>As per dict.</p>"},{"location":"reference/common/#async_kernel.common.LastUpdatedDict(last)","title":"<code>last</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Move the key to end if <code>True</code> or beginning if <code>False</code>.</p>"},{"location":"reference/common/#async_kernel.common.LastUpdatedDict(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Mapping</code>, default:                   <code>{}</code> )           \u2013            <p>As per dict.</p>"},{"location":"reference/common/#async_kernel.common.import_item","title":"import_item","text":"<pre><code>import_item(dottedname: str) -&gt; Any\n</code></pre> <p>Import an item from a module, given its dotted name.</p> Example <pre><code>import_item(\"os.path.join\")\n</code></pre> Source code in <code>src/async_kernel/common.py</code> <pre><code>def import_item(dottedname: str) -&gt; Any:\n    \"\"\"Import an item from a module, given its dotted name.\n\n    Example:\n        ```python\n        import_item(\"os.path.join\")\n        ```\n    \"\"\"\n    module, name0 = dottedname.rsplit(\".\", maxsplit=1)\n    return aiologic.meta.import_from(module, name0)\n</code></pre>"},{"location":"reference/debugger/","title":"debugger","text":"<p>Classes:</p> <ul> <li> <code>VariableExplorer</code>           \u2013            <p>A variable explorer.</p> </li> <li> <code>DebugpyClient</code>           \u2013            <p>A client for debugpy. Origin: IPyKernel.</p> </li> <li> <code>Debugger</code>           \u2013            <p>The debugger class. Origin: IPyKernel.</p> </li> </ul>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer","title":"VariableExplorer","text":"<p>               Bases: <code>HasTraits</code></p> <p>A variable explorer.</p> <p>Origin: IPyKernel</p> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Initialize the explorer.</p> </li> <li> <code>track</code>             \u2013              <p>Start tracking.</p> </li> <li> <code>untrack_all</code>             \u2013              <p>Stop tracking.</p> </li> <li> <code>get_children_variables</code>             \u2013              <p>Get the child variables for a variable reference.</p> </li> </ul> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>class VariableExplorer(HasTraits):\n    \"\"\"\n    A variable explorer.\n\n    Origin: [IPyKernel][ipykernel.debugger.VariableExplorer]\n    \"\"\"\n\n    kernel: Instance[Kernel] = Instance(\"async_kernel.kernel.Kernel\", ())\n\n    def __init__(self):\n        \"\"\"Initialize the explorer.\"\"\"\n        super().__init__()\n        # This import is apparently required to provide _pydevd_bundle imports\n        import debugpy.server.api  # noqa: F401, I001, PLC0415  # pyright: ignore[reportUnusedImport]\n        from _pydevd_bundle.pydevd_suspended_frames import SuspendedFramesManager, _FramesTracker  # type: ignore[attr-defined]  # noqa: PLC0415\n\n        self.suspended_frame_manager = SuspendedFramesManager()\n        self.py_db = _DummyPyDB()\n        self.tracker = _FramesTracker(self.suspended_frame_manager, self.py_db)\n        self.frame = None\n\n    def track(self):\n        \"\"\"Start tracking.\"\"\"\n        from _pydevd_bundle import pydevd_frame_utils  # type: ignore[attr-defined]  # noqa: PLC0415\n\n        shell = self.kernel.shell\n        var = shell.user_ns\n        self.frame = _FakeFrame(_FakeCode(\"&lt;module&gt;\", shell.compile.get_file_name(\"sys._getframe()\")), var, var)\n        self.tracker.track(\"thread1\", pydevd_frame_utils.create_frames_list_from_frame(self.frame))\n\n    def untrack_all(self):\n        \"\"\"Stop tracking.\"\"\"\n        self.tracker.untrack_all()\n\n    def get_children_variables(self, variable_ref=None):\n        \"\"\"Get the child variables for a variable reference.\"\"\"\n        var_ref = variable_ref\n        if not var_ref:\n            var_ref = id(self.frame)\n        try:\n            variables = self.suspended_frame_manager.get_variable(var_ref)\n        except KeyError:\n            return []\n        return [x.get_var_data() for x in variables.get_children_variables()]\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the explorer.\"\"\"\n    super().__init__()\n    # This import is apparently required to provide _pydevd_bundle imports\n    import debugpy.server.api  # noqa: F401, I001, PLC0415  # pyright: ignore[reportUnusedImport]\n    from _pydevd_bundle.pydevd_suspended_frames import SuspendedFramesManager, _FramesTracker  # type: ignore[attr-defined]  # noqa: PLC0415\n\n    self.suspended_frame_manager = SuspendedFramesManager()\n    self.py_db = _DummyPyDB()\n    self.tracker = _FramesTracker(self.suspended_frame_manager, self.py_db)\n    self.frame = None\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.track","title":"track","text":"<pre><code>track()\n</code></pre> <p>Start tracking.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def track(self):\n    \"\"\"Start tracking.\"\"\"\n    from _pydevd_bundle import pydevd_frame_utils  # type: ignore[attr-defined]  # noqa: PLC0415\n\n    shell = self.kernel.shell\n    var = shell.user_ns\n    self.frame = _FakeFrame(_FakeCode(\"&lt;module&gt;\", shell.compile.get_file_name(\"sys._getframe()\")), var, var)\n    self.tracker.track(\"thread1\", pydevd_frame_utils.create_frames_list_from_frame(self.frame))\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.untrack_all","title":"untrack_all","text":"<pre><code>untrack_all()\n</code></pre> <p>Stop tracking.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def untrack_all(self):\n    \"\"\"Stop tracking.\"\"\"\n    self.tracker.untrack_all()\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.get_children_variables","title":"get_children_variables","text":"<pre><code>get_children_variables(variable_ref=None)\n</code></pre> <p>Get the child variables for a variable reference.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def get_children_variables(self, variable_ref=None):\n    \"\"\"Get the child variables for a variable reference.\"\"\"\n    var_ref = variable_ref\n    if not var_ref:\n        var_ref = id(self.frame)\n    try:\n        variables = self.suspended_frame_manager.get_variable(var_ref)\n    except KeyError:\n        return []\n    return [x.get_var_data() for x in variables.get_children_variables()]\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient","title":"DebugpyClient","text":"<p>               Bases: <code>HasTraits</code></p> <p>A client for debugpy. Origin: IPyKernel.</p> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Initialize the client.</p> </li> <li> <code>put_tcp_frame</code>             \u2013              <p>Buffer the frame and process the buffer.</p> </li> <li> <code>connect_tcp_socket</code>             \u2013              <p>Connect to the tcp socket.</p> </li> </ul> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>class DebugpyClient(HasTraits):\n    \"\"\"A client for debugpy. Origin: [IPyKernel][ipykernel.debugger.DebugpyClient].\"\"\"\n\n    HEADER = b\"Content-Length: \"\n    SEPARATOR = b\"\\r\\n\\r\\n\"\n    SEPARATOR_LENGTH = 4\n    tcp_buffer = b\"\"\n    _result_responses: Dict[int, Pending] = Dict()\n    capabilities = Dict()\n    kernel: Instance[Kernel] = Instance(\"async_kernel.kernel.Kernel\", ())\n    _socketstream: anyio.abc.SocketStream | None = None\n    _send_lock = Instance(Lock, ())\n\n    def __init__(self, log, event_callback):\n        \"\"\"Initialize the client.\"\"\"\n        super().__init__()\n        self.log = log\n        self.event_callback = event_callback\n\n    @property\n    def connected(self):\n        return bool(self._socketstream)\n\n    async def send_request(self, request: dict) -&gt; Pending:\n        if not (socketstream := self._socketstream):\n            raise RuntimeError\n        async with self._send_lock:\n            self._result_responses[request[\"seq\"]] = pen = Pending()\n            content = orjson.dumps(request)\n            content_length = str(len(content)).encode()\n            buf = self.HEADER + content_length + self.SEPARATOR\n            buf += content\n            self.log.debug(\"DEBUGPYCLIENT: request %s\", buf)\n            await socketstream.send(buf)\n            return pen\n\n    def put_tcp_frame(self, frame: bytes):\n        \"\"\"Buffer the frame and process the buffer.\"\"\"\n        self.tcp_buffer += frame\n        data = self.tcp_buffer.split(self.HEADER)\n        if len(data) &gt; 1:\n            for buf in data[1:]:\n                size, raw_msg = buf.split(self.SEPARATOR, maxsplit=1)\n                size = int(size)\n                msg: DebugMessage = orjson.loads(raw_msg[:size])\n                self.log.debug(\"_put_message :%s %s\", msg[\"type\"], msg)\n                if msg[\"type\"] == \"event\":\n                    self.event_callback(msg)\n                elif result := self._result_responses.pop(msg[\"request_seq\"], None):\n                    result.set_result(msg)\n            self.tcp_buffer = b\"\"\n\n    async def connect_tcp_socket(self, ready: Event):\n        \"\"\"Connect to the tcp socket.\"\"\"\n        global _host_port  # noqa: PLW0603\n        if not _host_port:\n            import debugpy  # noqa: PLC0415\n\n            _host_port = debugpy.listen(0)\n        try:\n            self.log.debug(\"++ debugpy socketstream connecting ++\")\n            async with await anyio.connect_tcp(*_host_port) as socketstream:\n                self._socketstream = socketstream\n                self.log.debug(\"++ debugpy socketstream connected ++\")\n                ready.set()\n                while True:\n                    data = await socketstream.receive()\n                    self.put_tcp_frame(data)\n        except anyio.EndOfStream:\n            self.log.debug(\"++ debugpy socketstream disconnected ++\")\n            return\n        finally:\n            self._socketstream = None\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient.__init__","title":"__init__","text":"<pre><code>__init__(log, event_callback)\n</code></pre> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def __init__(self, log, event_callback):\n    \"\"\"Initialize the client.\"\"\"\n    super().__init__()\n    self.log = log\n    self.event_callback = event_callback\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient.put_tcp_frame","title":"put_tcp_frame","text":"<pre><code>put_tcp_frame(frame: bytes)\n</code></pre> <p>Buffer the frame and process the buffer.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def put_tcp_frame(self, frame: bytes):\n    \"\"\"Buffer the frame and process the buffer.\"\"\"\n    self.tcp_buffer += frame\n    data = self.tcp_buffer.split(self.HEADER)\n    if len(data) &gt; 1:\n        for buf in data[1:]:\n            size, raw_msg = buf.split(self.SEPARATOR, maxsplit=1)\n            size = int(size)\n            msg: DebugMessage = orjson.loads(raw_msg[:size])\n            self.log.debug(\"_put_message :%s %s\", msg[\"type\"], msg)\n            if msg[\"type\"] == \"event\":\n                self.event_callback(msg)\n            elif result := self._result_responses.pop(msg[\"request_seq\"], None):\n                result.set_result(msg)\n        self.tcp_buffer = b\"\"\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient.connect_tcp_socket","title":"connect_tcp_socket  <code>async</code>","text":"<pre><code>connect_tcp_socket(ready: Event)\n</code></pre> <p>Connect to the tcp socket.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def connect_tcp_socket(self, ready: Event):\n    \"\"\"Connect to the tcp socket.\"\"\"\n    global _host_port  # noqa: PLW0603\n    if not _host_port:\n        import debugpy  # noqa: PLC0415\n\n        _host_port = debugpy.listen(0)\n    try:\n        self.log.debug(\"++ debugpy socketstream connecting ++\")\n        async with await anyio.connect_tcp(*_host_port) as socketstream:\n            self._socketstream = socketstream\n            self.log.debug(\"++ debugpy socketstream connected ++\")\n            ready.set()\n            while True:\n                data = await socketstream.receive()\n                self.put_tcp_frame(data)\n    except anyio.EndOfStream:\n        self.log.debug(\"++ debugpy socketstream disconnected ++\")\n        return\n    finally:\n        self._socketstream = None\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger","title":"Debugger","text":"<p>               Bases: <code>HasTraits</code></p> <p>The debugger class. Origin: IPyKernel.</p> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0debugger </li> </ul> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Initialize the debugger.</p> </li> <li> <code>send_dap_request</code>             \u2013              <p>Sends a DAP request to the debug server, waits for and returns the corresponding response.</p> </li> <li> <code>next_seq</code>             \u2013              <p>A monotonically decreasing negative number so as not to clash with the frontend seq.</p> </li> <li> <code>process_request</code>             \u2013              <p>Process a request.</p> </li> <li> <code>do_initialize</code>             \u2013              <p>Initialize debugpy server starting as required.</p> </li> <li> <code>do_debug_info</code>             \u2013              <p>Handle a debug info message.</p> </li> <li> <code>do_inspect_variables</code>             \u2013              <p>Handle an inspect variables message.</p> </li> <li> <code>do_rich_inspect_variables</code>             \u2013              <p>Handle a rich inspect variables message.</p> </li> <li> <code>do_modules</code>             \u2013              <p>Handle a modules message.</p> </li> <li> <code>do_dump_cell</code>             \u2013              <p>Handle a dump cell message.</p> </li> <li> <code>do_set_breakpoints</code>             \u2013              <p>Handle a set breakpoints message.</p> </li> <li> <code>do_source</code>             \u2013              <p>Handle a source message.</p> </li> <li> <code>do_stack_trace</code>             \u2013              <p>Handle a stack trace message.</p> </li> <li> <code>do_variables</code>             \u2013              <p>Handle a variables message.</p> </li> <li> <code>do_attach</code>             \u2013              <p>Handle an attach message.</p> </li> <li> <code>do_configuration_done</code>             \u2013              <p>Handle a configuration done message.</p> </li> </ul> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>class Debugger(HasTraits):\n    \"\"\"The debugger class. Origin: [IPyKernel][ipykernel.debugger.DebugpyClient].\"\"\"\n\n    NO_DEBUG = {\"IPythonHistorySavingThread\"}\n    _seq = 0\n    breakpoint_list = Dict()\n    capabilities = Dict()\n    stopped_threads = Set()\n    _removed_cleanup = Dict()\n    just_my_code = Bool(True)\n    variable_explorer = Instance(VariableExplorer, ())\n    debugpy_client = Instance(DebugpyClient)\n    log = Instance(logging.LoggerAdapter)\n    kernel: Instance[Kernel] = Instance(\"async_kernel.kernel.Kernel\", ())\n    taskgroup: TaskGroup | None = None\n    init_event = Instance(Event, ())\n\n    @default(\"log\")\n    def _default_log(self):\n        return logging.LoggerAdapter(logging.getLogger(self.__class__.__name__))\n\n    def __init__(self):\n        \"\"\"Initialize the debugger.\"\"\"\n        super().__init__()\n        self.debugpy_client = DebugpyClient(log=self.log, event_callback=self._handle_event)\n        self.started_debug_handlers = {\n            \"setBreakpoints\": self.do_set_breakpoints,\n            \"stackTrace\": self.do_stack_trace,\n            \"variables\": self.do_variables,\n            \"attach\": self.do_attach,\n            \"configurationDone\": self.do_configuration_done,\n            \"copyToGlobals\": self.do_copy_to_globals,\n            \"disconnect\": self.do_disconnect,\n        }\n        self.static_debug_handlers = {\n            \"initialize\": self.do_initialize,\n            \"dumpCell\": self.do_dump_cell,\n            \"source\": self.do_source,\n            \"debugInfo\": self.do_debug_info,\n            \"inspectVariables\": self.do_inspect_variables,\n            \"richInspectVariables\": self.do_rich_inspect_variables,\n            \"modules\": self.do_modules,\n        }\n        self._forbidden_names = tuple(self.kernel.shell.user_ns_hidden)\n\n    async def send_dap_request(self, msg: DebugMessage, /):\n        \"\"\"Sends a DAP request to the debug server, waits for and returns the corresponding response.\"\"\"\n        return await (await self.debugpy_client.send_request(msg))\n\n    def next_seq(self):\n        \"A monotonically decreasing negative number so as not to clash with the frontend seq.\"\n        self._seq = self._seq - 1\n        return self._seq\n\n    def _handle_event(self, event):\n        if event[\"event\"] == \"stopped\":\n\n            async def _handle_stopped_event():\n                names = {t.name for t in threading.enumerate() if not getattr(t, \"pydev_do_not_trace\", False)}\n                msg = {\"seq\": self.next_seq(), \"type\": \"request\", \"command\": \"threads\"}\n                rep = await self.send_dap_request(msg)\n                for thread in rep[\"body\"][\"threads\"]:\n                    if thread[\"name\"] in names:\n                        self.stopped_threads.add(thread[\"id\"])\n                self._publish_event(event)\n\n            Caller().call_soon(_handle_stopped_event)\n            return\n\n        if event[\"event\"] == \"continued\":\n            self.stopped_threads.clear()\n        elif event[\"event\"] == \"initialized\":\n            self.init_event.set()\n        self._publish_event(event)\n\n    def _publish_event(self, event: dict):\n        self.kernel.iopub_send(\n            msg_or_type=\"debug_event\",\n            content=event,\n            ident=self.kernel.topic(\"debug_event\"),\n            parent=None,\n        )\n\n    def _build_variables_response(self, request, variables):\n        var_list = [var for var in variables if self._accept_variable(var[\"name\"])]\n        return {\n            \"seq\": request[\"seq\"],\n            \"type\": \"response\",\n            \"request_seq\": request[\"seq\"],\n            \"success\": True,\n            \"command\": request[\"command\"],\n            \"body\": {\"variables\": var_list},\n        }\n\n    def _accept_variable(self, variable_name):\n        \"\"\"Accept a variable by name.\"\"\"\n        return (\n            variable_name not in self._forbidden_names\n            and not bool(re.search(r\"^_\\d\", variable_name))\n            and not variable_name.startswith(\"_i\")\n        )\n\n    async def process_request(self, msg: DebugMessage, /):\n        \"\"\"Process a request.\"\"\"\n        command = msg[\"command\"]\n        if handler := self.static_debug_handlers.get(command):\n            return await handler(msg)\n        if not self.debugpy_client.connected:\n            msg_ = \"Debugy client not connected.\"\n            raise RuntimeError(msg_)\n        if handler := self.started_debug_handlers.get(command):\n            return await handler(msg)\n\n        return await self.send_dap_request(msg)\n\n    ## Static handlers\n\n    async def do_initialize(self, msg: DebugMessage, /):\n        \"Initialize debugpy server starting as required.\"\n        utils.mark_thread_pydev_do_not_trace()\n        for thread in threading.enumerate():\n            if thread.name in self.NO_DEBUG:\n                utils.mark_thread_pydev_do_not_trace(thread)\n        if not self.debugpy_client.connected:\n            ready = Event()\n            Caller().call_soon(self.debugpy_client.connect_tcp_socket, ready)\n            await ready\n            # Don't remove leading empty lines when debugging so the breakpoints are correctly positioned\n            cleanup_transforms = self.kernel.shell.input_transformer_manager.cleanup_transforms\n            if leading_empty_lines in cleanup_transforms:\n                index = cleanup_transforms.index(leading_empty_lines)\n                self._removed_cleanup[index] = cleanup_transforms.pop(index)\n        reply = await self.send_dap_request(msg)\n        if capabilities := reply.get(\"body\"):\n            self.capabilities = capabilities\n        return reply\n\n    async def do_debug_info(self, msg: DebugMessage, /):\n        \"\"\"Handle a debug info message.\"\"\"\n        breakpoint_list = []\n        for key, value in self.breakpoint_list.items():\n            breakpoint_list.append({\"source\": key, \"breakpoints\": value})\n        compiler = self.kernel.shell.compile\n        return {\n            \"type\": \"response\",\n            \"request_seq\": msg[\"seq\"],\n            \"success\": True,\n            \"command\": msg[\"command\"],\n            \"body\": {\n                \"isStarted\": self.debugpy_client.connected and not utils.LAUNCHED_BY_DEBUGPY,\n                \"hashMethod\": compiler.hash_method,\n                \"hashSeed\": compiler.hash_seed,\n                \"tmpFilePrefix\": compiler.tmp_file_prefix,\n                \"tmpFileSuffix\": compiler.tmp_file_suffix,\n                \"breakpoints\": breakpoint_list,\n                \"stoppedThreads\": sorted(self.stopped_threads),\n                \"richRendering\": True,\n                \"exceptionPaths\": [\"Python Exceptions\"],\n                \"copyToGlobals\": True,\n            },\n        }\n\n    async def do_inspect_variables(self, msg: DebugMessage, /):\n        \"\"\"Handle an inspect variables message.\"\"\"\n        self.variable_explorer.untrack_all()\n        # looks like the implementation of untrack_all in ptvsd\n        # destroys objects we need in track. We have no choice but\n        # reinstantiate the object\n        self.variable_explorer = VariableExplorer()\n        self.variable_explorer.track()\n        variables = self.variable_explorer.get_children_variables()\n        return self._build_variables_response(msg, variables)\n\n    async def do_rich_inspect_variables(self, msg: DebugMessage, /):\n        \"\"\"Handle a rich inspect variables message.\"\"\"\n        reply = {\n            \"type\": \"response\",\n            \"sequence_seq\": msg[\"seq\"],\n            \"success\": False,\n            \"command\": msg[\"command\"],\n        }\n        variable_name = msg[\"arguments\"].get(\"variableName\", \"\")\n        if not str.isidentifier(variable_name):\n            reply[\"body\"] = {\"data\": {}, \"metadata\": {}}\n            if variable_name in {\"special variables\", \"function variables\"}:\n                reply[\"success\"] = True\n            return reply\n        repr_data = {}\n        repr_metadata = {}\n        if not self.stopped_threads:\n            # The code did not hit a breakpoint, we use the interpreter\n            # to get the rich representation of the variable\n            result = self.kernel.shell.user_expressions({\"var\": variable_name})[\"var\"]\n            if result.get(\"status\", \"error\") == \"ok\":\n                repr_data = result.get(\"data\", {})\n                repr_metadata = result.get(\"metadata\", {})\n        else:\n            # The code has stopped on a breakpoint, we use the evaluate\n            # request to get the rich representation of the variable\n            code = f\"get_ipython().display_formatter.format({variable_name})\"\n            reply = await self.send_dap_request(\n                {\n                    \"type\": \"request\",\n                    \"command\": \"evaluate\",\n                    \"seq\": self.next_seq(),\n                    \"arguments\": {\"expression\": code, \"context\": \"clipboard\"} | msg[\"arguments\"],\n                }\n            )\n            if reply[\"success\"]:\n                repr_data, repr_metadata = eval(reply[\"body\"][\"result\"], {}, {})\n        body = {\n            \"data\": repr_data,\n            \"metadata\": {k: v for k, v in repr_metadata.items() if k in repr_data},\n        }\n        reply[\"body\"] = body\n        reply[\"success\"] = True\n        return reply\n\n    async def do_modules(self, msg: DebugMessage, /):\n        \"\"\"Handle a modules message.\"\"\"\n        modules = list(sys.modules.values())\n        startModule = msg.get(\"startModule\", 0)\n        moduleCount = msg.get(\"moduleCount\", len(modules))\n        mods = []\n        for i in range(startModule, moduleCount):\n            module = modules[i]\n            filename = getattr(getattr(module, \"__spec__\", None), \"origin\", None)\n            if filename and filename.endswith(\".py\"):\n                mods.append({\"id\": i, \"name\": module.__name__, \"path\": filename})\n        return {\"body\": {\"modules\": mods, \"totalModules\": len(modules)}}\n\n    async def do_dump_cell(self, msg: DebugMessage, /):\n        \"\"\"Handle a dump cell message.\"\"\"\n        code = msg[\"arguments\"][\"code\"]\n        path = self.kernel.shell.compile.get_file_name(code)\n        path.parent.mkdir(exist_ok=True)\n        with path.open(\"w\") as f:\n            f.write(code)\n        return {\n            \"type\": \"response\",\n            \"request_seq\": msg[\"seq\"],\n            \"success\": True,\n            \"command\": msg[\"command\"],\n            \"body\": {\"sourcePath\": str(path)},\n        }\n\n    # Started handlers (requires debug_client connection)\n\n    async def do_copy_to_globals(self, msg: DebugMessage, /):\n        dst_var_name = msg[\"arguments\"][\"dstVariableName\"]\n        src_var_name = msg[\"arguments\"][\"srcVariableName\"]\n        src_frame_id = msg[\"arguments\"][\"srcFrameId\"]\n        # Copy the variable to the user_ns\n        await self.send_dap_request(\n            {\n                \"type\": \"request\",\n                \"command\": \"evaluate\",\n                \"seq\": self.next_seq(),\n                \"arguments\": {\n                    \"expression\": f\"import async_kernel;async_kernel.kernel.Kernel().shell.user_ns['{dst_var_name}'] = {src_var_name}\",\n                    \"frameId\": src_frame_id,\n                    \"context\": \"repl\",\n                },\n            }\n        )\n        return await self.send_dap_request(\n            {\n                \"type\": \"request\",\n                \"command\": \"evaluate\",\n                \"seq\": msg[\"seq\"],\n                \"arguments\": {\n                    \"expression\": f\"globals()['{dst_var_name}'] = {src_var_name}\",\n                    \"frameId\": src_frame_id,\n                    \"context\": \"repl\",\n                },\n            }\n        )\n\n    async def do_set_breakpoints(self, msg: DebugMessage, /):\n        \"\"\"Handle a set breakpoints message.\"\"\"\n        source = msg[\"arguments\"][\"source\"][\"path\"]\n        self.breakpoint_list[source] = msg[\"arguments\"][\"breakpoints\"]\n        message_response = await self.send_dap_request(msg)\n        # debugpy can set breakpoints on different lines than the ones requested,\n        # so we want to record the breakpoints that were actually added\n        if message_response.get(\"success\"):\n            self.breakpoint_list[source] = [\n                {\"line\": breakpoint[\"line\"]} for breakpoint in message_response[\"body\"][\"breakpoints\"]\n            ]\n        return message_response\n\n    async def do_source(self, msg: DebugMessage, /):\n        \"\"\"Handle a source message.\"\"\"\n        reply = {\"type\": \"response\", \"request_seq\": msg[\"seq\"], \"command\": msg[\"command\"]}\n        if (path := Path(msg[\"arguments\"].get(\"source\", {}).get(\"path\", \"missing\"))).is_file():\n            with path.open(\"r\", encoding=\"utf-8\") as f:\n                reply[\"success\"] = True\n                reply[\"body\"] = {\"content\": f.read()}\n        else:\n            reply[\"success\"] = False\n            reply[\"message\"] = \"source unavailable\"\n            reply[\"body\"] = {}\n\n        return reply\n\n    async def do_stack_trace(self, msg: DebugMessage, /):\n        \"\"\"Handle a stack trace message.\"\"\"\n        reply = await self.send_dap_request(msg)\n        # The stackFrames array can have the following content:\n        # { frames from the notebook}\n        # ...\n        # { 'id': xxx, 'name': '&lt;module&gt;', ... } &lt;= this is the first frame of the code from the notebook\n        # { frames from async_kernel }\n        # ...\n        # {'id': yyy, 'name': '&lt;module&gt;', ... } &lt;= this is the first frame of async_kernel code\n        # or only the frames from the notebook.\n        # We want to remove all the frames from async_kernel when they are present.\n        try:\n            sf_list = reply[\"body\"][\"stackFrames\"]\n            module_idx = len(sf_list) - next(\n                i for i, v in enumerate(reversed(sf_list), 1) if v[\"name\"] == \"&lt;module&gt;\" and i != 1\n            )\n            reply[\"body\"][\"stackFrames\"] = reply[\"body\"][\"stackFrames\"][: module_idx + 1]\n        except StopIteration:\n            pass\n        return reply\n\n    async def do_variables(self, msg: DebugMessage, /):\n        \"\"\"Handle a variables message.\"\"\"\n        reply = {}\n        if not self.stopped_threads:\n            variables = self.variable_explorer.get_children_variables(msg[\"arguments\"][\"variablesReference\"])\n            return self._build_variables_response(msg, variables)\n        reply = await self.send_dap_request(msg)\n        if \"body\" in reply:\n            variables = [var for var in reply[\"body\"][\"variables\"] if self._accept_variable(var[\"name\"])]\n            reply[\"body\"][\"variables\"] = variables\n        return reply\n\n    async def do_attach(self, msg: DebugMessage, /):\n        \"\"\"Handle an attach message.\"\"\"\n        assert _host_port\n        msg[\"arguments\"][\"connect\"] = {\"host\": _host_port[0], \"port\": _host_port[1]}\n        if self.just_my_code:\n            msg[\"arguments\"][\"debugOptions\"] = [\"justMyCode\"]\n        reply = await self.debugpy_client.send_request(msg)\n        await self.init_event\n        await self.send_dap_request(\n            {\n                \"type\": \"request\",\n                \"seq\": self.next_seq(),\n                \"command\": \"configurationDone\",\n            }\n        )\n        return await reply\n\n    async def do_configuration_done(self, msg: DebugMessage, /):\n        \"\"\"Handle a configuration done message.\"\"\"\n        # This is only supposed to be called during initialize but can come at anytime. Ref: https://microsoft.github.io/debug-adapter-protocol/specification#Events_Initialized\n        # see : https://github.com/jupyterlab/jupyterlab/issues/17673\n        return {\n            \"seq\": msg[\"seq\"],\n            \"type\": \"response\",\n            \"request_seq\": msg[\"seq\"],\n            \"success\": True,\n            \"command\": msg[\"command\"],\n        }\n\n    async def do_disconnect(self, msg: DebugMessage, /):\n        response = await self.send_dap_request(msg)\n        # Restore the leading whitespace remove transform.\n        cleanup_transforms = self.kernel.shell.input_transformer_manager.cleanup_transforms\n        for index in sorted(self._removed_cleanup):\n            func = self._removed_cleanup.pop(index)\n            cleanup_transforms.insert(index, func)\n        self.init_event = Event()\n        self.breakpoint_list = {}\n        return response\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the debugger.\"\"\"\n    super().__init__()\n    self.debugpy_client = DebugpyClient(log=self.log, event_callback=self._handle_event)\n    self.started_debug_handlers = {\n        \"setBreakpoints\": self.do_set_breakpoints,\n        \"stackTrace\": self.do_stack_trace,\n        \"variables\": self.do_variables,\n        \"attach\": self.do_attach,\n        \"configurationDone\": self.do_configuration_done,\n        \"copyToGlobals\": self.do_copy_to_globals,\n        \"disconnect\": self.do_disconnect,\n    }\n    self.static_debug_handlers = {\n        \"initialize\": self.do_initialize,\n        \"dumpCell\": self.do_dump_cell,\n        \"source\": self.do_source,\n        \"debugInfo\": self.do_debug_info,\n        \"inspectVariables\": self.do_inspect_variables,\n        \"richInspectVariables\": self.do_rich_inspect_variables,\n        \"modules\": self.do_modules,\n    }\n    self._forbidden_names = tuple(self.kernel.shell.user_ns_hidden)\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.send_dap_request","title":"send_dap_request  <code>async</code>","text":"<pre><code>send_dap_request(msg: DebugMessage)\n</code></pre> <p>Sends a DAP request to the debug server, waits for and returns the corresponding response.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def send_dap_request(self, msg: DebugMessage, /):\n    \"\"\"Sends a DAP request to the debug server, waits for and returns the corresponding response.\"\"\"\n    return await (await self.debugpy_client.send_request(msg))\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.next_seq","title":"next_seq","text":"<pre><code>next_seq()\n</code></pre> <p>A monotonically decreasing negative number so as not to clash with the frontend seq.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def next_seq(self):\n    \"A monotonically decreasing negative number so as not to clash with the frontend seq.\"\n    self._seq = self._seq - 1\n    return self._seq\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.process_request","title":"process_request  <code>async</code>","text":"<pre><code>process_request(msg: DebugMessage)\n</code></pre> <p>Process a request.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def process_request(self, msg: DebugMessage, /):\n    \"\"\"Process a request.\"\"\"\n    command = msg[\"command\"]\n    if handler := self.static_debug_handlers.get(command):\n        return await handler(msg)\n    if not self.debugpy_client.connected:\n        msg_ = \"Debugy client not connected.\"\n        raise RuntimeError(msg_)\n    if handler := self.started_debug_handlers.get(command):\n        return await handler(msg)\n\n    return await self.send_dap_request(msg)\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_initialize","title":"do_initialize  <code>async</code>","text":"<pre><code>do_initialize(msg: DebugMessage)\n</code></pre> <p>Initialize debugpy server starting as required.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_initialize(self, msg: DebugMessage, /):\n    \"Initialize debugpy server starting as required.\"\n    utils.mark_thread_pydev_do_not_trace()\n    for thread in threading.enumerate():\n        if thread.name in self.NO_DEBUG:\n            utils.mark_thread_pydev_do_not_trace(thread)\n    if not self.debugpy_client.connected:\n        ready = Event()\n        Caller().call_soon(self.debugpy_client.connect_tcp_socket, ready)\n        await ready\n        # Don't remove leading empty lines when debugging so the breakpoints are correctly positioned\n        cleanup_transforms = self.kernel.shell.input_transformer_manager.cleanup_transforms\n        if leading_empty_lines in cleanup_transforms:\n            index = cleanup_transforms.index(leading_empty_lines)\n            self._removed_cleanup[index] = cleanup_transforms.pop(index)\n    reply = await self.send_dap_request(msg)\n    if capabilities := reply.get(\"body\"):\n        self.capabilities = capabilities\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_debug_info","title":"do_debug_info  <code>async</code>","text":"<pre><code>do_debug_info(msg: DebugMessage)\n</code></pre> <p>Handle a debug info message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_debug_info(self, msg: DebugMessage, /):\n    \"\"\"Handle a debug info message.\"\"\"\n    breakpoint_list = []\n    for key, value in self.breakpoint_list.items():\n        breakpoint_list.append({\"source\": key, \"breakpoints\": value})\n    compiler = self.kernel.shell.compile\n    return {\n        \"type\": \"response\",\n        \"request_seq\": msg[\"seq\"],\n        \"success\": True,\n        \"command\": msg[\"command\"],\n        \"body\": {\n            \"isStarted\": self.debugpy_client.connected and not utils.LAUNCHED_BY_DEBUGPY,\n            \"hashMethod\": compiler.hash_method,\n            \"hashSeed\": compiler.hash_seed,\n            \"tmpFilePrefix\": compiler.tmp_file_prefix,\n            \"tmpFileSuffix\": compiler.tmp_file_suffix,\n            \"breakpoints\": breakpoint_list,\n            \"stoppedThreads\": sorted(self.stopped_threads),\n            \"richRendering\": True,\n            \"exceptionPaths\": [\"Python Exceptions\"],\n            \"copyToGlobals\": True,\n        },\n    }\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_inspect_variables","title":"do_inspect_variables  <code>async</code>","text":"<pre><code>do_inspect_variables(msg: DebugMessage)\n</code></pre> <p>Handle an inspect variables message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_inspect_variables(self, msg: DebugMessage, /):\n    \"\"\"Handle an inspect variables message.\"\"\"\n    self.variable_explorer.untrack_all()\n    # looks like the implementation of untrack_all in ptvsd\n    # destroys objects we need in track. We have no choice but\n    # reinstantiate the object\n    self.variable_explorer = VariableExplorer()\n    self.variable_explorer.track()\n    variables = self.variable_explorer.get_children_variables()\n    return self._build_variables_response(msg, variables)\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_rich_inspect_variables","title":"do_rich_inspect_variables  <code>async</code>","text":"<pre><code>do_rich_inspect_variables(msg: DebugMessage)\n</code></pre> <p>Handle a rich inspect variables message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_rich_inspect_variables(self, msg: DebugMessage, /):\n    \"\"\"Handle a rich inspect variables message.\"\"\"\n    reply = {\n        \"type\": \"response\",\n        \"sequence_seq\": msg[\"seq\"],\n        \"success\": False,\n        \"command\": msg[\"command\"],\n    }\n    variable_name = msg[\"arguments\"].get(\"variableName\", \"\")\n    if not str.isidentifier(variable_name):\n        reply[\"body\"] = {\"data\": {}, \"metadata\": {}}\n        if variable_name in {\"special variables\", \"function variables\"}:\n            reply[\"success\"] = True\n        return reply\n    repr_data = {}\n    repr_metadata = {}\n    if not self.stopped_threads:\n        # The code did not hit a breakpoint, we use the interpreter\n        # to get the rich representation of the variable\n        result = self.kernel.shell.user_expressions({\"var\": variable_name})[\"var\"]\n        if result.get(\"status\", \"error\") == \"ok\":\n            repr_data = result.get(\"data\", {})\n            repr_metadata = result.get(\"metadata\", {})\n    else:\n        # The code has stopped on a breakpoint, we use the evaluate\n        # request to get the rich representation of the variable\n        code = f\"get_ipython().display_formatter.format({variable_name})\"\n        reply = await self.send_dap_request(\n            {\n                \"type\": \"request\",\n                \"command\": \"evaluate\",\n                \"seq\": self.next_seq(),\n                \"arguments\": {\"expression\": code, \"context\": \"clipboard\"} | msg[\"arguments\"],\n            }\n        )\n        if reply[\"success\"]:\n            repr_data, repr_metadata = eval(reply[\"body\"][\"result\"], {}, {})\n    body = {\n        \"data\": repr_data,\n        \"metadata\": {k: v for k, v in repr_metadata.items() if k in repr_data},\n    }\n    reply[\"body\"] = body\n    reply[\"success\"] = True\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_modules","title":"do_modules  <code>async</code>","text":"<pre><code>do_modules(msg: DebugMessage)\n</code></pre> <p>Handle a modules message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_modules(self, msg: DebugMessage, /):\n    \"\"\"Handle a modules message.\"\"\"\n    modules = list(sys.modules.values())\n    startModule = msg.get(\"startModule\", 0)\n    moduleCount = msg.get(\"moduleCount\", len(modules))\n    mods = []\n    for i in range(startModule, moduleCount):\n        module = modules[i]\n        filename = getattr(getattr(module, \"__spec__\", None), \"origin\", None)\n        if filename and filename.endswith(\".py\"):\n            mods.append({\"id\": i, \"name\": module.__name__, \"path\": filename})\n    return {\"body\": {\"modules\": mods, \"totalModules\": len(modules)}}\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_dump_cell","title":"do_dump_cell  <code>async</code>","text":"<pre><code>do_dump_cell(msg: DebugMessage)\n</code></pre> <p>Handle a dump cell message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_dump_cell(self, msg: DebugMessage, /):\n    \"\"\"Handle a dump cell message.\"\"\"\n    code = msg[\"arguments\"][\"code\"]\n    path = self.kernel.shell.compile.get_file_name(code)\n    path.parent.mkdir(exist_ok=True)\n    with path.open(\"w\") as f:\n        f.write(code)\n    return {\n        \"type\": \"response\",\n        \"request_seq\": msg[\"seq\"],\n        \"success\": True,\n        \"command\": msg[\"command\"],\n        \"body\": {\"sourcePath\": str(path)},\n    }\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_set_breakpoints","title":"do_set_breakpoints  <code>async</code>","text":"<pre><code>do_set_breakpoints(msg: DebugMessage)\n</code></pre> <p>Handle a set breakpoints message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_set_breakpoints(self, msg: DebugMessage, /):\n    \"\"\"Handle a set breakpoints message.\"\"\"\n    source = msg[\"arguments\"][\"source\"][\"path\"]\n    self.breakpoint_list[source] = msg[\"arguments\"][\"breakpoints\"]\n    message_response = await self.send_dap_request(msg)\n    # debugpy can set breakpoints on different lines than the ones requested,\n    # so we want to record the breakpoints that were actually added\n    if message_response.get(\"success\"):\n        self.breakpoint_list[source] = [\n            {\"line\": breakpoint[\"line\"]} for breakpoint in message_response[\"body\"][\"breakpoints\"]\n        ]\n    return message_response\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_source","title":"do_source  <code>async</code>","text":"<pre><code>do_source(msg: DebugMessage)\n</code></pre> <p>Handle a source message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_source(self, msg: DebugMessage, /):\n    \"\"\"Handle a source message.\"\"\"\n    reply = {\"type\": \"response\", \"request_seq\": msg[\"seq\"], \"command\": msg[\"command\"]}\n    if (path := Path(msg[\"arguments\"].get(\"source\", {}).get(\"path\", \"missing\"))).is_file():\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            reply[\"success\"] = True\n            reply[\"body\"] = {\"content\": f.read()}\n    else:\n        reply[\"success\"] = False\n        reply[\"message\"] = \"source unavailable\"\n        reply[\"body\"] = {}\n\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_stack_trace","title":"do_stack_trace  <code>async</code>","text":"<pre><code>do_stack_trace(msg: DebugMessage)\n</code></pre> <p>Handle a stack trace message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_stack_trace(self, msg: DebugMessage, /):\n    \"\"\"Handle a stack trace message.\"\"\"\n    reply = await self.send_dap_request(msg)\n    # The stackFrames array can have the following content:\n    # { frames from the notebook}\n    # ...\n    # { 'id': xxx, 'name': '&lt;module&gt;', ... } &lt;= this is the first frame of the code from the notebook\n    # { frames from async_kernel }\n    # ...\n    # {'id': yyy, 'name': '&lt;module&gt;', ... } &lt;= this is the first frame of async_kernel code\n    # or only the frames from the notebook.\n    # We want to remove all the frames from async_kernel when they are present.\n    try:\n        sf_list = reply[\"body\"][\"stackFrames\"]\n        module_idx = len(sf_list) - next(\n            i for i, v in enumerate(reversed(sf_list), 1) if v[\"name\"] == \"&lt;module&gt;\" and i != 1\n        )\n        reply[\"body\"][\"stackFrames\"] = reply[\"body\"][\"stackFrames\"][: module_idx + 1]\n    except StopIteration:\n        pass\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_variables","title":"do_variables  <code>async</code>","text":"<pre><code>do_variables(msg: DebugMessage)\n</code></pre> <p>Handle a variables message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_variables(self, msg: DebugMessage, /):\n    \"\"\"Handle a variables message.\"\"\"\n    reply = {}\n    if not self.stopped_threads:\n        variables = self.variable_explorer.get_children_variables(msg[\"arguments\"][\"variablesReference\"])\n        return self._build_variables_response(msg, variables)\n    reply = await self.send_dap_request(msg)\n    if \"body\" in reply:\n        variables = [var for var in reply[\"body\"][\"variables\"] if self._accept_variable(var[\"name\"])]\n        reply[\"body\"][\"variables\"] = variables\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_attach","title":"do_attach  <code>async</code>","text":"<pre><code>do_attach(msg: DebugMessage)\n</code></pre> <p>Handle an attach message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_attach(self, msg: DebugMessage, /):\n    \"\"\"Handle an attach message.\"\"\"\n    assert _host_port\n    msg[\"arguments\"][\"connect\"] = {\"host\": _host_port[0], \"port\": _host_port[1]}\n    if self.just_my_code:\n        msg[\"arguments\"][\"debugOptions\"] = [\"justMyCode\"]\n    reply = await self.debugpy_client.send_request(msg)\n    await self.init_event\n    await self.send_dap_request(\n        {\n            \"type\": \"request\",\n            \"seq\": self.next_seq(),\n            \"command\": \"configurationDone\",\n        }\n    )\n    return await reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_configuration_done","title":"do_configuration_done  <code>async</code>","text":"<pre><code>do_configuration_done(msg: DebugMessage)\n</code></pre> <p>Handle a configuration done message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_configuration_done(self, msg: DebugMessage, /):\n    \"\"\"Handle a configuration done message.\"\"\"\n    # This is only supposed to be called during initialize but can come at anytime. Ref: https://microsoft.github.io/debug-adapter-protocol/specification#Events_Initialized\n    # see : https://github.com/jupyterlab/jupyterlab/issues/17673\n    return {\n        \"seq\": msg[\"seq\"],\n        \"type\": \"response\",\n        \"request_seq\": msg[\"seq\"],\n        \"success\": True,\n        \"command\": msg[\"command\"],\n    }\n</code></pre>"},{"location":"reference/event_loop/","title":"event_loop","text":"Referenced by: <ul> <li> Reference typing <ul> <li> \u00a0RunSettings </li> <li> \u00a0typing </li> </ul> </li> </ul> <p>Classes:</p> <ul> <li> <code>Host</code>           \u2013            <p>A class that provides the necessary callbacks for <code>start_guest_run</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Run <code>func</code> to completion asynchronously in the current thread using a backend</p> </li> </ul>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.Host","title":"Host","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A class that provides the necessary callbacks for <code>start_guest_run</code>.</p> Referenced by: <ul> <li> Usage Command line and kernel configuration Loop options </li> <li> Reference event_loop <code></code>\u00a0run </li> </ul> Returned by: <ul> <li> Reference event_loop <code></code>\u00a0Host <code></code>\u00a0current </li> </ul> <p>Methods:</p> <ul> <li> <code>current</code>             \u2013              <p>The host running in the corresponding thread or current thread.</p> </li> <li> <code>run</code>             \u2013              <p>Run the loop in the current thread with a backend guest.</p> </li> <li> <code>mainloop</code>             \u2013              <p>Start the main event loop of the host.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>start_guest</code>               (<code>Callable[[], Any]</code>)           \u2013            <p>A callback to start the guest. This must be called by a subclass.</p> </li> </ul> Source code in <code>src/async_kernel/event_loop/run.py</code> <pre><code>class Host(Generic[T]):\n    \"\"\"\n    A class that provides the necessary callbacks for `start_guest_run`.\n    \"\"\"\n\n    LOOP: Loop\n    MATPLOTLIB_GUIS = ()\n    _subclasses: dict[Loop, type[Self]] = {}\n    _instances: dict[threading.Thread, Host] = {}\n\n    _outcome: Outcome[T] | None = None\n    start_guest: Callable[[], Any] = staticmethod(lambda: None)\n    \"A callback to start the guest. This must be called by a subclass.\"\n\n    def __init_subclass__(cls) -&gt; None:\n        if cls.LOOP is not Loop.custom:\n            cls._subclasses[cls.LOOP] = cls\n\n    @classmethod\n    def current(cls, thread: threading.Thread | None = None) -&gt; Host | None:\n        \"The host running in the corresponding thread or current thread.\"\n        thread = thread or threading.current_thread()\n        return cls._instances.get(thread)\n\n    @classmethod\n    def run(cls, func: Callable[..., CoroutineType[Any, Any, T]], args: tuple, settings: RunSettings, /) -&gt; T:\n        \"Run the loop in the current thread with a backend guest.\"\n\n        if (thread := threading.current_thread()) in cls._instances:\n            msg = \"A host is already running in this thread\"\n            raise RuntimeError(msg)\n\n        loop = Loop(settings.get(\"loop\"))\n        backend = Backend(settings.get(\"backend\", \"asyncio\"))\n        backend_options = settings.get(\"backend_options\") or {}\n        loop_options = settings.get(\"loop_options\") or {}\n\n        if \"host_class\" in loop_options:\n            loop_options = loop_options.copy()\n            cls_ = loop_options.pop(\"host_class\")\n            if isinstance(cls_, str):\n                cls_ = import_item(cls_)\n            if not issubclass(cls_, cls):\n                msg = f\"{cls_} is not a subclass of {cls}!\"\n                raise TypeError(msg)\n        else:\n            assert loop != backend\n            if loop not in cls._subclasses:\n                import_module(f\"async_kernel.event_loop.{loop}_host\")\n                assert loop in cls._subclasses, f\"Host for {loop=} is not implemented correctly!\"\n            cls_ = cls._subclasses[loop]\n        assert cls_.LOOP is loop\n\n        host = cls_(**loop_options)\n        # set the `start_guest` function (runs once).\n        backend_options.setdefault(\"host_uses_signal_set_wakeup_fd\", host.host_uses_signal_set_wakeup_fd)\n        start_guest_run = get_start_guest_run(backend)\n        host.start_guest = lambda: [\n            start_guest_run(\n                func,\n                *args,\n                run_sync_soon_threadsafe=host.run_sync_soon_threadsafe,\n                run_sync_soon_not_threadsafe=host.run_sync_soon_not_threadsafe,\n                done_callback=host.done_callback,\n                **backend_options,\n            ),\n            setattr(host, \"start_guest\", lambda: None),\n        ][1]\n        host._instances[thread] = host\n        try:\n            return host.mainloop()\n        finally:\n            host._instances.pop(threading.current_thread())\n\n    # Override the methods/attributes below as required.\n    host_uses_signal_set_wakeup_fd = False\n\n    def run_sync_soon_threadsafe(self, fn: Callable[[], Any]) -&gt; None: ...\n    def run_sync_soon_not_threadsafe(self, fn: Callable[[], Any]) -&gt; None: ...\n\n    def done_callback(self, outcome: Outcome) -&gt; None:\n        self._outcome = outcome\n\n    def mainloop(self) -&gt; T:\n        \"Start the main event loop of the host.\"\n        self.start_guest()  # Call at an appropriate time in the overriding subclass.\n        if not self._outcome:\n            msg = \"The mainloop should only exit once done_callback has been called!\"\n            raise RuntimeError(msg)\n        return self._outcome.unwrap()  # pragma: no cover\n</code></pre>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.Host.start_guest","title":"start_guest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_guest: Callable[[], Any] = staticmethod(lambda: None)\n</code></pre> <p>A callback to start the guest. This must be called by a subclass.</p>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.Host.current","title":"current  <code>classmethod</code>","text":"<pre><code>current(thread: Thread | None = None) -&gt; Host | None\n</code></pre> <p>The host running in the corresponding thread or current thread.</p> Source code in <code>src/async_kernel/event_loop/run.py</code> <pre><code>@classmethod\ndef current(cls, thread: threading.Thread | None = None) -&gt; Host | None:\n    \"The host running in the corresponding thread or current thread.\"\n    thread = thread or threading.current_thread()\n    return cls._instances.get(thread)\n</code></pre>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.Host.run","title":"run  <code>classmethod</code>","text":"<pre><code>run(\n    func: Callable[..., CoroutineType[Any, Any, T]], args: tuple, settings: RunSettings\n) -&gt; T\n</code></pre> <p>Run the loop in the current thread with a backend guest.</p> Source code in <code>src/async_kernel/event_loop/run.py</code> <pre><code>@classmethod\ndef run(cls, func: Callable[..., CoroutineType[Any, Any, T]], args: tuple, settings: RunSettings, /) -&gt; T:\n    \"Run the loop in the current thread with a backend guest.\"\n\n    if (thread := threading.current_thread()) in cls._instances:\n        msg = \"A host is already running in this thread\"\n        raise RuntimeError(msg)\n\n    loop = Loop(settings.get(\"loop\"))\n    backend = Backend(settings.get(\"backend\", \"asyncio\"))\n    backend_options = settings.get(\"backend_options\") or {}\n    loop_options = settings.get(\"loop_options\") or {}\n\n    if \"host_class\" in loop_options:\n        loop_options = loop_options.copy()\n        cls_ = loop_options.pop(\"host_class\")\n        if isinstance(cls_, str):\n            cls_ = import_item(cls_)\n        if not issubclass(cls_, cls):\n            msg = f\"{cls_} is not a subclass of {cls}!\"\n            raise TypeError(msg)\n    else:\n        assert loop != backend\n        if loop not in cls._subclasses:\n            import_module(f\"async_kernel.event_loop.{loop}_host\")\n            assert loop in cls._subclasses, f\"Host for {loop=} is not implemented correctly!\"\n        cls_ = cls._subclasses[loop]\n    assert cls_.LOOP is loop\n\n    host = cls_(**loop_options)\n    # set the `start_guest` function (runs once).\n    backend_options.setdefault(\"host_uses_signal_set_wakeup_fd\", host.host_uses_signal_set_wakeup_fd)\n    start_guest_run = get_start_guest_run(backend)\n    host.start_guest = lambda: [\n        start_guest_run(\n            func,\n            *args,\n            run_sync_soon_threadsafe=host.run_sync_soon_threadsafe,\n            run_sync_soon_not_threadsafe=host.run_sync_soon_not_threadsafe,\n            done_callback=host.done_callback,\n            **backend_options,\n        ),\n        setattr(host, \"start_guest\", lambda: None),\n    ][1]\n    host._instances[thread] = host\n    try:\n        return host.mainloop()\n    finally:\n        host._instances.pop(threading.current_thread())\n</code></pre>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.Host.mainloop","title":"mainloop","text":"<pre><code>mainloop() -&gt; T\n</code></pre> <p>Start the main event loop of the host.</p> Source code in <code>src/async_kernel/event_loop/run.py</code> <pre><code>def mainloop(self) -&gt; T:\n    \"Start the main event loop of the host.\"\n    self.start_guest()  # Call at an appropriate time in the overriding subclass.\n    if not self._outcome:\n        msg = \"The mainloop should only exit once done_callback has been called!\"\n        raise RuntimeError(msg)\n    return self._outcome.unwrap()  # pragma: no cover\n</code></pre>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.run","title":"run","text":"<pre><code>run(\n    func: Callable[..., CoroutineType[Any, Any, T]], args: tuple, settings: RunSettings\n) -&gt; T\n</code></pre> <p>Run <code>func</code> to completion asynchronously in the current thread using a backend with an optional gui event loop (host).</p> <p>The default backend is 'asyncio'.</p> <p>If loop is specified in <code>settings</code>. A host (gui) mainloop will be started with the <code>backend</code> running as a guest (in the same thread). The <code>backend</code> will execute <code>func</code> asynchronously to completion. Once completed the backend and host are stopped and finally the result is returned.</p> <p>Parameters:</p> Custom loop <p>A custom event loop can be used by subclassing Host. The host can be specified in the settings as the option 'host_class'. The value can be the class or a dotted path if it is importable.</p> Referenced by: <ul> <li> Reference typing <ul> <li> <code></code>\u00a0Loop </li> <li> <code></code>\u00a0typing </li> </ul> </li> </ul> Source code in <code>src/async_kernel/event_loop/run.py</code> <pre><code>def run(func: Callable[..., CoroutineType[Any, Any, T]], args: tuple, settings: RunSettings, /) -&gt; T:\n    \"\"\"\n    Run `func` to completion asynchronously in the current thread using a [backend][async_kernel.typing.Backend]\n    with an optional gui event loop (_host_).\n\n    The default backend is ['asyncio'][async_kernel.typing.Backend.asyncio].\n\n    If [loop][async_kernel.typing.Loop] is specified in `settings`. A _host_ (gui) mainloop\n    will be started with the `backend` running as a guest (in the same thread). The `backend`\n    will execute `func` asynchronously to completion. Once completed the backend and host\n    are stopped and finally the result is returned.\n\n    Args:\n        func: A coroutine function.\n        args: Args to use when calling func.\n        settings: Settings to use when running func.\n\n    Custom loop:\n        A custom event loop can be used by subclassing [Host][].\n        The host can be specified in the settings as the option 'host_class'. The value\n        can be the class or a dotted path if it is importable.\n    \"\"\"\n    if settings.get(\"loop\"):\n        # A loop with the backend running as a guest.\n        return Host.run(func, args, settings)\n    # backend only.\n    return anyio.run(\n        func,\n        *args,\n        backend=Backend(settings.get(\"backend\", \"asyncio\")),\n        backend_options=settings.get(\"backend_options\"),\n    )\n</code></pre>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.run(func)","title":"<code>func</code>","text":"(<code>Callable[..., CoroutineType[Any, Any, T]]</code>)           \u2013            <p>A coroutine function.</p>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.run(args)","title":"<code>args</code>","text":"(<code>tuple</code>)           \u2013            <p>Args to use when calling func.</p>"},{"location":"reference/event_loop/#async_kernel.event_loop.run.run(settings)","title":"<code>settings</code>","text":"(<code>RunSettings</code>)           \u2013            <p>Settings to use when running func.</p>"},{"location":"reference/interface/","title":"interface","text":"<p>Modules:</p> <ul> <li> <code>base</code>           \u2013            <p>The base class definition to interface with the kernel.</p> </li> <li> <code>callable</code>           \u2013            <p>A collection of objects to provide a kernel interface based on callbacks.</p> </li> <li> <code>zmq</code>           \u2013            <p>A collection of objects defining the kernel interface using zmq sockets.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>BaseKernelInterface</code>           \u2013            <p>The base class for interfacing with the kernel.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>start_kernel_callable_interface</code>             \u2013              <p>Start the kernel with the callback based kernel interface CallableKernelInterface.</p> </li> <li> <code>start_kernel_zmq_interface</code>             \u2013              <p>Start the kernel with the zmq socket based kernel interface ZMQKernelInterface.</p> </li> </ul> <p>The base class definition to interface with the kernel.</p> <p>Classes:</p> <ul> <li> <code>BaseKernelInterface</code>           \u2013            <p>The base class for interfacing with the kernel.</p> </li> </ul> <p>A collection of objects to provide a kernel interface based on callbacks.</p> <p>Classes:</p> <ul> <li> <code>Handlers</code>           \u2013            <p>Handlers returned by async_kernel.interface.callable.CallableKernelInterface when it is started.</p> </li> <li> <code>CallableKernelInterface</code>           \u2013            <p>A callback based interface to interact with the kernel using serialized messages.</p> </li> </ul> <p>A collection of objects defining the kernel interface using zmq sockets.</p> <p>Classes:</p> <ul> <li> <code>ZMQKernelInterface</code>           \u2013            <p>An interface for the kernel that uses zmq sockets.</p> </li> </ul>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface","title":"BaseKernelInterface","text":"<p>               Bases: <code>HasTraits</code>, <code>AsyncContextManagerMixin</code></p> <p>The base class for interfacing with the kernel.</p> <p>Must be overloaded to be useful.</p> Subclassed by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0CallableKernelInterface </li> <li> <code></code>\u00a0ZMQKernelInterface </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0interface </li> </ul> <p>Methods:</p> <ul> <li> <code>input_request</code>             \u2013              <p>Forward an input request to the frontend.</p> </li> <li> <code>raw_input</code>             \u2013              <p>Forward a raw_input request to the client.</p> </li> <li> <code>getpass</code>             \u2013              <p>Forward getpass to the client.</p> </li> <li> <code>interrupt</code>             \u2013              <p>Interrupt execution, possible raising a async_kernel.asyncshell.KernelInterruptError.</p> </li> <li> <code>msg</code>             \u2013              <p>Return the nested message dict.</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send an iopub message.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>log</code>           \u2013            <p>The logging adapter.</p> </li> <li> <code>callers</code>               (<code>Fixed[Self, dict[Literal[shell, control], Caller]]</code>)           \u2013            <p>The caller associated with the kernel once it has started.</p> </li> <li> <code>kernel</code>               (<code>Fixed[Self, Kernel]</code>)           \u2013            <p>The kernel.</p> </li> <li> <code>interrupts</code>               (<code>Fixed[Self, set[Callable[[], object]]]</code>)           \u2013            <p>A set for callbacks to register for calling when <code>interrupt</code> is called.</p> </li> <li> <code>last_interrupt_frame</code>           \u2013            <p>This frame is set when an interrupt is intercepted and cleared once the interrupt has been handled.</p> </li> <li> <code>wait_exit</code>           \u2013            <p>An event that when set will leave the kernel context if the kernel was started by this interface.</p> </li> <li> <code>backend</code>           \u2013            <p>The type of asynchronous backend used. Options are 'asyncio' or 'trio'.</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>class BaseKernelInterface(HasTraits, anyio.AsyncContextManagerMixin):\n    \"\"\"\n    The base class for interfacing with the kernel.\n\n    Must be overloaded to be useful.\n    \"\"\"\n\n    log = Instance(logging.LoggerAdapter)\n    \"The logging adapter.\"\n\n    callers: Fixed[Self, dict[Literal[Channel.shell, Channel.control], Caller]] = Fixed(dict)\n    \"The caller associated with the kernel once it has started.\"\n\n    kernel: Fixed[Self, Kernel] = Fixed(lambda _: async_kernel.Kernel())\n    \"The kernel.\"\n\n    interrupts: Fixed[Self, set[Callable[[], object]]] = Fixed(set)\n    \"A set for callbacks to register for calling when `interrupt` is called.\"\n\n    last_interrupt_frame = None\n    \"This frame is set when an interrupt is intercepted and cleared once the interrupt has been handled.\"\n\n    wait_exit = Fixed(Event)\n    \"An event that when set will leave the kernel context if the kernel was started by this interface.\"\n\n    backend = UseEnum(Backend)\n    \"The type of asynchronous backend used. Options are 'asyncio' or 'trio'.\"\n\n    def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n        raise NotImplementedError\n\n    @traitlets.default(\"log\")\n    def _default_log(self) -&gt; LoggerAdapter[Logger]:\n        return logging.LoggerAdapter(logging.getLogger(self.__class__.__name__))\n\n    def __init__(self, kernel_settings: dict[str, Any] | None = None, /) -&gt; None:\n        if self.kernel.trait_has_value(\"interface\"):\n            msg = \"The kernel already has an interface!\"\n            raise RuntimeError(msg)\n        super().__init__()\n        self.kernel.interface = self\n        if kernel_settings:\n            self.kernel.load_settings(kernel_settings)\n\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        self.backend = Backend(current_async_library())\n        restore_io = None\n        caller = Caller(\"manual\", name=\"Shell\", protected=True, log=self.kernel.log)\n        self.callers[Channel.shell] = caller\n        self.callers[Channel.control] = caller.get(name=\"Control\", log=self.kernel.log, protected=True)\n        async with caller:\n            try:\n                restore_io = self._patch_io()\n                yield self\n            finally:\n                if restore_io:\n                    restore_io()\n\n    def _patch_io(self) -&gt; Callable[[], None]:\n        original_io = sys.stdout, sys.stderr, sys.displayhook, builtins.input, self.getpass\n\n        def restore():\n            sys.stdout, sys.stderr, sys.displayhook, builtins.input, getpass.getpass = original_io\n\n        builtins.input = self.raw_input\n        getpass.getpass = self.getpass\n        for name in [\"stdout\", \"stderr\"]:\n\n            def flusher(string: str, name=name) -&gt; None:\n                \"Publish stdio or stderr when flush is called\"\n                self.iopub_send(\n                    msg_or_type=\"stream\",\n                    content={\"name\": name, \"text\": string},\n                    ident=f\"stream.{name}\".encode(),\n                )\n                if not self.kernel.quiet and (echo := (sys.__stdout__ if name == \"stdout\" else sys.__stderr__)):\n                    echo.write(string)  # pragma: no cover\n                    echo.flush()  # pragma: no cover\n\n            wrapper = OutStream(flusher=flusher)\n            setattr(sys, name, wrapper)\n\n        return restore\n\n    def input_request(self, prompt: str, *, password: bool = False) -&gt; str:\n        \"\"\"\n        Forward an input request to the frontend.\n\n        Args:\n            prompt: The user prompt.\n            password: If the prompt should be considered as a password.\n\n        Raises:\n           IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdi\n        \"\"\"\n        raise NotImplementedError\n\n    def raw_input(self, prompt: str = \"\") -&gt; str:\n        \"\"\"\n        Forward a raw_input request to the client.\n\n        Args:\n            prompt: The user prompt.\n\n        Raises:\n           IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n        \"\"\"\n        return self.input_request(str(prompt), password=False)\n\n    def getpass(self, prompt: str = \"\") -&gt; str:\n        \"\"\"\n        Forward getpass to the client.\n\n        Args:\n            prompt: The user prompt.\n\n        Raises:\n           IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n        \"\"\"\n        return self.input_request(prompt, password=True)\n\n    def interrupt(self) -&gt; None:\n        \"\"\"\n        Interrupt execution, possible raising a [async_kernel.asyncshell.KernelInterruptError][].\n        \"\"\"\n        while self.interrupts:\n            try:\n                self.interrupts.pop()()\n            except Exception:\n                pass\n\n    def msg(\n        self,\n        msg_type: str,\n        *,\n        content: dict | None = None,\n        parent: Message | dict[str, Any] | None = None,\n        header: MsgHeader | dict[str, Any] | None = None,\n        metadata: dict[str, Any] | None = None,\n        channel: Channel = Channel.shell,\n    ) -&gt; Message[dict[str, Any]]:\n        \"\"\"Return the nested message dict.\n\n        This format is different from what is sent over the wire. The\n        serialize/deserialize methods converts this nested message dict to the wire\n        format, which is a list of message parts.\n        \"\"\"\n        parent = parent or async_kernel.utils.get_parent()\n        if header is None:\n            session = \"\"\n            if parent and (header := parent.get(\"header\")):\n                session = header.get(\"session\", \"\")\n            header = MsgHeader(\n                date=datetime.now(UTC),\n                msg_id=str(uuid4()),\n                msg_type=msg_type,\n                session=session,\n                username=\"\",\n                version=async_kernel.kernel_protocol_version,\n            )\n        return Message(  # pyright: ignore[reportCallIssue]\n            channel=channel,\n            header=header,\n            parent_header=extract_header(parent),  # pyright: ignore[reportArgumentType]\n            content={} if content is None else content,\n            metadata=metadata if metadata is not None else {},\n        )\n\n    def iopub_send(\n        self,\n        msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n        *,\n        content: Content | None = None,\n        metadata: dict[str, Any] | None = None,\n        parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        ident: bytes | list[bytes] | None = None,\n        buffers: list[bytes] | None = None,\n    ) -&gt; None:\n        \"\"\"Send an iopub message.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log = Instance(LoggerAdapter)\n</code></pre> <p>The logging adapter.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.callers","title":"callers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>callers: Fixed[Self, dict[Literal[shell, control], Caller]] = Fixed(dict)\n</code></pre> <p>The caller associated with the kernel once it has started.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.kernel","title":"kernel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel: Fixed[Self, Kernel] = Fixed(lambda _: Kernel())\n</code></pre> <p>The kernel.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.interrupts","title":"interrupts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupts: Fixed[Self, set[Callable[[], object]]] = Fixed(set)\n</code></pre> <p>A set for callbacks to register for calling when <code>interrupt</code> is called.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.last_interrupt_frame","title":"last_interrupt_frame  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_interrupt_frame = None\n</code></pre> <p>This frame is set when an interrupt is intercepted and cleared once the interrupt has been handled.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.wait_exit","title":"wait_exit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wait_exit = Fixed(Event)\n</code></pre> <p>An event that when set will leave the kernel context if the kernel was started by this interface.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.backend","title":"backend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backend = UseEnum(Backend)\n</code></pre> <p>The type of asynchronous backend used. Options are 'asyncio' or 'trio'.</p> Referenced by: <ul> <li> Usage Command line and kernel configuration Backend </li> </ul>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.input_request","title":"input_request","text":"<pre><code>input_request(prompt: str, *, password: bool = False) -&gt; str\n</code></pre> <p>Forward an input request to the frontend.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdi</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def input_request(self, prompt: str, *, password: bool = False) -&gt; str:\n    \"\"\"\n    Forward an input request to the frontend.\n\n    Args:\n        prompt: The user prompt.\n        password: If the prompt should be considered as a password.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdi\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.input_request(prompt)","title":"<code>prompt</code>","text":"(<code>str</code>)           \u2013            <p>The user prompt.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.input_request(password)","title":"<code>password</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the prompt should be considered as a password.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.raw_input","title":"raw_input","text":"<pre><code>raw_input(prompt: str = '') -&gt; str\n</code></pre> <p>Forward a raw_input request to the client.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdin.</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def raw_input(self, prompt: str = \"\") -&gt; str:\n    \"\"\"\n    Forward a raw_input request to the client.\n\n    Args:\n        prompt: The user prompt.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n    \"\"\"\n    return self.input_request(str(prompt), password=False)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.raw_input(prompt)","title":"<code>prompt</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The user prompt.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.getpass","title":"getpass","text":"<pre><code>getpass(prompt: str = '') -&gt; str\n</code></pre> <p>Forward getpass to the client.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdin.</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def getpass(self, prompt: str = \"\") -&gt; str:\n    \"\"\"\n    Forward getpass to the client.\n\n    Args:\n        prompt: The user prompt.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n    \"\"\"\n    return self.input_request(prompt, password=True)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.getpass(prompt)","title":"<code>prompt</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The user prompt.</p>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.interrupt","title":"interrupt","text":"<pre><code>interrupt() -&gt; None\n</code></pre> <p>Interrupt execution, possible raising a async_kernel.asyncshell.KernelInterruptError.</p> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def interrupt(self) -&gt; None:\n    \"\"\"\n    Interrupt execution, possible raising a [async_kernel.asyncshell.KernelInterruptError][].\n    \"\"\"\n    while self.interrupts:\n        try:\n            self.interrupts.pop()()\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.msg","title":"msg","text":"<pre><code>msg(\n    msg_type: str,\n    *,\n    content: dict | None = None,\n    parent: Message | dict[str, Any] | None = None,\n    header: MsgHeader | dict[str, Any] | None = None,\n    metadata: dict[str, Any] | None = None,\n    channel: Channel = shell,\n) -&gt; Message[dict[str, Any]]\n</code></pre> <p>Return the nested message dict.</p> <p>This format is different from what is sent over the wire. The serialize/deserialize methods converts this nested message dict to the wire format, which is a list of message parts.</p> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def msg(\n    self,\n    msg_type: str,\n    *,\n    content: dict | None = None,\n    parent: Message | dict[str, Any] | None = None,\n    header: MsgHeader | dict[str, Any] | None = None,\n    metadata: dict[str, Any] | None = None,\n    channel: Channel = Channel.shell,\n) -&gt; Message[dict[str, Any]]:\n    \"\"\"Return the nested message dict.\n\n    This format is different from what is sent over the wire. The\n    serialize/deserialize methods converts this nested message dict to the wire\n    format, which is a list of message parts.\n    \"\"\"\n    parent = parent or async_kernel.utils.get_parent()\n    if header is None:\n        session = \"\"\n        if parent and (header := parent.get(\"header\")):\n            session = header.get(\"session\", \"\")\n        header = MsgHeader(\n            date=datetime.now(UTC),\n            msg_id=str(uuid4()),\n            msg_type=msg_type,\n            session=session,\n            username=\"\",\n            version=async_kernel.kernel_protocol_version,\n        )\n    return Message(  # pyright: ignore[reportCallIssue]\n        channel=channel,\n        header=header,\n        parent_header=extract_header(parent),  # pyright: ignore[reportArgumentType]\n        content={} if content is None else content,\n        metadata=metadata if metadata is not None else {},\n    )\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.BaseKernelInterface.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send an iopub message.</p> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def iopub_send(\n    self,\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"Send an iopub message.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.start_kernel_callable_interface","title":"start_kernel_callable_interface  <code>async</code>","text":"<pre><code>start_kernel_callable_interface(\n    *,\n    send: Callable[[str, list | None, bool], None | str],\n    stopped: Callable[[], None],\n    settings: dict | None = None,\n) -&gt; Handlers\n</code></pre> <p>Start the kernel with the callback based kernel interface CallableKernelInterface.</p> Source code in <code>src/async_kernel/interface/__init__.py</code> <pre><code>async def start_kernel_callable_interface(\n    *,\n    send: Callable[[str, list | None, bool], None | str],\n    stopped: Callable[[], None],\n    settings: dict | None = None,\n) -&gt; Handlers:\n    \"\"\"\n    Start the kernel with the callback based kernel interface [CallableKernelInterface][async_kernel.interface.callable.CallableKernelInterface].\n    \"\"\"\n    from async_kernel.interface.callable import CallableKernelInterface  # noqa: PLC0415\n\n    return await CallableKernelInterface(settings).start(send=send, stopped=stopped)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.start_kernel_zmq_interface","title":"start_kernel_zmq_interface","text":"<pre><code>start_kernel_zmq_interface(settings: dict | None = None) -&gt; None\n</code></pre> <p>Start the kernel with the zmq socket based kernel interface ZMQKernelInterface.</p> <p>Available in CPython.</p> Source code in <code>src/async_kernel/interface/__init__.py</code> <pre><code>def start_kernel_zmq_interface(settings: dict | None = None) -&gt; None:\n    \"\"\"\n    Start the kernel with the zmq socket based kernel interface [ZMQKernelInterface][async_kernel.interface.zmq.ZMQKernelInterface].\n\n    Available in CPython.\n    \"\"\"\n    from async_kernel.interface.zmq import ZMQKernelInterface  # noqa: PLC0415\n\n    ZMQKernelInterface(settings).start()\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface","title":"BaseKernelInterface","text":"<p>               Bases: <code>HasTraits</code>, <code>AsyncContextManagerMixin</code></p> <p>The base class for interfacing with the kernel.</p> <p>Must be overloaded to be useful.</p> Subclassed by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0CallableKernelInterface </li> <li> <code></code>\u00a0ZMQKernelInterface </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0interface </li> </ul> <p>Methods:</p> <ul> <li> <code>input_request</code>             \u2013              <p>Forward an input request to the frontend.</p> </li> <li> <code>raw_input</code>             \u2013              <p>Forward a raw_input request to the client.</p> </li> <li> <code>getpass</code>             \u2013              <p>Forward getpass to the client.</p> </li> <li> <code>interrupt</code>             \u2013              <p>Interrupt execution, possible raising a async_kernel.asyncshell.KernelInterruptError.</p> </li> <li> <code>msg</code>             \u2013              <p>Return the nested message dict.</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send an iopub message.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>log</code>           \u2013            <p>The logging adapter.</p> </li> <li> <code>callers</code>               (<code>Fixed[Self, dict[Literal[shell, control], Caller]]</code>)           \u2013            <p>The caller associated with the kernel once it has started.</p> </li> <li> <code>kernel</code>               (<code>Fixed[Self, Kernel]</code>)           \u2013            <p>The kernel.</p> </li> <li> <code>interrupts</code>               (<code>Fixed[Self, set[Callable[[], object]]]</code>)           \u2013            <p>A set for callbacks to register for calling when <code>interrupt</code> is called.</p> </li> <li> <code>last_interrupt_frame</code>           \u2013            <p>This frame is set when an interrupt is intercepted and cleared once the interrupt has been handled.</p> </li> <li> <code>wait_exit</code>           \u2013            <p>An event that when set will leave the kernel context if the kernel was started by this interface.</p> </li> <li> <code>backend</code>           \u2013            <p>The type of asynchronous backend used. Options are 'asyncio' or 'trio'.</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>class BaseKernelInterface(HasTraits, anyio.AsyncContextManagerMixin):\n    \"\"\"\n    The base class for interfacing with the kernel.\n\n    Must be overloaded to be useful.\n    \"\"\"\n\n    log = Instance(logging.LoggerAdapter)\n    \"The logging adapter.\"\n\n    callers: Fixed[Self, dict[Literal[Channel.shell, Channel.control], Caller]] = Fixed(dict)\n    \"The caller associated with the kernel once it has started.\"\n\n    kernel: Fixed[Self, Kernel] = Fixed(lambda _: async_kernel.Kernel())\n    \"The kernel.\"\n\n    interrupts: Fixed[Self, set[Callable[[], object]]] = Fixed(set)\n    \"A set for callbacks to register for calling when `interrupt` is called.\"\n\n    last_interrupt_frame = None\n    \"This frame is set when an interrupt is intercepted and cleared once the interrupt has been handled.\"\n\n    wait_exit = Fixed(Event)\n    \"An event that when set will leave the kernel context if the kernel was started by this interface.\"\n\n    backend = UseEnum(Backend)\n    \"The type of asynchronous backend used. Options are 'asyncio' or 'trio'.\"\n\n    def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n        raise NotImplementedError\n\n    @traitlets.default(\"log\")\n    def _default_log(self) -&gt; LoggerAdapter[Logger]:\n        return logging.LoggerAdapter(logging.getLogger(self.__class__.__name__))\n\n    def __init__(self, kernel_settings: dict[str, Any] | None = None, /) -&gt; None:\n        if self.kernel.trait_has_value(\"interface\"):\n            msg = \"The kernel already has an interface!\"\n            raise RuntimeError(msg)\n        super().__init__()\n        self.kernel.interface = self\n        if kernel_settings:\n            self.kernel.load_settings(kernel_settings)\n\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        self.backend = Backend(current_async_library())\n        restore_io = None\n        caller = Caller(\"manual\", name=\"Shell\", protected=True, log=self.kernel.log)\n        self.callers[Channel.shell] = caller\n        self.callers[Channel.control] = caller.get(name=\"Control\", log=self.kernel.log, protected=True)\n        async with caller:\n            try:\n                restore_io = self._patch_io()\n                yield self\n            finally:\n                if restore_io:\n                    restore_io()\n\n    def _patch_io(self) -&gt; Callable[[], None]:\n        original_io = sys.stdout, sys.stderr, sys.displayhook, builtins.input, self.getpass\n\n        def restore():\n            sys.stdout, sys.stderr, sys.displayhook, builtins.input, getpass.getpass = original_io\n\n        builtins.input = self.raw_input\n        getpass.getpass = self.getpass\n        for name in [\"stdout\", \"stderr\"]:\n\n            def flusher(string: str, name=name) -&gt; None:\n                \"Publish stdio or stderr when flush is called\"\n                self.iopub_send(\n                    msg_or_type=\"stream\",\n                    content={\"name\": name, \"text\": string},\n                    ident=f\"stream.{name}\".encode(),\n                )\n                if not self.kernel.quiet and (echo := (sys.__stdout__ if name == \"stdout\" else sys.__stderr__)):\n                    echo.write(string)  # pragma: no cover\n                    echo.flush()  # pragma: no cover\n\n            wrapper = OutStream(flusher=flusher)\n            setattr(sys, name, wrapper)\n\n        return restore\n\n    def input_request(self, prompt: str, *, password: bool = False) -&gt; str:\n        \"\"\"\n        Forward an input request to the frontend.\n\n        Args:\n            prompt: The user prompt.\n            password: If the prompt should be considered as a password.\n\n        Raises:\n           IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdi\n        \"\"\"\n        raise NotImplementedError\n\n    def raw_input(self, prompt: str = \"\") -&gt; str:\n        \"\"\"\n        Forward a raw_input request to the client.\n\n        Args:\n            prompt: The user prompt.\n\n        Raises:\n           IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n        \"\"\"\n        return self.input_request(str(prompt), password=False)\n\n    def getpass(self, prompt: str = \"\") -&gt; str:\n        \"\"\"\n        Forward getpass to the client.\n\n        Args:\n            prompt: The user prompt.\n\n        Raises:\n           IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n        \"\"\"\n        return self.input_request(prompt, password=True)\n\n    def interrupt(self) -&gt; None:\n        \"\"\"\n        Interrupt execution, possible raising a [async_kernel.asyncshell.KernelInterruptError][].\n        \"\"\"\n        while self.interrupts:\n            try:\n                self.interrupts.pop()()\n            except Exception:\n                pass\n\n    def msg(\n        self,\n        msg_type: str,\n        *,\n        content: dict | None = None,\n        parent: Message | dict[str, Any] | None = None,\n        header: MsgHeader | dict[str, Any] | None = None,\n        metadata: dict[str, Any] | None = None,\n        channel: Channel = Channel.shell,\n    ) -&gt; Message[dict[str, Any]]:\n        \"\"\"Return the nested message dict.\n\n        This format is different from what is sent over the wire. The\n        serialize/deserialize methods converts this nested message dict to the wire\n        format, which is a list of message parts.\n        \"\"\"\n        parent = parent or async_kernel.utils.get_parent()\n        if header is None:\n            session = \"\"\n            if parent and (header := parent.get(\"header\")):\n                session = header.get(\"session\", \"\")\n            header = MsgHeader(\n                date=datetime.now(UTC),\n                msg_id=str(uuid4()),\n                msg_type=msg_type,\n                session=session,\n                username=\"\",\n                version=async_kernel.kernel_protocol_version,\n            )\n        return Message(  # pyright: ignore[reportCallIssue]\n            channel=channel,\n            header=header,\n            parent_header=extract_header(parent),  # pyright: ignore[reportArgumentType]\n            content={} if content is None else content,\n            metadata=metadata if metadata is not None else {},\n        )\n\n    def iopub_send(\n        self,\n        msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n        *,\n        content: Content | None = None,\n        metadata: dict[str, Any] | None = None,\n        parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        ident: bytes | list[bytes] | None = None,\n        buffers: list[bytes] | None = None,\n    ) -&gt; None:\n        \"\"\"Send an iopub message.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log = Instance(LoggerAdapter)\n</code></pre> <p>The logging adapter.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.callers","title":"callers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>callers: Fixed[Self, dict[Literal[shell, control], Caller]] = Fixed(dict)\n</code></pre> <p>The caller associated with the kernel once it has started.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.kernel","title":"kernel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel: Fixed[Self, Kernel] = Fixed(lambda _: Kernel())\n</code></pre> <p>The kernel.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.interrupts","title":"interrupts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupts: Fixed[Self, set[Callable[[], object]]] = Fixed(set)\n</code></pre> <p>A set for callbacks to register for calling when <code>interrupt</code> is called.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.last_interrupt_frame","title":"last_interrupt_frame  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_interrupt_frame = None\n</code></pre> <p>This frame is set when an interrupt is intercepted and cleared once the interrupt has been handled.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.wait_exit","title":"wait_exit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wait_exit = Fixed(Event)\n</code></pre> <p>An event that when set will leave the kernel context if the kernel was started by this interface.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.backend","title":"backend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backend = UseEnum(Backend)\n</code></pre> <p>The type of asynchronous backend used. Options are 'asyncio' or 'trio'.</p> Referenced by: <ul> <li> Usage Command line and kernel configuration Backend </li> </ul>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.input_request","title":"input_request","text":"<pre><code>input_request(prompt: str, *, password: bool = False) -&gt; str\n</code></pre> <p>Forward an input request to the frontend.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdi</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def input_request(self, prompt: str, *, password: bool = False) -&gt; str:\n    \"\"\"\n    Forward an input request to the frontend.\n\n    Args:\n        prompt: The user prompt.\n        password: If the prompt should be considered as a password.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdi\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.input_request(prompt)","title":"<code>prompt</code>","text":"(<code>str</code>)           \u2013            <p>The user prompt.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.input_request(password)","title":"<code>password</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the prompt should be considered as a password.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.raw_input","title":"raw_input","text":"<pre><code>raw_input(prompt: str = '') -&gt; str\n</code></pre> <p>Forward a raw_input request to the client.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdin.</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def raw_input(self, prompt: str = \"\") -&gt; str:\n    \"\"\"\n    Forward a raw_input request to the client.\n\n    Args:\n        prompt: The user prompt.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n    \"\"\"\n    return self.input_request(str(prompt), password=False)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.raw_input(prompt)","title":"<code>prompt</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The user prompt.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.getpass","title":"getpass","text":"<pre><code>getpass(prompt: str = '') -&gt; str\n</code></pre> <p>Forward getpass to the client.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdin.</p> </li> </ul> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def getpass(self, prompt: str = \"\") -&gt; str:\n    \"\"\"\n    Forward getpass to the client.\n\n    Args:\n        prompt: The user prompt.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n    \"\"\"\n    return self.input_request(prompt, password=True)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.getpass(prompt)","title":"<code>prompt</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The user prompt.</p>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.interrupt","title":"interrupt","text":"<pre><code>interrupt() -&gt; None\n</code></pre> <p>Interrupt execution, possible raising a async_kernel.asyncshell.KernelInterruptError.</p> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def interrupt(self) -&gt; None:\n    \"\"\"\n    Interrupt execution, possible raising a [async_kernel.asyncshell.KernelInterruptError][].\n    \"\"\"\n    while self.interrupts:\n        try:\n            self.interrupts.pop()()\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.msg","title":"msg","text":"<pre><code>msg(\n    msg_type: str,\n    *,\n    content: dict | None = None,\n    parent: Message | dict[str, Any] | None = None,\n    header: MsgHeader | dict[str, Any] | None = None,\n    metadata: dict[str, Any] | None = None,\n    channel: Channel = shell,\n) -&gt; Message[dict[str, Any]]\n</code></pre> <p>Return the nested message dict.</p> <p>This format is different from what is sent over the wire. The serialize/deserialize methods converts this nested message dict to the wire format, which is a list of message parts.</p> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def msg(\n    self,\n    msg_type: str,\n    *,\n    content: dict | None = None,\n    parent: Message | dict[str, Any] | None = None,\n    header: MsgHeader | dict[str, Any] | None = None,\n    metadata: dict[str, Any] | None = None,\n    channel: Channel = Channel.shell,\n) -&gt; Message[dict[str, Any]]:\n    \"\"\"Return the nested message dict.\n\n    This format is different from what is sent over the wire. The\n    serialize/deserialize methods converts this nested message dict to the wire\n    format, which is a list of message parts.\n    \"\"\"\n    parent = parent or async_kernel.utils.get_parent()\n    if header is None:\n        session = \"\"\n        if parent and (header := parent.get(\"header\")):\n            session = header.get(\"session\", \"\")\n        header = MsgHeader(\n            date=datetime.now(UTC),\n            msg_id=str(uuid4()),\n            msg_type=msg_type,\n            session=session,\n            username=\"\",\n            version=async_kernel.kernel_protocol_version,\n        )\n    return Message(  # pyright: ignore[reportCallIssue]\n        channel=channel,\n        header=header,\n        parent_header=extract_header(parent),  # pyright: ignore[reportArgumentType]\n        content={} if content is None else content,\n        metadata=metadata if metadata is not None else {},\n    )\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.base.BaseKernelInterface.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send an iopub message.</p> Source code in <code>src/async_kernel/interface/base.py</code> <pre><code>def iopub_send(\n    self,\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"Send an iopub message.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.callable.Handlers","title":"Handlers","text":"<p>               Bases: <code>TypedDict</code></p> <p>Handlers returned by async_kernel.interface.callable.CallableKernelInterface when it is started.</p> Returned by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0CallableKernelInterface <code></code>\u00a0start </li> <li> <code></code>\u00a0start_kernel_callable_interface </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>handle_msg</code>               (<code>Callable[[str, list[bytes] | list[bytearray] | None]]</code>)           \u2013            <p>Handle messages from the client.</p> </li> <li> <code>stop</code>               (<code>Callable[[], None]</code>)           \u2013            <p>Stop the kernel.</p> </li> </ul> Source code in <code>src/async_kernel/interface/callable.py</code> <pre><code>class Handlers(TypedDict):\n    \"Handlers returned by [async_kernel.interface.callable.CallableKernelInterface][] when it is started.\"\n\n    handle_msg: Callable[[str, list[bytes] | list[bytearray] | None]]\n    \"\"\"\n    Handle messages from the client.\n\n    The handler requires two positional arguments\n\n    1. The message serialized as a JSON string. The channel (\"shell\" or \"control\" ) \n        should also be included in the Message under the key \"channel\". \n    2. A list of buffers if there are any, or None if there are no buffers.\n    \"\"\"\n\n    stop: Callable[[], None]\n    \"Stop the kernel.\"\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.callable.Handlers.handle_msg","title":"handle_msg  <code>instance-attribute</code>","text":"<pre><code>handle_msg: Callable[[str, list[bytes] | list[bytearray] | None]]\n</code></pre> <p>Handle messages from the client.</p> <p>The handler requires two positional arguments</p> <ol> <li>The message serialized as a JSON string. The channel (\"shell\" or \"control\" )      should also be included in the Message under the key \"channel\". </li> <li>A list of buffers if there are any, or None if there are no buffers.</li> </ol>"},{"location":"reference/interface/#async_kernel.interface.callable.Handlers.stop","title":"stop  <code>instance-attribute</code>","text":"<pre><code>stop: Callable[[], None]\n</code></pre> <p>Stop the kernel.</p>"},{"location":"reference/interface/#async_kernel.interface.callable.CallableKernelInterface","title":"CallableKernelInterface","text":"<p>               Bases: <code>BaseKernelInterface</code></p> <p>A callback based interface to interact with the kernel using serialized messages.</p> <p>Usage:</p> <pre><code>```python\nfrom async_kernel.interface.callable import CallableKernelInterface\n\n# Start the kernel providing the necessary callbacks.\nkernel_interface = await CallableKernelInterface(options).start(send=..., stopped=...)\n\n# Pass messages to the kernel.\nkernel_interface[\"handle_msg\"](msg, buffer)\n\n# Stop the kernel.\nkernel_interface[\"stop\"](msg, buffer)\n```\n</code></pre> <p>See also:     - [async_kernel.typing.CallableKernelInterfaceReturnArgs]</p> Referenced by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0Handlers </li> <li> <code></code>\u00a0start_kernel_callable_interface </li> <li> <code></code>\u00a0callable </li> <li> <code></code>\u00a0interface </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>pack</code>             \u2013              <p>Pack a message to a string.</p> </li> <li> <code>unpack</code>             \u2013              <p>Unpack a message from a json string.</p> </li> <li> <code>start</code>             \u2013              <p>Start the kernel.</p> </li> </ul> Source code in <code>src/async_kernel/interface/callable.py</code> <pre><code>class CallableKernelInterface(BaseKernelInterface):\n    \"\"\"\n    A callback based interface to interact with the kernel using serialized messages.\n\n    Usage:\n\n        ```python\n        from async_kernel.interface.callable import CallableKernelInterface\n\n        # Start the kernel providing the necessary callbacks.\n        kernel_interface = await CallableKernelInterface(options).start(send=..., stopped=...)\n\n        # Pass messages to the kernel.\n        kernel_interface[\"handle_msg\"](msg, buffer)\n\n        # Stop the kernel.\n        kernel_interface[\"stop\"](msg, buffer)\n        ```\n    See also:\n        - [async_kernel.typing.CallableKernelInterfaceReturnArgs]\n    \"\"\"\n\n    ORJSON_OPTION = orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_NAIVE_UTC | orjson.OPT_UTC_Z\n    _send: Callable[[str, list | None, bool], None | str]\n\n    def pack(self, msg: Message, /) -&gt; str:\n        \"\"\"\n        Pack a message to a string.\n        \"\"\"\n        return orjson.dumps(msg, default=repr, option=self.ORJSON_OPTION).decode()\n\n    def unpack(self, msg_string, /) -&gt; Message[dict[str, Any]]:\n        \"\"\"\n        Unpack a message from a json string.\n        \"\"\"\n        try:\n            return orjson.loads(msg_string)\n        except Exception:\n            return json.loads(msg_string)\n\n    async def start(\n        self,\n        *,\n        send: Callable[[str, list | None, bool], None | str],\n        stopped: Callable[[], None],\n    ) -&gt; Handlers:\n        \"\"\"\n        Start the kernel.\n\n        Args:\n            send: The function to send kernel messages to the client. It must accept\n\n                1. A json string of the message.\n                2. A list of buffers, or None if there are no buffers.\n                3. A boolean value that indicates a response is required for the stdio channel.\n\n            stopped: A callback that is called once the kernel has stopped.\n\n        Returns: A pending that when resolved returns the message handler callback.\n        \"\"\"\n        self._send = send\n        ready: Pending[Handlers] = async_kernel.Pending()\n        sig = signal.signal(signal.SIGINT, self._signal_handler)\n\n        async def run_kernel():\n            try:\n                async with self.kernel:\n                    ready.set_result(Handlers(handle_msg=self._handle_msg, stop=self.kernel.stop))\n                    await anyio.sleep_forever()\n            except Exception as e:\n                del self._send\n                if not ready.done():\n                    ready.set_exception(e)\n            finally:\n                signal.signal(signal.SIGINT, sig)\n                stopped()\n\n        self._task = asyncio.create_task(run_kernel())\n        return await ready\n\n    @enable_signal_safety\n    def _signal_handler(self, signum, frame: FrameType | None) -&gt; None:\n        self.last_interrupt_frame = frame\n        self.interrupt()\n        self.last_interrupt_frame = None\n        raise KernelInterruptError\n\n    def _send_to_frontend(\n        self,\n        msg: Message[dict],\n        *,\n        channel: Channel = Channel.shell,\n        buffers: list[bytearray | bytes] | None = None,\n        requires_reply=False,\n    ) -&gt; Message | None:\n        msg[\"channel\"] = channel\n        reply = self._send(self.pack(msg), buffers, requires_reply)\n        if requires_reply:\n            assert reply\n            return self.unpack(reply)\n        return None\n\n    async def _send_reply(self, job: Job, content: dict, /) -&gt; None:\n        if \"status\" not in content:\n            content[\"status\"] = \"ok\"\n        msg_type = job[\"msg\"][\"header\"][\"msg_type\"].replace(\"request\", \"reply\")\n        msg = self.msg(msg_type, content=content, parent=job[\"msg\"])\n        self._send_to_frontend(msg, channel=job[\"msg\"][\"channel\"], buffers=content.pop(\"buffers\", None))\n\n    def _handle_msg(self, msg_json: str, buffers: list[bytearray] | list[bytes] | None = None, /):\n        \"The main message handler that gets returned by the `start` method.\"\n        msg: Message[dict[str, Any]] = self.unpack(msg_json)\n        # Copy the buffer\n        msg[\"buffers\"] = [b[:] for b in buffers] if buffers else []\n        msg[\"channel\"] = Channel(msg[\"channel\"])\n        job = Job(received_time=time.monotonic(), msg=msg, ident=b\"\")\n        self.kernel.msg_handler(msg[\"channel\"], MsgType(job[\"msg\"][\"header\"][\"msg_type\"]), job, self._send_reply)  # pyright: ignore[reportArgumentType]\n\n    @override\n    def iopub_send(\n        self,\n        msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n        *,\n        content: Content | None = None,\n        metadata: dict[str, Any] | None = None,\n        parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        ident: bytes | list[bytes] | None = None,\n        buffers: list[bytes] | None = None,\n    ) -&gt; None:\n        if parent is NoValue:\n            parent = async_kernel.utils.get_parent()\n        if not isinstance(msg_or_type, dict):\n            msg_or_type = self.msg(msg_type=msg_or_type, content=content, parent=parent, metadata=metadata)  # pyright: ignore[reportArgumentType]\n        self._send_to_frontend(msg_or_type, channel=\"iopub\", buffers=buffers)  # pyright: ignore[reportArgumentType]\n\n    @override\n    def input_request(self, prompt: str, *, password=False) -&gt; Any:\n        job = async_kernel.utils.get_job()\n        if not job[\"msg\"].get(\"content\", {}).get(\"allow_stdin\", False):\n            msg = \"Stdin is not allowed in this context!\"\n            raise StdinNotImplementedError(msg)\n        msg = self.msg(\"input_request\", content={\"prompt\": prompt, \"password\": password})\n        reply = self._send_to_frontend(msg, channel=Channel.stdin, requires_reply=True)\n        assert reply\n        return reply[\"content\"][\"value\"]\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.callable.CallableKernelInterface.pack","title":"pack","text":"<pre><code>pack(msg: Message) -&gt; str\n</code></pre> <p>Pack a message to a string.</p> Source code in <code>src/async_kernel/interface/callable.py</code> <pre><code>def pack(self, msg: Message, /) -&gt; str:\n    \"\"\"\n    Pack a message to a string.\n    \"\"\"\n    return orjson.dumps(msg, default=repr, option=self.ORJSON_OPTION).decode()\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.callable.CallableKernelInterface.unpack","title":"unpack","text":"<pre><code>unpack(msg_string) -&gt; Message[dict[str, Any]]\n</code></pre> <p>Unpack a message from a json string.</p> Source code in <code>src/async_kernel/interface/callable.py</code> <pre><code>def unpack(self, msg_string, /) -&gt; Message[dict[str, Any]]:\n    \"\"\"\n    Unpack a message from a json string.\n    \"\"\"\n    try:\n        return orjson.loads(msg_string)\n    except Exception:\n        return json.loads(msg_string)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.callable.CallableKernelInterface.start","title":"start  <code>async</code>","text":"<pre><code>start(\n    *, send: Callable[[str, list | None, bool], None | str], stopped: Callable[[], None]\n) -&gt; Handlers\n</code></pre> <p>Start the kernel.</p> <p>Parameters:</p> <p>Returns: A pending that when resolved returns the message handler callback.</p> Source code in <code>src/async_kernel/interface/callable.py</code> <pre><code>async def start(\n    self,\n    *,\n    send: Callable[[str, list | None, bool], None | str],\n    stopped: Callable[[], None],\n) -&gt; Handlers:\n    \"\"\"\n    Start the kernel.\n\n    Args:\n        send: The function to send kernel messages to the client. It must accept\n\n            1. A json string of the message.\n            2. A list of buffers, or None if there are no buffers.\n            3. A boolean value that indicates a response is required for the stdio channel.\n\n        stopped: A callback that is called once the kernel has stopped.\n\n    Returns: A pending that when resolved returns the message handler callback.\n    \"\"\"\n    self._send = send\n    ready: Pending[Handlers] = async_kernel.Pending()\n    sig = signal.signal(signal.SIGINT, self._signal_handler)\n\n    async def run_kernel():\n        try:\n            async with self.kernel:\n                ready.set_result(Handlers(handle_msg=self._handle_msg, stop=self.kernel.stop))\n                await anyio.sleep_forever()\n        except Exception as e:\n            del self._send\n            if not ready.done():\n                ready.set_exception(e)\n        finally:\n            signal.signal(signal.SIGINT, sig)\n            stopped()\n\n    self._task = asyncio.create_task(run_kernel())\n    return await ready\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.callable.CallableKernelInterface.start(send)","title":"<code>send</code>","text":"(<code>Callable[[str, list | None, bool], None | str]</code>)           \u2013            <p>The function to send kernel messages to the client. It must accept</p> <ol> <li>A json string of the message.</li> <li>A list of buffers, or None if there are no buffers.</li> <li>A boolean value that indicates a response is required for the stdio channel.</li> </ol>"},{"location":"reference/interface/#async_kernel.interface.callable.CallableKernelInterface.start(stopped)","title":"<code>stopped</code>","text":"(<code>Callable[[], None]</code>)           \u2013            <p>A callback that is called once the kernel has stopped.</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface","title":"ZMQKernelInterface","text":"<p>               Bases: <code>BaseKernelInterface</code></p> <p>An interface for the kernel that uses zmq sockets.</p> Referenced by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0start_kernel_zmq_interface </li> <li> <code></code>\u00a0interface </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>start</code>             \u2013              <p>Start the kernel blocking until the kernel stops.</p> </li> <li> <code>load_connection_info</code>             \u2013              <p>Load connection info from a dict containing connection info.</p> </li> <li> <code>__asynccontextmanager__</code>             \u2013              <p>Create caller, and open socketes.</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send a message on the zmq iopub socket.</p> </li> <li> <code>receive_msg_loop</code>             \u2013              <p>Opens a zmq socket for the channel, receives messages and calls the message handler.</p> </li> <li> <code>interrupt</code>             \u2013              <p>Perform a keyboard interrupt.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>sockets</code>               (<code>Fixed[Self, dict[Channel, Socket]]</code>)           \u2013            </li> <li> <code>ports</code>               (<code>Fixed[Self, dict[Channel, int]]</code>)           \u2013            </li> <li> <code>ip</code>           \u2013            <p>The kernel's IP address [default localhost].</p> </li> <li> <code>session</code>           \u2013            <p>Handles serialization and sending of messages.</p> </li> <li> <code>transport</code>               (<code>CaselessStrEnum[str]</code>)           \u2013            <p>Transport for sockets.</p> </li> <li> <code>loop</code>               (<code>TraitType[Loop | None, Loop | None]</code>)           \u2013            <p>The name of the (gui) event loop if one is used.</p> </li> <li> <code>loop_options</code>           \u2013            <p>Options for starting the loop.</p> </li> <li> <code>backend_options</code>           \u2013            <p>Options for starting the backend.</p> </li> </ul> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>class ZMQKernelInterface(BaseKernelInterface):\n    \"An interface for the kernel that uses zmq sockets.\"\n\n    _zmq_context = Fixed(zmq.Context)\n    _interrupt_requested: bool | Literal[\"FORCE\"] = False\n    _iopub_url = \"inproc://iopub-capture\"\n\n    sockets: Fixed[Self, dict[Channel, zmq.Socket]] = Fixed(dict)\n    \"\"\n    ports: Fixed[Self, dict[Channel, int]] = Fixed(dict)\n    \"\"\n    ip = Unicode()\n    \"\"\"\n    The kernel's IP address [default localhost].\n\n    If the IP address is something other than localhost, then Consoles on other machines \n    will be able to connect to the Kernel, so be careful!\n    \"\"\"\n    session = Fixed(Session)\n    \"Handles serialization and sending of messages.\"\n\n    transport: CaselessStrEnum[str] = CaselessStrEnum(\n        [\"tcp\", \"ipc\"] if sys.platform == \"linux\" else [\"tcp\"], default_value=\"tcp\"\n    )\n    \"Transport for sockets.\"\n\n    loop: TraitType[Loop | None, Loop | None] = UseEnum(Loop, default_value=None, allow_none=True)\n    \"The name of the (gui) event loop if one is used.\"\n\n    loop_options = Dict(allow_none=True)\n    \"Options for starting the loop.\"\n\n    backend_options = Dict(allow_none=True)\n    \"Options for starting the backend.\"\n\n    @default(\"backend\")\n    def _default_backend(self) -&gt; Backend:\n        try:\n            return Backend(current_async_library())\n        except AsyncLibraryNotFoundError:\n            if (\n                not self.loop\n                and not self.trait_has_value(\"backend_options\")\n                and (importlib.util.find_spec(\"winloop\") or importlib.util.find_spec(\"uvloop\"))\n            ):\n                self.backend_options[\"use_uvloop\"] = True\n            return Backend.asyncio\n\n    def start(self):\n        \"\"\"\n        Start the kernel blocking until the kernel stops.\n\n        Warning:\n            - Running the kernel in a thread other than the 'MainThread' is permitted, but discouraged.\n            - Blocking calls can only be interrupted in the 'MainThread' because [*'threads cannot be destroyed, stopped, suspended, resumed, or interrupted'*](https://docs.python.org/3/library/threading.html#module-threading).\n            - Some libraries may assume the call is occurring in the 'MainThread'.\n            - If there is an `asyncio` or `trio` event loop already running in the 'MainThread`;\n                start the kernel asynchronously instead (`async with kernel: ...`).\n        \"\"\"\n\n        async def run_kernel() -&gt; None:\n            async with self.kernel:\n                await self.wait_exit\n\n        settings = RunSettings(\n            backend=self.backend,\n            loop=self.loop,\n            backend_options=self.backend_options,\n            loop_options=self.loop_options,\n        )\n        async_kernel.event_loop.run(run_kernel, (), settings)\n\n    @override\n    def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Load connection info from a dict containing connection info.\n\n        Typically this data comes from a connection file\n        and is called by load_connection_file.\n\n        Args:\n            info: Dictionary containing connection_info. See the connection_file spec for details.\n        \"\"\"\n        if self.ports:\n            msg = \"Connection info is already loaded!\"\n            raise RuntimeError(msg)\n        self.transport = info.get(\"transport\", self.transport)\n        self.ip = info.get(\"ip\") or self.ip\n        for channel in Channel:\n            name = f\"{channel}_port\"\n            if channel not in self.ports and name in info:\n                self.ports[channel] = info[name]\n        if \"key\" in info:\n            key = info[\"key\"]\n            if isinstance(key, str):\n                key = key.encode()\n            assert isinstance(key, bytes)\n\n            self.session.key = key\n        if \"signature_scheme\" in info:\n            self.session.signature_scheme = info[\"signature_scheme\"]\n\n    @traitlets.validate(\"ip\")\n    def _validate_ip(self, proposal) -&gt; str:\n        return \"0.0.0.0\" if (val := proposal[\"value\"]) == \"*\" else val\n\n    @traitlets.default(\"ip\")\n    def _default_ip(self) -&gt; str:\n        return str(self.kernel.connection_file) + \"-ipc\" if self.transport == \"ipc\" else localhost()\n\n    @override\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        \"\"\"Create caller, and open socketes.\"\"\"\n        self.backend = Backend(current_async_library())\n        sig = restore_io = None\n        caller = Caller(\n            \"manual\",\n            name=\"Shell\",\n            protected=True,\n            log=self.kernel.log,\n            zmq_context=self._zmq_context,\n            loop=self.loop,\n        )\n        self.callers[Channel.shell] = caller\n        self.callers[Channel.control] = caller.get(name=\"Control\", log=self.kernel.log, protected=True)\n        start = Event()\n        try:\n            async with caller:\n                self._start_hb_iopub_shell_control_threads(start)\n                with self._bind_socket(Channel.stdin):\n                    assert len(self.sockets) == len(Channel)\n                    self._write_connection_file()\n                    restore_io = self._patch_io()\n                    with contextlib.suppress(ValueError):\n                        sig = signal.signal(signal.SIGINT, self._signal_handler)\n                    start.set()\n                    yield self\n        finally:\n            start.set()\n            if sig:\n                signal.signal(signal.SIGINT, sig)\n            if restore_io:\n                restore_io()\n            self._zmq_context.term()\n\n    def _start_hb_iopub_shell_control_threads(self, start: Event) -&gt; None:\n        def heartbeat(ready: Event) -&gt; None:\n            # ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#heartbeat-for-kernels\n            async_kernel.utils.mark_thread_pydev_do_not_trace()\n            with self._bind_socket(Channel.heartbeat) as socket:\n                ready.set()\n                try:\n                    zmq.proxy(socket, socket)\n                except zmq.ContextTerminated:\n                    return\n\n        def pub_proxy(ready: Event) -&gt; None:\n            utils.mark_thread_pydev_do_not_trace()\n\n            # We use an internal proxy to collect pub messages for distribution.\n            # Each thread needs to open its own socket to publish to the internal proxy.\n            # Ref: https://zguide.zeromq.org/docs/chapter2/#Working-with-Messages (fig 14)\n\n            frontend: zmq.Socket = self._zmq_context.socket(zmq.XSUB)\n            frontend.bind(Caller.iopub_url)\n\n            # Capture broadcasts messages received on both frontend and backend\n            capture = self._zmq_context.socket(zmq.PUB)\n            capture.bind(self._iopub_url)\n            threading.Thread(target=self._pub_capture).start()\n\n            with self._bind_socket(Channel.iopub) as iopub_socket:\n                ready.set()\n                try:\n                    zmq.proxy(frontend, iopub_socket, capture)\n                except (zmq.ContextTerminated, Exception):\n                    pass\n            frontend.close(linger=50)\n            capture.close(linger=50)\n\n        hb_ready, iopub_ready = (Event(), Event())\n        threading.Thread(target=heartbeat, name=\"heartbeat\", args=[hb_ready]).start()\n        hb_ready.wait()\n        threading.Thread(target=pub_proxy, name=\"iopub proxy\", args=[iopub_ready]).start()\n        iopub_ready.wait()\n        # message loops\n        for channel in [Channel.shell, Channel.control]:\n            ready = Event()\n            name = f\"{channel}-receive_msg_loop\"\n            threading.Thread(target=self.receive_msg_loop, name=name, args=(channel, ready, start)).start()\n            ready.wait()\n\n    def _pub_capture(self):\n        \"\"\"\n        Capture connection messages on iopub.\n\n        Will send an 'iopub_welcome' whenever a socket subscribes to the iopub socket [ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#welcome-message).\n        \"\"\"\n\n        utils.mark_thread_pydev_do_not_trace()\n\n        socket: zmq.Socket = self._zmq_context.socket(zmq.SUB)\n        socket.linger = 0\n        socket.connect(self._iopub_url)\n        # welcome_message:  https://jupyter.org/enhancement-proposals/65-jupyter-xpub/jupyter-xpub.html#replace-pub-socket-with-xpub-socket\n        # Only subscribe to the 'pub subscribe' topic byte `1` (byte `0` is 'pub unsubscribe').\n        socket.subscribe(b\"\\x01\")\n        with socket:\n            while True:\n                try:\n                    if frames := socket.recv_multipart():\n                        frame = next(iter(frames))\n                        if frame[0] == 1:\n                            msg = self.msg(\"iopub_welcome\", content={\"subscription\": frame[1:].decode()})\n                            self.iopub_send(msg, parent=None)\n                except zmq.ContextTerminated:\n                    break\n                except Exception:\n                    continue\n\n    @contextlib.contextmanager\n    def _bind_socket(self, channel: Channel) -&gt; Generator[Any | Socket[Any], Any, None]:\n        \"\"\"\n        Bind a zmq.Socket storing a reference to the socket and the port\n        details and closing the socket on leaving the context.\n        \"\"\"\n        match channel:\n            case Channel.shell | Channel.control | Channel.heartbeat | Channel.stdin:\n                socket_type = zmq.ROUTER\n            case Channel.iopub:\n                socket_type = zmq.XPUB\n        socket: zmq.Socket = self._zmq_context.socket(socket_type)\n        socket.linger = 50\n        port = bind_socket(socket=socket, transport=self.transport, ip=self.ip, port=self.ports.get(channel, 0))  # pyright: ignore[reportArgumentType]\n        self.ports[channel] = port\n        self.log.debug(\"%s socket on port: %i\", channel, port)\n        self.sockets[channel] = socket\n        try:\n            yield socket\n        finally:\n            socket.close(linger=50)\n            self.sockets.pop(channel)\n\n    def _write_connection_file(\n        self,\n    ) -&gt; None:\n        \"\"\"\n        Write connection info to JSON dict in kernel.connection_file.\n        \"\"\"\n        if not (path := self.kernel.connection_file).exists():\n            path.parent.mkdir(parents=True, exist_ok=True)\n            write_connection_file(\n                str(path),\n                transport=self.transport,\n                ip=self.ip,\n                key=self.session.key,\n                signature_scheme=self.session.signature_scheme,\n                kernel_name=self.kernel.kernel_name,\n                **{f\"{channel}_port\": self.ports[channel] for channel in Channel},\n            )\n            ip_files: list[pathlib.Path] = []\n            if self.transport == \"ipc\":\n                for s in self.sockets.values():\n                    f = pathlib.Path(s.get_string(zmq.LAST_ENDPOINT).removeprefix(\"ipc://\"))\n                    assert f.exists()\n                    ip_files.append(f)\n\n            def cleanup_file_files() -&gt; None:\n                path.unlink(missing_ok=True)\n                for f in ip_files:\n                    f.unlink(missing_ok=True)\n\n            atexit.register(cleanup_file_files)\n\n    @override\n    def input_request(self, prompt: str, *, password=False) -&gt; Any:\n        job = async_kernel.utils.get_job()\n        if not job[\"msg\"].get(\"content\", {}).get(\"allow_stdin\", False):\n            msg = \"Stdin is not allowed in this context!\"\n            raise StdinNotImplementedError(msg)\n        socket = self.sockets[Channel.stdin]\n        # Clear messages on the stdin socket\n        while socket.get(SocketOption.EVENTS) &amp; PollEvent.POLLIN:  # pyright: ignore[reportOperatorIssue]\n            socket.recv_multipart(flags=Flag.DONTWAIT, copy=False)\n        # Send the input request.\n        assert self is not None\n        self.session.send(\n            stream=socket,\n            msg_or_type=\"input_request\",\n            content={\"prompt\": prompt, \"password\": password},\n            parent=job[\"msg\"],  # pyright: ignore[reportArgumentType]\n            ident=job[\"ident\"],\n        )\n        # Poll for a reply.\n        while not (socket.poll(100) &amp; PollEvent.POLLIN):\n            if self.last_interrupt_frame:\n                raise KernelInterruptError\n        return self.session.recv(socket)[1][\"content\"][\"value\"]  # pyright: ignore[reportOptionalSubscript]\n\n    @override\n    def iopub_send(\n        self,\n        msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n        *,\n        content: Content | None = None,\n        metadata: dict[str, Any] | None = None,\n        parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        ident: bytes | list[bytes] | None = None,\n        buffers: list[bytes] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Send a message on the zmq iopub socket.\n        \"\"\"\n        if socket := Caller.iopub_sockets.get(t_ident := Caller.id_current()):\n            msg = self.session.send(\n                stream=socket,\n                msg_or_type=msg_or_type,  # pyright: ignore[reportArgumentType]\n                content=content,\n                metadata=metadata,\n                parent=parent if parent is not NoValue else utils.get_parent(),  # pyright: ignore[reportArgumentType]\n                ident=ident,\n                buffers=buffers,  # pyright: ignore[reportArgumentType]\n            )\n            if msg:\n                self.log.debug(\"iopub_send: msg_type:'%s', content: %s\", msg[\"header\"][\"msg_type\"], msg[\"content\"])\n        elif (caller := self.callers.get(Channel.control)) and caller.id != t_ident:\n            caller.call_direct(\n                self.iopub_send,\n                msg_or_type=msg_or_type,\n                content=content,\n                metadata=metadata,\n                parent=parent if parent is not NoValue else None,\n                ident=ident,\n                buffers=buffers,\n            )\n\n    def receive_msg_loop(self, channel: Literal[Channel.control, Channel.shell], ready: Event, start: Event) -&gt; None:\n        \"\"\"\n        Opens a zmq socket for the channel, receives messages and calls the message handler.\n        \"\"\"\n        if not utils.LAUNCHED_BY_DEBUGPY:\n            utils.mark_thread_pydev_do_not_trace()\n\n        session, log, message_handler = self.session, self.log, self.kernel.msg_handler\n        with self._bind_socket(channel) as socket:\n            lock = BinarySemaphore()\n\n            async def send_reply(job: Job, content: dict, /) -&gt; None:\n                if \"status\" not in content:\n                    content[\"status\"] = \"ok\"\n                async with lock:\n                    msg = session.send(\n                        stream=socket,\n                        msg_or_type=job[\"msg\"][\"header\"][\"msg_type\"].replace(\"request\", \"reply\"),\n                        content=content,\n                        parent=job[\"msg\"],  # pyright: ignore[reportArgumentType]\n                        ident=job[\"ident\"],\n                        buffers=content.pop(\"buffers\", None),\n                    )\n                    if msg:\n                        log.debug(\"*** send_reply %s*** %s\", channel, msg)\n\n            ready.set()\n            start.wait()\n            while True:\n                try:\n                    ident, msg = session.recv(socket, mode=zmq.BLOCKY, copy=False)\n                    msg[\"channel\"] = channel  # pyright: ignore[reportOptionalSubscript]\n                    job = Job(received_time=time.monotonic(), msg=msg, ident=ident)  # pyright: ignore[reportArgumentType]\n                    message_handler(channel, MsgType(job[\"msg\"][\"header\"][\"msg_type\"]), job, send_reply)\n                except zmq.ContextTerminated:\n                    break\n                except Exception as e:\n                    log.debug(\"Bad message on %s: %s\", channel, e)\n                    continue\n\n    @enable_signal_safety\n    def _signal_handler(self, signum, frame: FrameType | None) -&gt; None:\n        \"Handle interrupt signals.\"\n\n        match self._interrupt_requested:\n            case \"FORCE\":\n                self._interrupt_requested = False\n                raise KernelInterruptError\n            case True:\n                if frame and frame.f_locals is self.kernel.shell.user_ns:\n                    self._interrupt_requested = False\n                    raise KernelInterruptError\n                self.last_interrupt_frame = frame\n\n                def clearlast_interrupt_frame():\n                    if self.last_interrupt_frame is frame:\n                        self.last_interrupt_frame = None\n\n                def re_raise():\n                    if self.last_interrupt_frame is frame:\n                        self._interrupt_now(force=True)\n\n                # Race to check if the main thread should be interrupted.\n                self.callers[Channel.shell].call_direct(clearlast_interrupt_frame)\n                self.callers[Channel.control].call_later(1, re_raise)\n            case False:\n                signal.default_int_handler(signum, frame)\n\n    def _interrupt_now(self, *, force=False) -&gt; None:\n        \"\"\"\n        Request an interrupt of the currently running shell thread.\n\n        If called from the main thread, sets the interrupt request flag and sends a SIGINT signal\n        to the current process. On Windows, uses `signal.raise_signal`; on other platforms, uses `os.kill`.\n        If `force` is True, sets the interrupt request flag to \"FORCE\".\n\n        Args:\n            force: If True, requests a forced interrupt. Defaults to False.\n        \"\"\"\n        # Restricted this to when the shell is running in the main thread.\n        if self.callers[Channel.shell].id == Caller.CALLER_MAIN_THREAD_ID:\n            self._interrupt_requested = \"FORCE\" if force else True\n            if sys.platform == \"win32\":\n                signal.raise_signal(signal.SIGINT)\n                time.sleep(0)\n            else:\n                os.kill(os.getpid(), signal.SIGINT)\n\n    @override\n    def interrupt(self) -&gt; None:\n        \"\"\"\n        Perform a keyboard interrupt.\n        \"\"\"\n        self._interrupt_now()\n        super().interrupt()\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.sockets","title":"sockets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sockets: Fixed[Self, dict[Channel, Socket]] = Fixed(dict)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.ports","title":"ports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ports: Fixed[Self, dict[Channel, int]] = Fixed(dict)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.ip","title":"ip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ip = Unicode()\n</code></pre> <p>The kernel's IP address [default localhost].</p> <p>If the IP address is something other than localhost, then Consoles on other machines  will be able to connect to the Kernel, so be careful!</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session = Fixed(Session)\n</code></pre> <p>Handles serialization and sending of messages.</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.transport","title":"transport  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transport: CaselessStrEnum[str] = CaselessStrEnum(\n    [\"tcp\", \"ipc\"] if platform == \"linux\" else [\"tcp\"], default_value=\"tcp\"\n)\n</code></pre> <p>Transport for sockets.</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.loop","title":"loop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loop: TraitType[Loop | None, Loop | None] = UseEnum(\n    Loop, default_value=None, allow_none=True\n)\n</code></pre> <p>The name of the (gui) event loop if one is used.</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.loop_options","title":"loop_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loop_options = Dict(allow_none=True)\n</code></pre> <p>Options for starting the loop.</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.backend_options","title":"backend_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backend_options = Dict(allow_none=True)\n</code></pre> <p>Options for starting the backend.</p> Referenced by: <ul> <li> Usage Command line and kernel configuration Backend </li> </ul>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the kernel blocking until the kernel stops.</p> Warning <ul> <li>Running the kernel in a thread other than the 'MainThread' is permitted, but discouraged.</li> <li>Blocking calls can only be interrupted in the 'MainThread' because 'threads cannot be destroyed, stopped, suspended, resumed, or interrupted'.</li> <li>Some libraries may assume the call is occurring in the 'MainThread'.</li> <li>If there is an <code>asyncio</code> or <code>trio</code> event loop already running in the 'MainThread<code>;     start the kernel asynchronously instead (</code>async with kernel: ...`).</li> </ul> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>def start(self):\n    \"\"\"\n    Start the kernel blocking until the kernel stops.\n\n    Warning:\n        - Running the kernel in a thread other than the 'MainThread' is permitted, but discouraged.\n        - Blocking calls can only be interrupted in the 'MainThread' because [*'threads cannot be destroyed, stopped, suspended, resumed, or interrupted'*](https://docs.python.org/3/library/threading.html#module-threading).\n        - Some libraries may assume the call is occurring in the 'MainThread'.\n        - If there is an `asyncio` or `trio` event loop already running in the 'MainThread`;\n            start the kernel asynchronously instead (`async with kernel: ...`).\n    \"\"\"\n\n    async def run_kernel() -&gt; None:\n        async with self.kernel:\n            await self.wait_exit\n\n    settings = RunSettings(\n        backend=self.backend,\n        loop=self.loop,\n        backend_options=self.backend_options,\n        loop_options=self.loop_options,\n    )\n    async_kernel.event_loop.run(run_kernel, (), settings)\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.load_connection_info","title":"load_connection_info","text":"<pre><code>load_connection_info(info: dict[str, Any]) -&gt; None\n</code></pre> <p>Load connection info from a dict containing connection info.</p> <p>Typically this data comes from a connection file and is called by load_connection_file.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>@override\ndef load_connection_info(self, info: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Load connection info from a dict containing connection info.\n\n    Typically this data comes from a connection file\n    and is called by load_connection_file.\n\n    Args:\n        info: Dictionary containing connection_info. See the connection_file spec for details.\n    \"\"\"\n    if self.ports:\n        msg = \"Connection info is already loaded!\"\n        raise RuntimeError(msg)\n    self.transport = info.get(\"transport\", self.transport)\n    self.ip = info.get(\"ip\") or self.ip\n    for channel in Channel:\n        name = f\"{channel}_port\"\n        if channel not in self.ports and name in info:\n            self.ports[channel] = info[name]\n    if \"key\" in info:\n        key = info[\"key\"]\n        if isinstance(key, str):\n            key = key.encode()\n        assert isinstance(key, bytes)\n\n        self.session.key = key\n    if \"signature_scheme\" in info:\n        self.session.signature_scheme = info[\"signature_scheme\"]\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.load_connection_info(info)","title":"<code>info</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary containing connection_info. See the connection_file spec for details.</p>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.__asynccontextmanager__","title":"__asynccontextmanager__  <code>async</code>","text":"<pre><code>__asynccontextmanager__() -&gt; AsyncGenerator[Self]\n</code></pre> <p>Create caller, and open socketes.</p> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>@override\n@asynccontextmanager\nasync def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n    \"\"\"Create caller, and open socketes.\"\"\"\n    self.backend = Backend(current_async_library())\n    sig = restore_io = None\n    caller = Caller(\n        \"manual\",\n        name=\"Shell\",\n        protected=True,\n        log=self.kernel.log,\n        zmq_context=self._zmq_context,\n        loop=self.loop,\n    )\n    self.callers[Channel.shell] = caller\n    self.callers[Channel.control] = caller.get(name=\"Control\", log=self.kernel.log, protected=True)\n    start = Event()\n    try:\n        async with caller:\n            self._start_hb_iopub_shell_control_threads(start)\n            with self._bind_socket(Channel.stdin):\n                assert len(self.sockets) == len(Channel)\n                self._write_connection_file()\n                restore_io = self._patch_io()\n                with contextlib.suppress(ValueError):\n                    sig = signal.signal(signal.SIGINT, self._signal_handler)\n                start.set()\n                yield self\n    finally:\n        start.set()\n        if sig:\n            signal.signal(signal.SIGINT, sig)\n        if restore_io:\n            restore_io()\n        self._zmq_context.term()\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send a message on the zmq iopub socket.</p> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>@override\ndef iopub_send(\n    self,\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | MsgHeader | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"\n    Send a message on the zmq iopub socket.\n    \"\"\"\n    if socket := Caller.iopub_sockets.get(t_ident := Caller.id_current()):\n        msg = self.session.send(\n            stream=socket,\n            msg_or_type=msg_or_type,  # pyright: ignore[reportArgumentType]\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else utils.get_parent(),  # pyright: ignore[reportArgumentType]\n            ident=ident,\n            buffers=buffers,  # pyright: ignore[reportArgumentType]\n        )\n        if msg:\n            self.log.debug(\"iopub_send: msg_type:'%s', content: %s\", msg[\"header\"][\"msg_type\"], msg[\"content\"])\n    elif (caller := self.callers.get(Channel.control)) and caller.id != t_ident:\n        caller.call_direct(\n            self.iopub_send,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else None,\n            ident=ident,\n            buffers=buffers,\n        )\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.receive_msg_loop","title":"receive_msg_loop","text":"<pre><code>receive_msg_loop(channel: Literal[control, shell], ready: Event, start: Event) -&gt; None\n</code></pre> <p>Opens a zmq socket for the channel, receives messages and calls the message handler.</p> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>def receive_msg_loop(self, channel: Literal[Channel.control, Channel.shell], ready: Event, start: Event) -&gt; None:\n    \"\"\"\n    Opens a zmq socket for the channel, receives messages and calls the message handler.\n    \"\"\"\n    if not utils.LAUNCHED_BY_DEBUGPY:\n        utils.mark_thread_pydev_do_not_trace()\n\n    session, log, message_handler = self.session, self.log, self.kernel.msg_handler\n    with self._bind_socket(channel) as socket:\n        lock = BinarySemaphore()\n\n        async def send_reply(job: Job, content: dict, /) -&gt; None:\n            if \"status\" not in content:\n                content[\"status\"] = \"ok\"\n            async with lock:\n                msg = session.send(\n                    stream=socket,\n                    msg_or_type=job[\"msg\"][\"header\"][\"msg_type\"].replace(\"request\", \"reply\"),\n                    content=content,\n                    parent=job[\"msg\"],  # pyright: ignore[reportArgumentType]\n                    ident=job[\"ident\"],\n                    buffers=content.pop(\"buffers\", None),\n                )\n                if msg:\n                    log.debug(\"*** send_reply %s*** %s\", channel, msg)\n\n        ready.set()\n        start.wait()\n        while True:\n            try:\n                ident, msg = session.recv(socket, mode=zmq.BLOCKY, copy=False)\n                msg[\"channel\"] = channel  # pyright: ignore[reportOptionalSubscript]\n                job = Job(received_time=time.monotonic(), msg=msg, ident=ident)  # pyright: ignore[reportArgumentType]\n                message_handler(channel, MsgType(job[\"msg\"][\"header\"][\"msg_type\"]), job, send_reply)\n            except zmq.ContextTerminated:\n                break\n            except Exception as e:\n                log.debug(\"Bad message on %s: %s\", channel, e)\n                continue\n</code></pre>"},{"location":"reference/interface/#async_kernel.interface.zmq.ZMQKernelInterface.interrupt","title":"interrupt","text":"<pre><code>interrupt() -&gt; None\n</code></pre> <p>Perform a keyboard interrupt.</p> Source code in <code>src/async_kernel/interface/zmq.py</code> <pre><code>@override\ndef interrupt(self) -&gt; None:\n    \"\"\"\n    Perform a keyboard interrupt.\n    \"\"\"\n    self._interrupt_now()\n    super().interrupt()\n</code></pre>"},{"location":"reference/kernel/","title":"kernel","text":"<p>Classes:</p> <ul> <li> <code>KernelInterruptError</code>           \u2013            <p>Raised to interrupt the kernel.</p> </li> <li> <code>Kernel</code>           \u2013            <p>A Jupyter kernel that supports concurrent execution providing an IPython InteractiveShell</p> </li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.KernelInterruptError","title":"KernelInterruptError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised to interrupt the kernel.</p> Referenced by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0BaseKernelInterface </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0interrupt </li> </ul> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>class KernelInterruptError(Exception):\n    \"Raised to interrupt the kernel.\"\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel","title":"Kernel","text":"<p>               Bases: <code>HasTraits</code>, <code>AsyncContextManagerMixin</code></p> <p>A Jupyter kernel that supports concurrent execution providing an IPython InteractiveShell with support for kernel subshells.</p> Info <p>Only one instance of a kernel is created at a time per subprocess. The instance can be obtained with <code>Kernel()</code> or [get_kernel].</p> Starting the kernel <p>The kernel should appear in the list of kernels just as other kernels are. Variants of the kernel can with custom configuration can be added at the command line.</p> From the shellBlockingInside a coroutine <pre><code>async-kernel -f .\n</code></pre> <pre><code>import async_kernel.interface\n\nasync_kernel.interface.start_kernel_zmq_interface()\n</code></pre> <pre><code>async with Kernel():\n    await anyio.sleep_forever()\n</code></pre> Warning <p>Starting the kernel outside the main thread has the following implicatations:     - Execute requests won't be run in the main thread.     - Interrupts via signals won't work, so thread blocking calls in the shell cannot be interrupted.</p> Origins <ul> <li>IPyKernel Kernel</li> <li>IPyKernel IPKernelApp</li> <li>IPyKernel IPythonKernel</li> </ul> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> asyncshell <ul> <li> <code></code>\u00a0AsyncInteractiveShell </li> <li> <code></code>\u00a0asyncshell </li> </ul> </li> </ul> </li> <li> Usage Usage Caller </li> </ul> Returned by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0kernel </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0kernel </li> </ul> </li> <li> utils <code></code>\u00a0get_kernel </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>load_settings</code>             \u2013              <p>Load settings into the kernel.</p> </li> <li> <code>load_connection_info</code>             \u2013              <p>Load connection info from a dict containing connection info.</p> </li> <li> <code>stop</code>             \u2013              <p>A staticmethod to stop the running kernel.</p> </li> <li> <code>__asynccontextmanager__</code>             \u2013              <p>Start the kernel in an already running anyio event loop.</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send a message on the iopub socket.</p> </li> <li> <code>topic</code>             \u2013              <p>prefixed topic for IOPub messages.</p> </li> <li> <code>msg_handler</code>             \u2013              <p>Schedule a message to be executed.</p> </li> <li> <code>run_handler</code>             \u2013              <p>Asynchronously run a message handler for a given job, managing reply sending and execution state.</p> </li> <li> <code>get_run_mode</code>             \u2013              <p>Determine the run mode for a given channel, message type and job.</p> </li> <li> <code>all_concurrency_run_modes</code>             \u2013              <p>Generates a dictionary containing all combinations of SocketID, and MsgType, along with their</p> </li> <li> <code>kernel_info_request</code>             \u2013              <p>Handle a kernel info request.</p> </li> <li> <code>comm_info_request</code>             \u2013              <p>Handle a comm info request.</p> </li> <li> <code>execute_request</code>             \u2013              <p>Handle a execute request.</p> </li> <li> <code>complete_request</code>             \u2013              <p>Handle a completion request.</p> </li> <li> <code>is_complete_request</code>             \u2013              <p>Handle a is_complete request.</p> </li> <li> <code>inspect_request</code>             \u2013              <p>Handle a inspect request.</p> </li> <li> <code>history_request</code>             \u2013              <p>Handle a history request.</p> </li> <li> <code>comm_open</code>             \u2013              <p>Handle a comm open request.</p> </li> <li> <code>comm_msg</code>             \u2013              <p>Handle a comm msg request.</p> </li> <li> <code>comm_close</code>             \u2013              <p>Handle a comm close request.</p> </li> <li> <code>interrupt_request</code>             \u2013              <p>Handle an interrupt request (control only).</p> </li> <li> <code>shutdown_request</code>             \u2013              <p>Handle a shutdown request (control only).</p> </li> <li> <code>debug_request</code>             \u2013              <p>Handle a debug request (control only).</p> </li> <li> <code>create_subshell_request</code>             \u2013              <p>Handle a create subshell request (control only).</p> </li> <li> <code>delete_subshell_request</code>             \u2013              <p>Handle a delete subshell request (control only).</p> </li> <li> <code>list_subshell_request</code>             \u2013              <p>Handle a list subshell request (control only).</p> </li> <li> <code>excepthook</code>             \u2013              <p>Handle an exception.</p> </li> <li> <code>unraisablehook</code>             \u2013              <p>Handle unraisable exceptions (during gc for instance).</p> </li> <li> <code>get_connection_info</code>             \u2013              <p>Return the connection info as a dict.</p> </li> <li> <code>get_parent</code>             \u2013              <p>A convenience method to access the 'message' in the current context if there is one.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>interface</code>           \u2013            <p>The abstraction to communicate with the kernel.</p> </li> <li> <code>callers</code>               (<code>Fixed[Self, dict[Literal[shell, control], Caller]]</code>)           \u2013            <p>The callers associated with the kernel once it has started.</p> </li> <li> <code>subshell_manager</code>           \u2013            <p>Dedicated to management of sub shells.</p> </li> <li> <code>help_links</code>           \u2013            </li> <li> <code>quiet</code>           \u2013            <p>Only send stdout/stderr to output stream.</p> </li> <li> <code>print_kernel_messages</code>           \u2013            <p>When enabled the kernel will print startup, shutdown and terminal errors.</p> </li> <li> <code>connection_file</code>               (<code>TraitType[Path, Path | str]</code>)           \u2013            <p>JSON file in which to store connection info </p> </li> <li> <code>kernel_name</code>           \u2013            <p>The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.</p> </li> <li> <code>log</code>           \u2013            <p>The logging adapter.</p> </li> <li> <code>main_shell</code>           \u2013            <p>The interactive shell.</p> </li> <li> <code>debugger</code>           \u2013            <p>Handles debug requests.</p> </li> <li> <code>comm_manager</code>           \u2013            <p>Creates async_kernel.comm.Comm instances and maintains a mapping to <code>comm_id</code> to <code>Comm</code> instances.</p> </li> <li> <code>event_started</code>           \u2013            <p>An event that occurs when the kernel is started.</p> </li> <li> <code>event_stopped</code>           \u2013            <p>An event that occurs when the kernel is stopped.</p> </li> <li> <code>settings</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Settings that have been set to customise the behaviour of the kernel.</p> </li> <li> <code>shell</code>               (<code>AsyncInteractiveShell | AsyncInteractiveSubshell</code>)           \u2013            <p>The shell given the current context.</p> </li> <li> <code>caller</code>               (<code>Caller</code>)           \u2013            <p>The caller for the shell channel.</p> </li> <li> <code>kernel_info</code>               (<code>dict[str, str | dict[str, str | dict[str, str | int]] | Any | tuple[Any, ...] | bool]</code>)           \u2013            <p>A dict of detail sent in reply to for a 'kernel_info_request'.</p> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>class Kernel(HasTraits, anyio.AsyncContextManagerMixin):\n    \"\"\"\n    A Jupyter kernel that supports concurrent execution providing an [IPython InteractiveShell][async_kernel.asyncshell.AsyncInteractiveShell]\n    with support for kernel subshells.\n\n    Info:\n        Only one instance of a kernel is created at a time per subprocess. The instance can be obtained\n        with `Kernel()` or [get_kernel].\n\n    Starting the kernel:\n        The kernel should appear in the list of kernels just as other kernels are. Variants of the kernel\n        can with custom configuration can be added at the [command line][command.command_line].\n\n        === \"From the shell\"\n\n            ``` shell\n            async-kernel -f .\n            ```\n\n        === \"Blocking\"\n\n            ```python\n            import async_kernel.interface\n\n            async_kernel.interface.start_kernel_zmq_interface()\n            ```\n\n        === \"Inside a coroutine\"\n\n            ```python\n            async with Kernel():\n                await anyio.sleep_forever()\n            ```\n\n    Warning:\n        Starting the kernel outside the main thread has the following implicatations:\n            - Execute requests won't be run in the main thread.\n            - Interrupts via signals won't work, so thread blocking calls in the shell cannot be interrupted.\n\n    Origins:\n        - [IPyKernel Kernel][ipykernel.kernelbase.Kernel]\n        - [IPyKernel IPKernelApp][ipykernel.kernelapp.IPKernelApp]\n        - [IPyKernel IPythonKernel][ipykernel.ipkernel.IPythonKernel]\n    \"\"\"\n\n    _instance: Self | None = None\n    _initialised = False\n\n    _settings = Fixed(dict)\n\n    interface = traitlets.Instance(BaseKernelInterface)\n    \"The abstraction to communicate with the kernel.\"\n\n    callers: Fixed[Self, dict[Literal[Channel.shell, Channel.control], Caller]] = Fixed(dict)\n    \"The callers associated with the kernel once it has started.\"\n    \"\"\n    subshell_manager = Fixed(SubshellManager)\n    \"Dedicated to management of sub shells.\"\n\n    # Public traits\n    help_links = Tuple()\n    \"\"\n    quiet = traitlets.Bool(True)\n    \"Only send stdout/stderr to output stream.\"\n\n    print_kernel_messages = traitlets.Bool(True)\n    \"When enabled the kernel will print startup, shutdown and terminal errors.\"\n\n    connection_file: traitlets.TraitType[Path, Path | str] = traitlets.TraitType()\n    \"\"\"\n    JSON file in which to store connection info \n\n    `\"kernel-&lt;pid&gt;.json\"`\n\n    This file will contain the IP, ports, and authentication key needed to connect\n    clients to this kernel. By default, this file will be created in the security dir\n    of the current profile, but can be specified by absolute path.\n    \"\"\"\n\n    kernel_name = CUnicode()\n    \"The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.\"\n\n    log = Instance(logging.LoggerAdapter)\n    \"The logging adapter.\"\n\n    # Public fixed\n    main_shell = Fixed(lambda _: AsyncInteractiveShell.instance())\n    \"The interactive shell.\"\n\n    debugger = Fixed(Debugger)\n    \"Handles [debug requests](https://jupyter-client.readthedocs.io/en/stable/messaging.html#debug-request).\"\n\n    comm_manager = Fixed(CommManager)\n    \"Creates [async_kernel.comm.Comm][] instances and maintains a mapping to `comm_id` to `Comm` instances.\"\n\n    event_started = Fixed(Event)\n    \"An event that occurs when the kernel is started.\"\n\n    event_stopped = Fixed(Event)\n    \"An event that occurs when the kernel is stopped.\"\n\n    def __new__(cls, settings: dict | None = None, /) -&gt; Self:  # noqa: ARG004\n        #  There is only one instance (including subclasses).\n        if not (instance := Kernel._instance):\n            Kernel._instance = instance = super().__new__(cls)\n        return instance  # pyright: ignore[reportReturnType]\n\n    def __init__(self, settings: dict | None = None, /) -&gt; None:\n        if not self._initialised:\n            self._initialised = True\n            super().__init__()\n            if not os.environ.get(\"MPLBACKEND\"):\n                os.environ[\"MPLBACKEND\"] = \"module://matplotlib_inline.backend_inline\"\n        if settings:\n            self.load_settings(settings)\n\n    @override\n    def __repr__(self) -&gt; str:\n        info = [f\"{k}={v}\" for k, v in self.settings.items()]\n        return f\"{self.__class__.__name__}&lt;{', '.join(info)}&gt;\"\n\n    @traitlets.default(\"log\")\n    def _default_log(self) -&gt; LoggerAdapter[Logger]:\n        return logging.LoggerAdapter(logging.getLogger(self.__class__.__name__))\n\n    @traitlets.default(\"kernel_name\")\n    def _default_kernel_name(self):\n        return \"async-trio\" if current_async_library(failsafe=True) == \"trio\" else \"async\"\n\n    @traitlets.default(\"interface\")\n    def default_interface(self):\n        from async_kernel.interface.zmq import ZMQKernelInterface  # noqa: PLC0415\n\n        return ZMQKernelInterface()\n\n    @traitlets.default(\"connection_file\")\n    def _default_connection_file(self) -&gt; Path:\n        return Path(jupyter_runtime_dir()).joinpath(f\"kernel-{uuid.uuid4()}.json\")\n\n    @traitlets.default(\"help_links\")\n    def _default_help_links(self) -&gt; tuple[dict[str, str], ...]:\n        return (\n            {\n                \"text\": \"Async Kernel Reference \",\n                \"url\": \"https://fleming79.github.io/async-kernel/\",\n            },\n            {\n                \"text\": \"IPython Reference\",\n                \"url\": \"https://ipython.readthedocs.io/en/stable/\",\n            },\n            {\n                \"text\": \"IPython magic Reference\",\n                \"url\": \"https://ipython.readthedocs.io/en/stable/interactive/magics.html\",\n            },\n            {\n                \"text\": \"Matplotlib ipympl Reference\",\n                \"url\": \"https://matplotlib.org/ipympl/\",\n            },\n            {\n                \"text\": \"Matplotlib Reference\",\n                \"url\": \"https://matplotlib.org/contents.html\",\n            },\n        )\n\n    @traitlets.observe(\"connection_file\")\n    def _observe_connection_file(self, change) -&gt; None:\n        if not self.interface.callers and (path := self.connection_file).exists():\n            self.log.debug(\"Loading connection file %s\", path)\n            with path.open(\"r\") as f:\n                self.load_connection_info(json.load(f))\n\n    @traitlets.validate(\"connection_file\")\n    def _validate_connection_file(self, proposal) -&gt; Path:\n        return pathlib.Path(proposal.value)\n\n    @property\n    def settings(self) -&gt; dict[str, Any]:\n        \"Settings that have been set to customise the behaviour of the kernel.\"\n        return {k: getattr(self, k) for k in (\"kernel_name\", \"connection_file\")} | self._settings\n\n    @property\n    def shell(self) -&gt; AsyncInteractiveShell | AsyncInteractiveSubshell:\n        \"\"\"\n        The shell given the current context.\n\n        Notes:\n            - The `subshell_id` of the main shell is `None`.\n        \"\"\"\n        return self.subshell_manager.get_shell()\n\n    @property\n    def caller(self) -&gt; Caller:\n        \"The caller for the shell channel.\"\n        return self.callers[Channel.shell]\n\n    @property\n    def kernel_info(self) -&gt; dict[str, str | dict[str, str | dict[str, str | int]] | Any | tuple[Any, ...] | bool]:\n        \"A dict of detail sent in reply to for a 'kernel_info_request'.\"\n        supported_features = [\"kernel subshells\"]\n        if not utils.LAUNCHED_BY_DEBUGPY and sys.platform != \"emscripten\":\n            supported_features.append(\"debugger\")\n\n        return {\n            \"protocol_version\": async_kernel.kernel_protocol_version,\n            \"implementation\": \"async_kernel\",\n            \"implementation_version\": async_kernel.__version__,\n            \"language_info\": async_kernel.kernel_protocol_version_info,\n            \"banner\": self.shell.banner,\n            \"help_links\": self.help_links,\n            \"debugger\": (not utils.LAUNCHED_BY_DEBUGPY) &amp; (sys.platform != \"emscripten\"),\n            \"kernel_name\": self.kernel_name,\n            \"supported_features\": supported_features,\n        }\n\n    def load_settings(self, settings: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Load settings into the kernel.\n\n        Permitted until the kernel async context has been entered.\n\n        Args:\n            settings:\n                key: dotted.path.of.attribute.\n                value: The value to set.\n        \"\"\"\n        if self.event_started:\n            msg = \"It is too late to load settings!\"\n            raise RuntimeError(msg)\n        settings_ = self._settings or {\"kernel_name\": self.kernel_name}\n        for k, v in settings.items():\n            settings_ |= utils.setattr_nested(self, k, v)\n        self._settings.update(settings_)\n\n    def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Load connection info from a dict containing connection info.\n\n        Typically this data comes from a connection file\n        and is called by load_connection_file.\n\n        Args:\n            info: Dictionary containing connection_info. See the connection_file spec for details.\n        \"\"\"\n        self.interface.load_connection_info(info)\n\n    @staticmethod\n    def stop() -&gt; None:\n        \"\"\"\n        A [staticmethod][] to stop the running kernel.\n\n        Once an instance of a kernel is stopped the instance cannot be restarted.\n        Instead a new instance should be started.\n        \"\"\"\n        if (instance := Kernel._instance) and (stop := getattr(instance, \"_stop\", None)):\n            stop()\n\n    @asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        \"\"\"Start the kernel in an already running anyio event loop.\"\"\"\n        assert self.main_shell\n        try:\n            async with self.interface:\n                self.callers.update(self.interface.callers)\n                with anyio.CancelScope() as scope:\n                    self._stop = lambda: self.caller.call_direct(scope.cancel, \"Stopping kernel\")\n                    sys.excepthook = self.excepthook\n                    sys.unraisablehook = self.unraisablehook\n\n                    self.comm_manager.patch_comm()\n                    try:\n                        self.comm_manager.kernel = self\n                        self.event_started.set()\n                        self.log.info(\"Kernel started: %s\", self)\n                        yield self\n                    except BaseException:\n                        if not scope.cancel_called:\n                            raise\n                    finally:\n                        self.comm_manager.kernel = None\n                        self.event_stopped.set()\n        finally:\n            self.shell.reset(new_session=False)\n            self.subshell_manager.stop_all_subshells(force=True)\n            self.callers.clear()\n            Kernel._instance = None\n            AsyncInteractiveShell.clear_instance()\n            with anyio.CancelScope(shield=True):\n                await anyio.sleep(0.1)\n            self.log.info(\"Kernel stopped: %s\", self)\n            gc.collect()\n\n    def iopub_send(\n        self,\n        msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n        *,\n        content: Content | None = None,\n        metadata: dict[str, Any] | None = None,\n        parent: Message[dict[str, Any]] | dict[str, Any] | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n        ident: bytes | list[bytes] | None = None,\n        buffers: list[bytes] | None = None,\n    ) -&gt; None:\n        \"\"\"Send a message on the iopub socket.\"\"\"\n        self.interface.iopub_send(\n            msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent,\n            ident=ident,\n            buffers=buffers,\n        )\n\n    def topic(self, topic) -&gt; bytes:\n        \"\"\"prefixed topic for IOPub messages.\"\"\"\n        return (f\"kernel.{topic}\").encode()\n\n    def msg_handler(\n        self,\n        channel: Literal[Channel.shell, Channel.control],\n        msg_type: MsgType,\n        job: Job,\n        send_reply: Callable[[Job, dict], CoroutineType[Any, Any, None]],\n        /,\n    ):\n        \"\"\"Schedule a message to be executed.\"\"\"\n        # Note: There are never any active pending trackers in this context.\n        try:\n            subshell_id = job[\"msg\"][\"content\"][\"subshell_id\"]\n        except KeyError:\n            try:\n                subshell_id = job[\"msg\"][\"header\"][\"subshell_id\"]  # pyright: ignore[reportTypedDictNotRequiredAccess]\n            except KeyError:\n                subshell_id = None\n        handler = cache_wrap_handler(subshell_id, send_reply, self.run_handler, self.get_handler(msg_type))\n        run_mode = self.get_run_mode(msg_type, channel=channel, job=job)\n        match run_mode:\n            case RunMode.direct:\n                self.callers[channel].call_direct(handler, job)\n            case RunMode.queue:\n                self.callers[channel].queue_call(handler, job).trackers = ()  # A slight optimisation\n            case RunMode.task:\n                self.callers[channel].call_soon(handler, job)\n            case RunMode.thread:\n                self.callers[channel].to_thread(handler, job)\n        self.log.debug(\"%s %s %s %s\", msg_type, handler, run_mode, job)\n\n    def get_handler(self, msg_type: MsgType) -&gt; HandlerType:\n        if not callable(f := getattr(self, msg_type, None)):\n            msg = f\"A handler was not found for {msg_type=}\"\n            raise TypeError(msg)\n        return f  # pyright: ignore[reportReturnType]\n\n    async def run_handler(\n        self,\n        subshell_id: str | None,\n        send_reply: Callable[[Job, dict], CoroutineType[Any, Any, None]],\n        handler: HandlerType,\n        job: Job[dict],\n    ) -&gt; None:\n        \"\"\"\n        Asynchronously run a message handler for a given job, managing reply sending and execution state.\n\n        Args:\n            subshell_id: The id of the subshell to set the context of the handler.\n            send_reply: A coroutine function responsible for sending the reply.\n            handler: A coroutine function to handle the job / message.\n\n                - It is a method on the kernel whose name corresponds to the [message type that it handles][async_kernel.typing.MsgType].\n                - The handler should return a dict to use as 'content'in a reply.\n                - If status is not included in the dict it gets added automatically as `{'status': 'ok'}`.\n                - If a reply is not expected the handler should return `None`.\n\n            job: The job dictionary containing message, socket, and identification information.\n\n        Workflow:\n            - Sets the current job and subshell_id context variables.\n            - Sends a \"busy\" status message on the IOPub channel.\n            - Awaits the handler; if the handler returns a content dict, a reply is sent using send_reply.\n            - On exception, sends an error reply and logs the exception.\n            - Resets the job and subshell_id context variables.\n            - Sends an \"idle\" status message on the IOPub channel.\n\n        Notes:\n            - Replies are sent even if exceptions occur in the handler.\n            - The reply message type is derived from the original request type.\n        \"\"\"\n        job_token = utils._job_var.set(job)  # pyright: ignore[reportPrivateUsage]\n        subshell_token = ShellPendingManager._id_contextvar.set(subshell_id)  # pyright: ignore[reportPrivateUsage]\n\n        try:\n            self.iopub_send(\n                msg_or_type=\"status\",\n                parent=job[\"msg\"],\n                content={\"execution_state\": \"busy\"},\n                ident=self.topic(topic=\"status\"),\n            )\n            if (content := await handler(job)) is not None:\n                await send_reply(job, content)\n        except Exception as e:\n            await send_reply(job, utils.error_to_content(e))\n            self.log.exception(\"Exception in message handler:\", exc_info=e)\n        finally:\n            utils._job_var.reset(job_token)  # pyright: ignore[reportPrivateUsage]\n            ShellPendingManager._id_contextvar.reset(subshell_token)  # pyright: ignore[reportPrivateUsage]\n            self.iopub_send(\n                msg_or_type=\"status\",\n                parent=job[\"msg\"],\n                content={\"execution_state\": \"idle\"},\n                ident=self.topic(\"status\"),\n            )\n            del job\n\n    def get_run_mode(\n        self,\n        msg_type: MsgType,\n        *,\n        channel: Literal[Channel.shell, Channel.control] = Channel.shell,\n        job: Job | None = None,\n    ) -&gt; RunMode:\n        \"\"\"\n        Determine the run mode for a given channel, message type and job.\n\n        Args:\n            channel: The channel the message was received on.\n            msg_type: The type of the message.\n            job: The job associated with the message, if any.\n\n        Returns:\n            The run mode for the message.\n        \"\"\"\n        # receive_msg_loop - DEBUG WARNING\n\n        # TODO: Are any of these options worth including?\n        # if mode_from_metadata := job[\"msg\"][\"metadata\"].get(\"run_mode\"):\n        #     return RunMode( mode_from_metadata)\n        # if mode_from_header := job[\"msg\"][\"header\"].get(\"run_mode\"):\n        #     return RunMode( mode_from_header)\n        match (channel, msg_type):\n            case _, MsgType.comm_msg:\n                return RunMode.queue\n            case Channel.control, MsgType.execute_request:\n                return RunMode.queue\n            case _, MsgType.execute_request:\n                if job:\n                    if content := job[\"msg\"].get(\"content\", {}):\n                        if code := content.get(\"code\"):\n                            try:\n                                if (code := code.strip().split(\"\\n\", maxsplit=1)[0]).startswith((\"# \", \"##\")):\n                                    return RunMode(code[2:])\n                                if code.startswith(\"RunMode.\"):\n                                    return RunMode(code.removeprefix(\"RunMode.\"))\n                            except ValueError:\n                                pass\n                        if content.get(\"silent\"):\n                            return RunMode.task\n                    if mode_ := set(utils.get_tags(job)).intersection(RunMode):\n                        return RunMode(next(iter(mode_)))\n                return RunMode.queue\n            case (\n                Channel.shell,\n                MsgType.shutdown_request\n                | MsgType.debug_request\n                | MsgType.create_subshell_request\n                | MsgType.delete_subshell_request\n                | MsgType.list_subshell_request,\n            ):\n                msg = f\"{msg_type=} not allowed on shell!\"\n                raise ValueError(msg)\n            case _, MsgType.debug_request:\n                return RunMode.queue\n            case (\n                _,\n                MsgType.complete_request\n                | MsgType.inspect_request\n                | MsgType.history_request\n                | MsgType.create_subshell_request\n                | MsgType.delete_subshell_request\n                | MsgType.is_complete_request,\n            ):\n                return RunMode.thread\n            case _:\n                pass\n        return RunMode.direct\n\n    def all_concurrency_run_modes(\n        self,\n        channels: Iterable[Literal[Channel.shell, Channel.control]] = (Channel.shell, Channel.control),\n        msg_types: Iterable[MsgType] = MsgType,\n    ) -&gt; dict[\n        Literal[\"SocketID\", \"MsgType\", \"RunMode\"],\n        tuple[Channel, MsgType, RunMode | None],\n    ]:\n        \"\"\"\n        Generates a dictionary containing all combinations of SocketID, and MsgType, along with their\n        corresponding RunMode (if available).\n        \"\"\"\n        data: list[Any] = []\n        for channel in channels:\n            for msg_type in msg_types:\n                try:\n                    mode = self.get_run_mode(msg_type, channel=channel)\n                except ValueError:\n                    mode = None\n                data.append((channel, msg_type, mode))\n        data_ = zip(*data, strict=True)\n        return dict(zip([\"SocketID\", \"MsgType\", \"RunMode\"], data_, strict=True))\n\n    async def kernel_info_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [kernel info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-info).\"\"\"\n        return self.kernel_info\n\n    async def comm_info_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [comm info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-info).\"\"\"\n        c = job[\"msg\"][\"content\"]\n        target_name = c.get(\"target_name\", None)\n        comms = {\n            k: {\"target_name\": v.target_name}\n            for (k, v) in tuple(self.comm_manager.comms.items())\n            if v.target_name == target_name or target_name is None\n        }\n        return {\"comms\": comms}\n\n    async def execute_request(self, job: Job[ExecuteContent], /) -&gt; Content:\n        \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n        return await self.shell.execute_request(**job[\"msg\"][\"content\"])  # pyright: ignore[reportArgumentType]\n\n    async def complete_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n        return await self.shell.do_complete_request(\n            code=job[\"msg\"][\"content\"].get(\"code\", \"\"), cursor_pos=job[\"msg\"][\"content\"].get(\"cursor_pos\", 0)\n        )\n\n    async def is_complete_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n        return await self.shell.is_complete_request(job[\"msg\"][\"content\"].get(\"code\", \"\"))\n\n    async def inspect_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n        c = job[\"msg\"][\"content\"]\n        return await self.shell.inspect_request(\n            code=c.get(\"code\", \"\"),\n            cursor_pos=c.get(\"cursor_pos\", 0),\n            detail_level=c.get(\"detail_level\", 0),\n        )\n\n    async def history_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n        return await self.shell.history_request(**job[\"msg\"][\"content\"])\n\n    async def comm_open(self, job: Job[Content], /) -&gt; None:\n        \"\"\"Handle a [comm open request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#opening-a-comm).\"\"\"\n        self.comm_manager.comm_open(stream=None, ident=None, msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n\n    async def comm_msg(self, job: Job[Content], /) -&gt; None:\n        \"\"\"Handle a [comm msg request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-messages).\"\"\"\n        self.comm_manager.comm_msg(stream=None, ident=None, msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n\n    async def comm_close(self, job: Job[Content], /) -&gt; None:\n        \"\"\"Handle a [comm close request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#tearing-down-comms).\"\"\"\n        self.comm_manager.comm_close(stream=None, ident=None, msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n\n    async def interrupt_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle an [interrupt request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-interrupt) (control only).\"\"\"\n        self.interface.interrupt()\n        return {}\n\n    async def shutdown_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [shutdown request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-shutdown) (control only).\"\"\"\n        self.stop()\n        return {\"restart\": job[\"msg\"][\"content\"].get(\"restart\", False)}\n\n    async def debug_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [debug request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#debug-request) (control only).\"\"\"\n        return await self.debugger.process_request(job[\"msg\"][\"content\"])\n\n    async def create_subshell_request(self: Kernel, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [create subshell request](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#create-subshell) (control only).\"\"\"\n\n        return {\"subshell_id\": self.subshell_manager.create_subshell(protected=False).subshell_id}\n\n    async def delete_subshell_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [delete subshell request](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#delete-subshell) (control only).\"\"\"\n        self.subshell_manager.delete_subshell(job[\"msg\"][\"content\"][\"subshell_id\"])\n        return {}\n\n    async def list_subshell_request(self, job: Job[Content], /) -&gt; Content:\n        \"\"\"Handle a [list subshell request](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#list-subshells) (control only).\"\"\"\n        return {\"subshell_id\": list(self.subshell_manager.list_subshells())}\n\n    def excepthook(self, etype, evalue, tb) -&gt; None:\n        \"\"\"Handle an exception.\"\"\"\n        # write uncaught traceback to 'real' stderr, not zmq-forwarder\n        if self.print_kernel_messages:\n            traceback.print_exception(etype, evalue, tb, file=sys.__stderr__)\n\n    def unraisablehook(self, unraisable: sys.UnraisableHookArgs, /) -&gt; None:\n        \"Handle unraisable exceptions (during gc for instance).\"\n        exc_info = (\n            unraisable.exc_type,\n            unraisable.exc_value or unraisable.exc_type(unraisable.err_msg),\n            unraisable.exc_traceback,\n        )\n        self.log.exception(unraisable.err_msg, exc_info=exc_info, extra={\"object\": unraisable.object})\n\n    def get_connection_info(self) -&gt; dict[str, Any]:\n        \"\"\"Return the connection info as a dict.\"\"\"\n        with self.connection_file.open(\"r\") as f:\n            return json.load(f)\n\n    def get_parent(self) -&gt; Message[dict[str, Any]] | None:\n        \"\"\"\n        A convenience method to access the 'message' in the current context if there is one.\n\n        'parent' is the parameter name used by [Session.send][jupyter_client.session.Session.send] to provide context when sending a reply.\n\n        See also:\n            - [Kernel.iopub_send][Kernel.iopub_send]\n            - [ipywidgets.Output][ipywidgets.widgets.widget_output.Output]:\n                Uses `get_ipython().kernel.get_parent()` to obtain the `msg_id` which\n                is used to 'capture' output when its context has been acquired.\n        \"\"\"\n        return utils.get_parent()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.interface","title":"interface  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interface = Instance(BaseKernelInterface)\n</code></pre> <p>The abstraction to communicate with the kernel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.callers","title":"callers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>callers: Fixed[Self, dict[Literal[shell, control], Caller]] = Fixed(dict)\n</code></pre> <p>The callers associated with the kernel once it has started.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.subshell_manager","title":"subshell_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subshell_manager = Fixed(SubshellManager)\n</code></pre> <p>Dedicated to management of sub shells.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.help_links","title":"help_links  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help_links = Tuple()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.quiet","title":"quiet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quiet = Bool(True)\n</code></pre> <p>Only send stdout/stderr to output stream.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.print_kernel_messages","title":"print_kernel_messages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print_kernel_messages = Bool(True)\n</code></pre> <p>When enabled the kernel will print startup, shutdown and terminal errors.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.connection_file","title":"connection_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection_file: TraitType[Path, Path | str] = TraitType()\n</code></pre> <p>JSON file in which to store connection info </p> <p><code>\"kernel-&lt;pid&gt;.json\"</code></p> <p>This file will contain the IP, ports, and authentication key needed to connect clients to this kernel. By default, this file will be created in the security dir of the current profile, but can be specified by absolute path.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_name","title":"kernel_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_name = CUnicode()\n</code></pre> <p>The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log = Instance(LoggerAdapter)\n</code></pre> <p>The logging adapter.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.main_shell","title":"main_shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>main_shell = Fixed(lambda _: instance())\n</code></pre> <p>The interactive shell.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debugger","title":"debugger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debugger = Fixed(Debugger)\n</code></pre> <p>Handles debug requests.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_manager","title":"comm_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_manager = Fixed(CommManager)\n</code></pre> <p>Creates async_kernel.comm.Comm instances and maintains a mapping to <code>comm_id</code> to <code>Comm</code> instances.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.event_started","title":"event_started  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_started = Fixed(Event)\n</code></pre> <p>An event that occurs when the kernel is started.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.event_stopped","title":"event_stopped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_stopped = Fixed(Event)\n</code></pre> <p>An event that occurs when the kernel is stopped.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict[str, Any]\n</code></pre> <p>Settings that have been set to customise the behaviour of the kernel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shell","title":"shell  <code>property</code>","text":"<pre><code>shell: AsyncInteractiveShell | AsyncInteractiveSubshell\n</code></pre> <p>The shell given the current context.</p> Notes <ul> <li>The <code>subshell_id</code> of the main shell is <code>None</code>.</li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.caller","title":"caller  <code>property</code>","text":"<pre><code>caller: Caller\n</code></pre> <p>The caller for the shell channel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_info","title":"kernel_info  <code>property</code>","text":"<pre><code>kernel_info: dict[\n    str, str | dict[str, str | dict[str, str | int]] | Any | tuple[Any, ...] | bool\n]\n</code></pre> <p>A dict of detail sent in reply to for a 'kernel_info_request'.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_settings","title":"load_settings","text":"<pre><code>load_settings(settings: dict[str, Any]) -&gt; None\n</code></pre> <p>Load settings into the kernel.</p> <p>Permitted until the kernel async context has been entered.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def load_settings(self, settings: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Load settings into the kernel.\n\n    Permitted until the kernel async context has been entered.\n\n    Args:\n        settings:\n            key: dotted.path.of.attribute.\n            value: The value to set.\n    \"\"\"\n    if self.event_started:\n        msg = \"It is too late to load settings!\"\n        raise RuntimeError(msg)\n    settings_ = self._settings or {\"kernel_name\": self.kernel_name}\n    for k, v in settings.items():\n        settings_ |= utils.setattr_nested(self, k, v)\n    self._settings.update(settings_)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_settings(settings)","title":"<code>settings</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>key: dotted.path.of.attribute. value: The value to set.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_connection_info","title":"load_connection_info","text":"<pre><code>load_connection_info(info: dict[str, Any]) -&gt; None\n</code></pre> <p>Load connection info from a dict containing connection info.</p> <p>Typically this data comes from a connection file and is called by load_connection_file.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Load connection info from a dict containing connection info.\n\n    Typically this data comes from a connection file\n    and is called by load_connection_file.\n\n    Args:\n        info: Dictionary containing connection_info. See the connection_file spec for details.\n    \"\"\"\n    self.interface.load_connection_info(info)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_connection_info(info)","title":"<code>info</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary containing connection_info. See the connection_file spec for details.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.stop","title":"stop  <code>staticmethod</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>A staticmethod to stop the running kernel.</p> <p>Once an instance of a kernel is stopped the instance cannot be restarted. Instead a new instance should be started.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>@staticmethod\ndef stop() -&gt; None:\n    \"\"\"\n    A [staticmethod][] to stop the running kernel.\n\n    Once an instance of a kernel is stopped the instance cannot be restarted.\n    Instead a new instance should be started.\n    \"\"\"\n    if (instance := Kernel._instance) and (stop := getattr(instance, \"_stop\", None)):\n        stop()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.__asynccontextmanager__","title":"__asynccontextmanager__  <code>async</code>","text":"<pre><code>__asynccontextmanager__() -&gt; AsyncGenerator[Self]\n</code></pre> <p>Start the kernel in an already running anyio event loop.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>@asynccontextmanager\nasync def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n    \"\"\"Start the kernel in an already running anyio event loop.\"\"\"\n    assert self.main_shell\n    try:\n        async with self.interface:\n            self.callers.update(self.interface.callers)\n            with anyio.CancelScope() as scope:\n                self._stop = lambda: self.caller.call_direct(scope.cancel, \"Stopping kernel\")\n                sys.excepthook = self.excepthook\n                sys.unraisablehook = self.unraisablehook\n\n                self.comm_manager.patch_comm()\n                try:\n                    self.comm_manager.kernel = self\n                    self.event_started.set()\n                    self.log.info(\"Kernel started: %s\", self)\n                    yield self\n                except BaseException:\n                    if not scope.cancel_called:\n                        raise\n                finally:\n                    self.comm_manager.kernel = None\n                    self.event_stopped.set()\n    finally:\n        self.shell.reset(new_session=False)\n        self.subshell_manager.stop_all_subshells(force=True)\n        self.callers.clear()\n        Kernel._instance = None\n        AsyncInteractiveShell.clear_instance()\n        with anyio.CancelScope(shield=True):\n            await anyio.sleep(0.1)\n        self.log.info(\"Kernel stopped: %s\", self)\n        gc.collect()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: Message[dict[str, Any]] | dict[str, Any] | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send a message on the iopub socket.</p> Referenced by: <ul> <li> Reference <ul> <li> asyncshell <ul> <li> <code></code>\u00a0AsyncDisplayHook </li> <li> <code></code>\u00a0AsyncDisplayPublisher </li> <li> <code></code>\u00a0asyncshell </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0get_parent </li> </ul> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def iopub_send(\n    self,\n    msg_or_type: Message[dict[str, Any]] | dict[str, Any] | str,\n    *,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: Message[dict[str, Any]] | dict[str, Any] | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"Send a message on the iopub socket.\"\"\"\n    self.interface.iopub_send(\n        msg_or_type,\n        content=content,\n        metadata=metadata,\n        parent=parent,\n        ident=ident,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.topic","title":"topic","text":"<pre><code>topic(topic) -&gt; bytes\n</code></pre> <p>prefixed topic for IOPub messages.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def topic(self, topic) -&gt; bytes:\n    \"\"\"prefixed topic for IOPub messages.\"\"\"\n    return (f\"kernel.{topic}\").encode()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.msg_handler","title":"msg_handler","text":"<pre><code>msg_handler(\n    channel: Literal[shell, control],\n    msg_type: MsgType,\n    job: Job,\n    send_reply: Callable[[Job, dict], CoroutineType[Any, Any, None]],\n)\n</code></pre> <p>Schedule a message to be executed.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0RunMode </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def msg_handler(\n    self,\n    channel: Literal[Channel.shell, Channel.control],\n    msg_type: MsgType,\n    job: Job,\n    send_reply: Callable[[Job, dict], CoroutineType[Any, Any, None]],\n    /,\n):\n    \"\"\"Schedule a message to be executed.\"\"\"\n    # Note: There are never any active pending trackers in this context.\n    try:\n        subshell_id = job[\"msg\"][\"content\"][\"subshell_id\"]\n    except KeyError:\n        try:\n            subshell_id = job[\"msg\"][\"header\"][\"subshell_id\"]  # pyright: ignore[reportTypedDictNotRequiredAccess]\n        except KeyError:\n            subshell_id = None\n    handler = cache_wrap_handler(subshell_id, send_reply, self.run_handler, self.get_handler(msg_type))\n    run_mode = self.get_run_mode(msg_type, channel=channel, job=job)\n    match run_mode:\n        case RunMode.direct:\n            self.callers[channel].call_direct(handler, job)\n        case RunMode.queue:\n            self.callers[channel].queue_call(handler, job).trackers = ()  # A slight optimisation\n        case RunMode.task:\n            self.callers[channel].call_soon(handler, job)\n        case RunMode.thread:\n            self.callers[channel].to_thread(handler, job)\n    self.log.debug(\"%s %s %s %s\", msg_type, handler, run_mode, job)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler","title":"run_handler  <code>async</code>","text":"<pre><code>run_handler(\n    subshell_id: str | None,\n    send_reply: Callable[[Job, dict], CoroutineType[Any, Any, None]],\n    handler: HandlerType,\n    job: Job[dict],\n) -&gt; None\n</code></pre> <p>Asynchronously run a message handler for a given job, managing reply sending and execution state.</p> <p>Parameters:</p> Workflow <ul> <li>Sets the current job and subshell_id context variables.</li> <li>Sends a \"busy\" status message on the IOPub channel.</li> <li>Awaits the handler; if the handler returns a content dict, a reply is sent using send_reply.</li> <li>On exception, sends an error reply and logs the exception.</li> <li>Resets the job and subshell_id context variables.</li> <li>Sends an \"idle\" status message on the IOPub channel.</li> </ul> Notes <ul> <li>Replies are sent even if exceptions occur in the handler.</li> <li>The reply message type is derived from the original request type.</li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def run_handler(\n    self,\n    subshell_id: str | None,\n    send_reply: Callable[[Job, dict], CoroutineType[Any, Any, None]],\n    handler: HandlerType,\n    job: Job[dict],\n) -&gt; None:\n    \"\"\"\n    Asynchronously run a message handler for a given job, managing reply sending and execution state.\n\n    Args:\n        subshell_id: The id of the subshell to set the context of the handler.\n        send_reply: A coroutine function responsible for sending the reply.\n        handler: A coroutine function to handle the job / message.\n\n            - It is a method on the kernel whose name corresponds to the [message type that it handles][async_kernel.typing.MsgType].\n            - The handler should return a dict to use as 'content'in a reply.\n            - If status is not included in the dict it gets added automatically as `{'status': 'ok'}`.\n            - If a reply is not expected the handler should return `None`.\n\n        job: The job dictionary containing message, socket, and identification information.\n\n    Workflow:\n        - Sets the current job and subshell_id context variables.\n        - Sends a \"busy\" status message on the IOPub channel.\n        - Awaits the handler; if the handler returns a content dict, a reply is sent using send_reply.\n        - On exception, sends an error reply and logs the exception.\n        - Resets the job and subshell_id context variables.\n        - Sends an \"idle\" status message on the IOPub channel.\n\n    Notes:\n        - Replies are sent even if exceptions occur in the handler.\n        - The reply message type is derived from the original request type.\n    \"\"\"\n    job_token = utils._job_var.set(job)  # pyright: ignore[reportPrivateUsage]\n    subshell_token = ShellPendingManager._id_contextvar.set(subshell_id)  # pyright: ignore[reportPrivateUsage]\n\n    try:\n        self.iopub_send(\n            msg_or_type=\"status\",\n            parent=job[\"msg\"],\n            content={\"execution_state\": \"busy\"},\n            ident=self.topic(topic=\"status\"),\n        )\n        if (content := await handler(job)) is not None:\n            await send_reply(job, content)\n    except Exception as e:\n        await send_reply(job, utils.error_to_content(e))\n        self.log.exception(\"Exception in message handler:\", exc_info=e)\n    finally:\n        utils._job_var.reset(job_token)  # pyright: ignore[reportPrivateUsage]\n        ShellPendingManager._id_contextvar.reset(subshell_token)  # pyright: ignore[reportPrivateUsage]\n        self.iopub_send(\n            msg_or_type=\"status\",\n            parent=job[\"msg\"],\n            content={\"execution_state\": \"idle\"},\n            ident=self.topic(\"status\"),\n        )\n        del job\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(subshell_id)","title":"<code>subshell_id</code>","text":"(<code>str | None</code>)           \u2013            <p>The id of the subshell to set the context of the handler.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(send_reply)","title":"<code>send_reply</code>","text":"(<code>Callable[[Job, dict], CoroutineType[Any, Any, None]]</code>)           \u2013            <p>A coroutine function responsible for sending the reply.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(handler)","title":"<code>handler</code>","text":"(<code>HandlerType</code>)           \u2013            <p>A coroutine function to handle the job / message.</p> <ul> <li>It is a method on the kernel whose name corresponds to the message type that it handles.</li> <li>The handler should return a dict to use as 'content'in a reply.</li> <li>If status is not included in the dict it gets added automatically as <code>{'status': 'ok'}</code>.</li> <li>If a reply is not expected the handler should return <code>None</code>.</li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(job)","title":"<code>job</code>","text":"(<code>Job[dict]</code>)           \u2013            <p>The job dictionary containing message, socket, and identification information.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode","title":"get_run_mode","text":"<pre><code>get_run_mode(\n    msg_type: MsgType, *, channel: Literal[shell, control] = shell, job: Job | None = None\n) -&gt; RunMode\n</code></pre> <p>Determine the run mode for a given channel, message type and job.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RunMode</code>           \u2013            <p>The run mode for the message.</p> </li> </ul> Referenced by: <ul> <li> Reference typing <code></code>\u00a0RunMode </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_run_mode(\n    self,\n    msg_type: MsgType,\n    *,\n    channel: Literal[Channel.shell, Channel.control] = Channel.shell,\n    job: Job | None = None,\n) -&gt; RunMode:\n    \"\"\"\n    Determine the run mode for a given channel, message type and job.\n\n    Args:\n        channel: The channel the message was received on.\n        msg_type: The type of the message.\n        job: The job associated with the message, if any.\n\n    Returns:\n        The run mode for the message.\n    \"\"\"\n    # receive_msg_loop - DEBUG WARNING\n\n    # TODO: Are any of these options worth including?\n    # if mode_from_metadata := job[\"msg\"][\"metadata\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_metadata)\n    # if mode_from_header := job[\"msg\"][\"header\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_header)\n    match (channel, msg_type):\n        case _, MsgType.comm_msg:\n            return RunMode.queue\n        case Channel.control, MsgType.execute_request:\n            return RunMode.queue\n        case _, MsgType.execute_request:\n            if job:\n                if content := job[\"msg\"].get(\"content\", {}):\n                    if code := content.get(\"code\"):\n                        try:\n                            if (code := code.strip().split(\"\\n\", maxsplit=1)[0]).startswith((\"# \", \"##\")):\n                                return RunMode(code[2:])\n                            if code.startswith(\"RunMode.\"):\n                                return RunMode(code.removeprefix(\"RunMode.\"))\n                        except ValueError:\n                            pass\n                    if content.get(\"silent\"):\n                        return RunMode.task\n                if mode_ := set(utils.get_tags(job)).intersection(RunMode):\n                    return RunMode(next(iter(mode_)))\n            return RunMode.queue\n        case (\n            Channel.shell,\n            MsgType.shutdown_request\n            | MsgType.debug_request\n            | MsgType.create_subshell_request\n            | MsgType.delete_subshell_request\n            | MsgType.list_subshell_request,\n        ):\n            msg = f\"{msg_type=} not allowed on shell!\"\n            raise ValueError(msg)\n        case _, MsgType.debug_request:\n            return RunMode.queue\n        case (\n            _,\n            MsgType.complete_request\n            | MsgType.inspect_request\n            | MsgType.history_request\n            | MsgType.create_subshell_request\n            | MsgType.delete_subshell_request\n            | MsgType.is_complete_request,\n        ):\n            return RunMode.thread\n        case _:\n            pass\n    return RunMode.direct\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(channel)","title":"<code>channel</code>","text":"(<code>Literal[shell, control]</code>, default:                   <code>shell</code> )           \u2013            <p>The channel the message was received on.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(msg_type)","title":"<code>msg_type</code>","text":"(<code>MsgType</code>)           \u2013            <p>The type of the message.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(job)","title":"<code>job</code>","text":"(<code>Job | None</code>, default:                   <code>None</code> )           \u2013            <p>The job associated with the message, if any.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.all_concurrency_run_modes","title":"all_concurrency_run_modes","text":"<pre><code>all_concurrency_run_modes(\n    channels: Iterable[Literal[shell, control]] = (shell, control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"MsgType\", \"RunMode\"], tuple[Channel, MsgType, RunMode | None]\n]\n</code></pre> <p>Generates a dictionary containing all combinations of SocketID, and MsgType, along with their corresponding RunMode (if available).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def all_concurrency_run_modes(\n    self,\n    channels: Iterable[Literal[Channel.shell, Channel.control]] = (Channel.shell, Channel.control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"MsgType\", \"RunMode\"],\n    tuple[Channel, MsgType, RunMode | None],\n]:\n    \"\"\"\n    Generates a dictionary containing all combinations of SocketID, and MsgType, along with their\n    corresponding RunMode (if available).\n    \"\"\"\n    data: list[Any] = []\n    for channel in channels:\n        for msg_type in msg_types:\n            try:\n                mode = self.get_run_mode(msg_type, channel=channel)\n            except ValueError:\n                mode = None\n            data.append((channel, msg_type, mode))\n    data_ = zip(*data, strict=True)\n    return dict(zip([\"SocketID\", \"MsgType\", \"RunMode\"], data_, strict=True))\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_info_request","title":"kernel_info_request  <code>async</code>","text":"<pre><code>kernel_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a kernel info request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0kernel_info_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def kernel_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [kernel info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-info).\"\"\"\n    return self.kernel_info\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_info_request","title":"comm_info_request  <code>async</code>","text":"<pre><code>comm_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a comm info request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0comm_info_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [comm info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-info).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    target_name = c.get(\"target_name\", None)\n    comms = {\n        k: {\"target_name\": v.target_name}\n        for (k, v) in tuple(self.comm_manager.comms.items())\n        if v.target_name == target_name or target_name is None\n    }\n    return {\"comms\": comms}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execute_request","title":"execute_request  <code>async</code>","text":"<pre><code>execute_request(job: Job[ExecuteContent]) -&gt; Content\n</code></pre> <p>Handle a execute request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def execute_request(self, job: Job[ExecuteContent], /) -&gt; Content:\n    \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n    return await self.shell.execute_request(**job[\"msg\"][\"content\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.complete_request","title":"complete_request  <code>async</code>","text":"<pre><code>complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a completion request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0complete_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n    return await self.shell.do_complete_request(\n        code=job[\"msg\"][\"content\"].get(\"code\", \"\"), cursor_pos=job[\"msg\"][\"content\"].get(\"cursor_pos\", 0)\n    )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.is_complete_request","title":"is_complete_request  <code>async</code>","text":"<pre><code>is_complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a is_complete request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def is_complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n    return await self.shell.is_complete_request(job[\"msg\"][\"content\"].get(\"code\", \"\"))\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.inspect_request","title":"inspect_request  <code>async</code>","text":"<pre><code>inspect_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a inspect request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def inspect_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    return await self.shell.inspect_request(\n        code=c.get(\"code\", \"\"),\n        cursor_pos=c.get(\"cursor_pos\", 0),\n        detail_level=c.get(\"detail_level\", 0),\n    )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.history_request","title":"history_request  <code>async</code>","text":"<pre><code>history_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a history request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def history_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n    return await self.shell.history_request(**job[\"msg\"][\"content\"])\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_open","title":"comm_open  <code>async</code>","text":"<pre><code>comm_open(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm open request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_open(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm open request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#opening-a-comm).\"\"\"\n    self.comm_manager.comm_open(stream=None, ident=None, msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_msg","title":"comm_msg  <code>async</code>","text":"<pre><code>comm_msg(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm msg request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_msg(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm msg request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-messages).\"\"\"\n    self.comm_manager.comm_msg(stream=None, ident=None, msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_close","title":"comm_close  <code>async</code>","text":"<pre><code>comm_close(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm close request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_close(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm close request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#tearing-down-comms).\"\"\"\n    self.comm_manager.comm_close(stream=None, ident=None, msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.interrupt_request","title":"interrupt_request  <code>async</code>","text":"<pre><code>interrupt_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle an interrupt request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0interrupt_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def interrupt_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle an [interrupt request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-interrupt) (control only).\"\"\"\n    self.interface.interrupt()\n    return {}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shutdown_request","title":"shutdown_request  <code>async</code>","text":"<pre><code>shutdown_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a shutdown request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def shutdown_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [shutdown request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-shutdown) (control only).\"\"\"\n    self.stop()\n    return {\"restart\": job[\"msg\"][\"content\"].get(\"restart\", False)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debug_request","title":"debug_request  <code>async</code>","text":"<pre><code>debug_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a debug request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0list_subshell_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def debug_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [debug request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#debug-request) (control only).\"\"\"\n    return await self.debugger.process_request(job[\"msg\"][\"content\"])\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.create_subshell_request","title":"create_subshell_request  <code>async</code>","text":"<pre><code>create_subshell_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a create subshell request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def create_subshell_request(self: Kernel, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [create subshell request](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#create-subshell) (control only).\"\"\"\n\n    return {\"subshell_id\": self.subshell_manager.create_subshell(protected=False).subshell_id}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.delete_subshell_request","title":"delete_subshell_request  <code>async</code>","text":"<pre><code>delete_subshell_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a delete subshell request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def delete_subshell_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [delete subshell request](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#delete-subshell) (control only).\"\"\"\n    self.subshell_manager.delete_subshell(job[\"msg\"][\"content\"][\"subshell_id\"])\n    return {}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.list_subshell_request","title":"list_subshell_request  <code>async</code>","text":"<pre><code>list_subshell_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a list subshell request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def list_subshell_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [list subshell request](https://jupyter.org/enhancement-proposals/91-kernel-subshells/kernel-subshells.html#list-subshells) (control only).\"\"\"\n    return {\"subshell_id\": list(self.subshell_manager.list_subshells())}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.excepthook","title":"excepthook","text":"<pre><code>excepthook(etype, evalue, tb) -&gt; None\n</code></pre> <p>Handle an exception.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def excepthook(self, etype, evalue, tb) -&gt; None:\n    \"\"\"Handle an exception.\"\"\"\n    # write uncaught traceback to 'real' stderr, not zmq-forwarder\n    if self.print_kernel_messages:\n        traceback.print_exception(etype, evalue, tb, file=sys.__stderr__)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.unraisablehook","title":"unraisablehook","text":"<pre><code>unraisablehook(unraisable: UnraisableHookArgs) -&gt; None\n</code></pre> <p>Handle unraisable exceptions (during gc for instance).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def unraisablehook(self, unraisable: sys.UnraisableHookArgs, /) -&gt; None:\n    \"Handle unraisable exceptions (during gc for instance).\"\n    exc_info = (\n        unraisable.exc_type,\n        unraisable.exc_value or unraisable.exc_type(unraisable.err_msg),\n        unraisable.exc_traceback,\n    )\n    self.log.exception(unraisable.err_msg, exc_info=exc_info, extra={\"object\": unraisable.object})\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_connection_info","title":"get_connection_info","text":"<pre><code>get_connection_info() -&gt; dict[str, Any]\n</code></pre> <p>Return the connection info as a dict.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_connection_info(self) -&gt; dict[str, Any]:\n    \"\"\"Return the connection info as a dict.\"\"\"\n    with self.connection_file.open(\"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_parent","title":"get_parent","text":"<pre><code>get_parent() -&gt; Message[dict[str, Any]] | None\n</code></pre> <p>A convenience method to access the 'message' in the current context if there is one.</p> <p>'parent' is the parameter name used by Session.send to provide context when sending a reply.</p> See also <ul> <li>Kernel.iopub_send</li> <li>ipywidgets.Output:     Uses <code>get_ipython().kernel.get_parent()</code> to obtain the <code>msg_id</code> which     is used to 'capture' output when its context has been acquired.</li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_parent(self) -&gt; Message[dict[str, Any]] | None:\n    \"\"\"\n    A convenience method to access the 'message' in the current context if there is one.\n\n    'parent' is the parameter name used by [Session.send][jupyter_client.session.Session.send] to provide context when sending a reply.\n\n    See also:\n        - [Kernel.iopub_send][Kernel.iopub_send]\n        - [ipywidgets.Output][ipywidgets.widgets.widget_output.Output]:\n            Uses `get_ipython().kernel.get_parent()` to obtain the `msg_id` which\n            is used to 'capture' output when its context has been acquired.\n    \"\"\"\n    return utils.get_parent()\n</code></pre>"},{"location":"reference/kernelspec/","title":"kernelspec","text":"<p>Add and remove kernel specifications for Jupyter.</p> <p>Functions:</p> <ul> <li> <code>make_argv</code>             \u2013              <p>Returns an argument vector (argv) that can be used to start a <code>Kernel</code>.</p> </li> <li> <code>write_kernel_spec</code>             \u2013              <p>Write a kernel spec for launching a kernel ref.</p> </li> <li> <code>get_kernel_dir</code>             \u2013              <p>The path to where kernel specs are stored for Jupyter.</p> </li> <li> <code>import_start_interface</code>             \u2013              <p>Import the kernel interface starter as defined in a kernel spec.</p> </li> </ul>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv","title":"make_argv","text":"<pre><code>make_argv(\n    *,\n    connection_file: str = \"{connection_file}\",\n    kernel_name: str = \"async\",\n    start_interface: str | InterfaceStartType = DEFAULT_START_INTERFACE,\n    fullpath: bool = True,\n    **kwargs: dict[str, Any],\n) -&gt; list[str]\n</code></pre> <p>Returns an argument vector (argv) that can be used to start a <code>Kernel</code>.</p> <p>This function returns a list of arguments can be used directly start a kernel with subprocess.Popen. It will always call command.command_line as a python module.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[str]</code> )          \u2013            <p>A list of command-line arguments to launch the kernel module.</p> </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def make_argv(\n    *,\n    connection_file: str = \"{connection_file}\",\n    kernel_name: str = \"async\",\n    start_interface: str | InterfaceStartType = DEFAULT_START_INTERFACE,\n    fullpath: bool = True,\n    **kwargs: dict[str, Any],\n) -&gt; list[str]:\n    \"\"\"Returns an argument vector (argv) that can be used to start a `Kernel`.\n\n    This function returns a list of arguments can be used directly start a kernel with [subprocess.Popen][].\n    It will always call [command.command_line][] as a python module.\n\n    Args:\n        connection_file: The path to the connection file.\n        start_interface: Either the kernel factory object itself, or the string import path to a\n            callable that returns a non-started kernel.\n        kernel_name: The name of the kernel to use.\n        fullpath: If True the full path to the executable is used, otherwise 'python' is used.\n        **kwargs: Additional settings to pass when creating the kernel passed to `start_interface`.\n\n    Returns:\n        list: A list of command-line arguments to launch the kernel module.\n    \"\"\"\n    argv = [(sys.executable if fullpath else \"python\"), \"-m\", \"async_kernel\", \"-f\", connection_file]\n    for k, v in ({\"start_interface\": start_interface, \"kernel_name\": kernel_name} | kwargs).items():\n        argv.append(f\"--{k}={v}\")\n    return argv\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(connection_file)","title":"<code>connection_file</code>","text":"(<code>str</code>, default:                   <code>'{connection_file}'</code> )           \u2013            <p>The path to the connection file.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(start_interface)","title":"<code>start_interface</code>","text":"(<code>str | InterfaceStartType</code>, default:                   <code>DEFAULT_START_INTERFACE</code> )           \u2013            <p>Either the kernel factory object itself, or the string import path to a callable that returns a non-started kernel.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(kernel_name)","title":"<code>kernel_name</code>","text":"(<code>str</code>, default:                   <code>'async'</code> )           \u2013            <p>The name of the kernel to use.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(fullpath)","title":"<code>fullpath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True the full path to the executable is used, otherwise 'python' is used.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional settings to pass when creating the kernel passed to <code>start_interface</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec","title":"write_kernel_spec","text":"<pre><code>write_kernel_spec(\n    path: Path | str | None = None,\n    *,\n    kernel_name: str = \"async\",\n    display_name: str = \"\",\n    fullpath: bool = False,\n    prefix: str = \"\",\n    start_interface: str | InterfaceStartType = DEFAULT_START_INTERFACE,\n    connection_file: str = \"{connection_file}\",\n    env: dict | None = None,\n    metadata: dict | None = None,\n    **kwargs: dict[str, Any],\n) -&gt; Path\n</code></pre> <p>Write a kernel spec for launching a kernel ref.</p> <p>Parameters:</p> <p>Example passing a callable start_interface:</p> <pre><code>When `start_interface` is passed as a callable, the callable is stored in the file\n'kernel_spec.py' inside the kernelspec folder.\n\n```python\nimport async_kernel.kernelspec\n\n\ndef start_interface(settings):\n    from async_kernel import Kernel\n\n    class MyKernel(Kernel):\n        async def execute_request(self, job):\n            print(job)\n            return await super().execute_request(job)\n\n    return MyKernel(settings)\n\n\nasync_kernel.kernelspec.write_kernel_spec(\n    kernel_name=\"async-print-job\", start_interface=start_interface\n)\n```\n\nWarning:\n    Moving the spec folder will break the import which is stored as an absolute path.\n</code></pre> Referenced by: <ul> <li> Usage Command line and kernel configuration Backend options Custom arguments </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def write_kernel_spec(\n    path: Path | str | None = None,\n    *,\n    kernel_name: str = \"async\",\n    display_name: str = \"\",\n    fullpath: bool = False,\n    prefix: str = \"\",\n    start_interface: str | InterfaceStartType = DEFAULT_START_INTERFACE,\n    connection_file: str = \"{connection_file}\",\n    env: dict | None = None,\n    metadata: dict | None = None,\n    **kwargs: dict[str, Any],\n) -&gt; Path:\n    \"\"\"\n    Write a kernel spec for launching a kernel [ref](https://jupyter-client.readthedocs.io/en/stable/kernels.html#kernel-specs).\n\n    Args:\n        path: The path where to write the spec.\n        kernel_name: The name of the kernel to use.\n        display_name: The display name for Jupyter to use for the kernel. The default is `\"Python ({kernel_name})\"`.\n        fullpath: If True the full path to the executable is used, otherwise 'python' is used.\n        prefix: given, the kernelspec will be installed to PREFIX/share/jupyter/kernels/KERNEL_NAME.\n            This can be sys.prefix for installation inside virtual or conda envs.\n        start_interface: The string import path to a callable that creates the Kernel or,\n            a *self-contained* function that returns an instance of a `Kernel`.\n        connection_file: The path to the connection file.\n        env: A mapping environment variables for the kernel to set prior to starting.\n        metadata: A mapping of additional attributes to aid the client in kernel selection.\n        **kwargs: Pass additional settings to set on the instance of the `Kernel` when it is instantiated.\n            Each setting should correspond to the dotted path to the attribute relative to the kernel.\n            For example `..., **{'shell.timeout'=0.1})`.\n\n    Example passing a callable start_interface:\n\n        When `start_interface` is passed as a callable, the callable is stored in the file\n        'kernel_spec.py' inside the kernelspec folder.\n\n        ```python\n        import async_kernel.kernelspec\n\n\n        def start_interface(settings):\n            from async_kernel import Kernel\n\n            class MyKernel(Kernel):\n                async def execute_request(self, job):\n                    print(job)\n                    return await super().execute_request(job)\n\n            return MyKernel(settings)\n\n\n        async_kernel.kernelspec.write_kernel_spec(\n            kernel_name=\"async-print-job\", start_interface=start_interface\n        )\n        ```\n\n        Warning:\n            Moving the spec folder will break the import which is stored as an absolute path.\n    \"\"\"\n\n    assert re.match(re.compile(r\"^[a-z0-9._\\-]+$\", re.IGNORECASE), kernel_name)\n    path = Path(path) if path else (get_kernel_dir(prefix) / kernel_name)\n    # stage resources\n    try:\n        path.mkdir(parents=True, exist_ok=True)\n        if callable(start_interface):\n            path.joinpath(\"start_interface.py\").write_text(textwrap.dedent(inspect.getsource(start_interface)))\n            start_interface = f\"{path}{CUSTOM_KERNEL_MARKER}{start_interface.__name__}\"\n        # validate\n        if start_interface != DEFAULT_START_INTERFACE:\n            import_start_interface(start_interface)\n        shutil.copytree(src=RESOURCES, dst=path, dirs_exist_ok=True)\n\n        argv = make_argv(\n            start_interface=start_interface,\n            connection_file=connection_file,\n            kernel_name=kernel_name,\n            fullpath=fullpath,\n            **kwargs,\n        )\n        spec = {\n            \"argv\": argv,\n            \"env\": env or {},\n            \"display_name\": display_name or f\"Python ({kernel_name})\",\n            \"language\": \"python\",\n            \"interrupt_mode\": \"message\",\n            \"metadata\": metadata if metadata is not None else {\"debugger\": True, \"concurrent\": True},\n            \"kernel_protocol_version\": PROTOCOL_VERSION,\n        }\n\n        # write kernel.json\n        path.joinpath(\"kernel.json\").write_text(json.dumps(spec, indent=2))\n    except Exception:\n        shutil.rmtree(path, ignore_errors=True)\n        raise\n    else:\n        return path\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(path)","title":"<code>path</code>","text":"(<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path where to write the spec.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(kernel_name)","title":"<code>kernel_name</code>","text":"(<code>str</code>, default:                   <code>'async'</code> )           \u2013            <p>The name of the kernel to use.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(display_name)","title":"<code>display_name</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The display name for Jupyter to use for the kernel. The default is <code>\"Python ({kernel_name})\"</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(fullpath)","title":"<code>fullpath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True the full path to the executable is used, otherwise 'python' is used.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>given, the kernelspec will be installed to PREFIX/share/jupyter/kernels/KERNEL_NAME. This can be sys.prefix for installation inside virtual or conda envs.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(start_interface)","title":"<code>start_interface</code>","text":"(<code>str | InterfaceStartType</code>, default:                   <code>DEFAULT_START_INTERFACE</code> )           \u2013            <p>The string import path to a callable that creates the Kernel or, a self-contained function that returns an instance of a <code>Kernel</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(connection_file)","title":"<code>connection_file</code>","text":"(<code>str</code>, default:                   <code>'{connection_file}'</code> )           \u2013            <p>The path to the connection file.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(env)","title":"<code>env</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping environment variables for the kernel to set prior to starting.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(metadata)","title":"<code>metadata</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of additional attributes to aid the client in kernel selection.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Pass additional settings to set on the instance of the <code>Kernel</code> when it is instantiated. Each setting should correspond to the dotted path to the attribute relative to the kernel. For example <code>..., **{'shell.timeout'=0.1})</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.get_kernel_dir","title":"get_kernel_dir","text":"<pre><code>get_kernel_dir(prefix: str = '') -&gt; Path\n</code></pre> <p>The path to where kernel specs are stored for Jupyter.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def get_kernel_dir(prefix: str = \"\") -&gt; Path:\n    \"\"\"\n    The path to where kernel specs are stored for Jupyter.\n\n    Args:\n        prefix: Defaults to sys.prefix (installable for a particular environment).\n    \"\"\"\n    return Path(prefix or sys.prefix) / \"share/jupyter/kernels\"\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.get_kernel_dir(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Defaults to sys.prefix (installable for a particular environment).</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.import_start_interface","title":"import_start_interface","text":"<pre><code>import_start_interface(start_interface: str = '') -&gt; InterfaceStartType\n</code></pre> <p>Import the kernel interface starter as defined in a kernel spec.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>InterfaceStartType</code>           \u2013            <p>The kernel factory.</p> </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def import_start_interface(start_interface: str = \"\", /) -&gt; InterfaceStartType:\n    \"\"\"\n    Import the kernel interface starter as defined in a kernel spec.\n\n    Args:\n        start_interface: The name of the interface factory.\n\n    Returns:\n        The kernel factory.\n    \"\"\"\n\n    if CUSTOM_KERNEL_MARKER in start_interface:\n        path, factory_name = start_interface.split(CUSTOM_KERNEL_MARKER)\n        try:\n            sys.path.insert(0, path)\n            import start_interface as kf  # noqa: PLC0415\n\n            factory = getattr(kf, factory_name)\n            assert len(inspect.signature(factory).parameters) == 1\n            return factory\n        finally:\n            sys.path.remove(path)\n    from async_kernel.common import import_item  # noqa: PLC0415\n\n    return import_item(start_interface or DEFAULT_START_INTERFACE)\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.import_start_interface(start_interface)","title":"<code>start_interface</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the interface factory.</p>"},{"location":"reference/pending/","title":"pending","text":"<p>Classes:</p> <ul> <li> <code>PendingCancelled</code>           \u2013            <p>Used to indicate the pending is cancelled.</p> </li> <li> <code>InvalidStateError</code>           \u2013            <p>An invalid state of the pending.</p> </li> <li> <code>PendingTracker</code>           \u2013            <p>The base class for tracking Pending.</p> </li> <li> <code>PendingManager</code>           \u2013            <p>PendingManager is a class that can be used to capture the creation of async_kernel.pending.Pending</p> </li> <li> <code>PendingGroup</code>           \u2013            <p>An asynchronous context manager for tracking async_kernel.pending.Pending created in the context.</p> </li> <li> <code>Pending</code>           \u2013            <p>A thread-safe, cancellable, awaitable object representing a pending asynchronous result.</p> </li> </ul>"},{"location":"reference/pending/#async_kernel.pending.PendingCancelled","title":"PendingCancelled","text":"<p>               Bases: <code>ClosedResourceError</code></p> <p>Used to indicate the pending is cancelled.</p> Raised by: <ul> <li> Reference pending <code></code>\u00a0Pending <ul> <li> <code></code>\u00a0exception </li> <li> <code></code>\u00a0result </li> <li> <code></code>\u00a0wait </li> <li> <code></code>\u00a0wait_sync </li> </ul> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class PendingCancelled(anyio.ClosedResourceError):\n    \"Used to indicate the pending is cancelled.\"\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.InvalidStateError","title":"InvalidStateError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An invalid state of the pending.</p> Raised by: <ul> <li> Reference pending <code></code>\u00a0Pending <code></code>\u00a0result </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class InvalidStateError(RuntimeError):\n    \"An invalid state of the pending.\"\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingTracker","title":"PendingTracker","text":"<p>The base class for tracking Pending.</p> Referenced by: <ul> <li> Reference pending \u00a0Pending \u00a0trackers </li> </ul> Returned by: <ul> <li> Reference pending \u00a0Pending \u00a0trackers </li> </ul> Subclassed by: <ul> <li> Reference <ul> <li> caller \u00a0PendingGroup </li> <li> pending <ul> <li> \u00a0PendingGroup </li> <li> \u00a0PendingManager </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> caller \u00a0Caller \u00a0schedule_call </li> <li> pending \u00a0Pending \u00a0__init__ </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>current</code>             \u2013              <p>The instance of the active tracker in the current context.</p> </li> <li> <code>active_id</code>             \u2013              <p>The id of the active tracker in the current context.</p> </li> <li> <code>add</code>             \u2013              <p>Track <code>Pending</code> until it is done.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>Fixed[Self, str]</code>)           \u2013            <p>The unique id of the pending tracker instance.</p> </li> <li> <code>pending</code>               (<code>set[Pending[Any]]</code>)           \u2013            <p>The pending currently associated with this instance.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class PendingTracker:\n    \"\"\"\n    The base class for tracking [Pending][async_kernel.pending.Pending].\n    \"\"\"\n\n    _subclasses: ClassVar[tuple[type[Self], ...]] = ()\n    _instances: ClassVar[weakref.WeakValueDictionary[str, Self]] = weakref.WeakValueDictionary()\n    _id_contextvar: ClassVar[contextvars.ContextVar[str | None]]\n    _pending: Fixed[Self, set[Pending[Any]]] = Fixed(set)\n\n    id: Fixed[Self, str] = Fixed(lambda _: str(uuid.uuid4()))\n    \"\"\"The unique id of the pending tracker instance.\"\"\"\n\n    @property\n    def pending(self) -&gt; set[Pending[Any]]:\n        \"The pending currently associated with this instance.\"\n        return self._pending.copy()\n\n    def __init_subclass__(cls) -&gt; None:\n        if cls.__name__ != \"PendingManager\":\n            PendingTracker._subclasses = (*cls._subclasses, cls)\n            # Each subclass is assigned a new context variable.\n            cls._id_contextvar = contextvars.ContextVar(f\"{cls.__module__}.{cls.__name__}\", default=None)\n        return super().__init_subclass__()\n\n    @classmethod\n    def current(cls) -&gt; Self | None:\n        \"The instance of the active tracker in the current context.\"\n        if (id_ := cls._id_contextvar.get()) and (current := cls._instances.get(id_)):\n            return current\n        return None\n\n    @classmethod\n    def active_id(cls) -&gt; str | None:\n        \"The id of the active tracker in the current context.\"\n        return cls._id_contextvar.get()\n\n    def __init__(self) -&gt; None:\n        self._instances[self.id] = self\n\n    def _activate(self) -&gt; Token[str | None]:\n        return self._id_contextvar.set(self.id)\n\n    def _deactivate(self, token: contextvars.Token[str | None]) -&gt; None:\n        self._id_contextvar.reset(token)\n\n    def add(self, pen: Pending) -&gt; None:\n        \"Track `Pending` until it is done.\"\n\n        if isinstance(self, pen.trackers) and (pen not in self._pending):\n            self._pending.add(pen)\n            pen.add_done_callback(self._on_pending_done)\n\n    def _on_pending_done(self, pen: Pending) -&gt; None:\n        \"A done_callback that is registered with pen when it is added (don't call directly).\"\n        self._pending.discard(pen)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingTracker.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Fixed[Self, str] = Fixed(lambda _: str(uuid4()))\n</code></pre> <p>The unique id of the pending tracker instance.</p>"},{"location":"reference/pending/#async_kernel.pending.PendingTracker.pending","title":"pending  <code>property</code>","text":"<pre><code>pending: set[Pending[Any]]\n</code></pre> <p>The pending currently associated with this instance.</p>"},{"location":"reference/pending/#async_kernel.pending.PendingTracker.current","title":"current  <code>classmethod</code>","text":"<pre><code>current() -&gt; Self | None\n</code></pre> <p>The instance of the active tracker in the current context.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>@classmethod\ndef current(cls) -&gt; Self | None:\n    \"The instance of the active tracker in the current context.\"\n    if (id_ := cls._id_contextvar.get()) and (current := cls._instances.get(id_)):\n        return current\n    return None\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingTracker.active_id","title":"active_id  <code>classmethod</code>","text":"<pre><code>active_id() -&gt; str | None\n</code></pre> <p>The id of the active tracker in the current context.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>@classmethod\ndef active_id(cls) -&gt; str | None:\n    \"The id of the active tracker in the current context.\"\n    return cls._id_contextvar.get()\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingTracker.add","title":"add","text":"<pre><code>add(pen: Pending) -&gt; None\n</code></pre> <p>Track <code>Pending</code> until it is done.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def add(self, pen: Pending) -&gt; None:\n    \"Track `Pending` until it is done.\"\n\n    if isinstance(self, pen.trackers) and (pen not in self._pending):\n        self._pending.add(pen)\n        pen.add_done_callback(self._on_pending_done)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingManager","title":"PendingManager","text":"<p>               Bases: <code>PendingTracker</code></p> <p>PendingManager is a class that can be used to capture the creation of async_kernel.pending.Pending in any specific context.</p> <p>This class can not be used directly and must be subclassed to be useful. For any subclass, there is only one active instance in that context.</p> <p>Notes:</p> <pre><code>- A subclass of [PendingManager][] is required to use its functionality.\n- Each subclass is assigned it's own context variable.\n    - This means that only one instance is ever active in a specific context at any time.\n- It is proportionally expensive to subclass PendingManager so it's usage should\n    be limited to cases where it is necessary to start and stop tracking from specific contexts.\n</code></pre> <p>Usage:</p> <pre><code>```python\nclass MyPendingManager(PendingManager):\n    \"Manages the context of ...\"\n\n\nm = MyPendingManager()\nm2 = MyPendingManager()\n\n# In one or more contexts\ntoken = m.activate()\ntry:\n    ...\n    try:\n        token2 = m2.activate()\n        pen = m2.caller.call_soon(lambda: 1 + 1)\n        assert pen in m2.pending\n        assert (\n            pen not in m.pending\n        ), \"pen is associated should only be associated with m2\"\n        ...\n    finally:\n        m2.deactivate(token2)\n\nfinally:\n    m.deactivate(token)\n```\n</code></pre> <p>Methods:</p> <ul> <li> <code>activate</code>             \u2013              <p>Start tracking <code>Pending</code> in the  current context.</p> </li> <li> <code>deactivate</code>             \u2013              <p>Stop tracking using the token.</p> </li> <li> <code>context</code>             \u2013              <p>A context manager to activate this instance.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class PendingManager(PendingTracker):\n    \"\"\"\n    PendingManager is a class that can be used to capture the creation of [async_kernel.pending.Pending][]\n    in any specific context.\n\n    This class can not be used directly and must be subclassed to be useful. For any\n    subclass, there is only one active instance in that context.\n\n    Notes:\n\n        - A subclass of [PendingManager][] is required to use its functionality.\n        - Each subclass is assigned it's own context variable.\n            - This means that only one instance is ever active in a specific context at any time.\n        - It is proportionally expensive to subclass PendingManager so it's usage should\n            be limited to cases where it is necessary to start and stop tracking from specific contexts.\n\n    Usage:\n\n        ```python\n        class MyPendingManager(PendingManager):\n            \"Manages the context of ...\"\n\n\n        m = MyPendingManager()\n        m2 = MyPendingManager()\n\n        # In one or more contexts\n        token = m.activate()\n        try:\n            ...\n            try:\n                token2 = m2.activate()\n                pen = m2.caller.call_soon(lambda: 1 + 1)\n                assert pen in m2.pending\n                assert (\n                    pen not in m.pending\n                ), \"pen is associated should only be associated with m2\"\n                ...\n            finally:\n                m2.deactivate(token2)\n\n        finally:\n            m.deactivate(token)\n        ```\n    \"\"\"\n\n    def activate(self) -&gt; contextvars.Token[str | None]:\n        \"\"\"\n        Start tracking `Pending` in the  current context.\n        \"\"\"\n        return self._activate()\n\n    def deactivate(self, token: contextvars.Token[str | None]) -&gt; None:\n        \"\"\"\n        Stop tracking using the token.\n\n        Args:\n            token: The token returned from [activate][].\n        \"\"\"\n        self._deactivate(token)\n\n    @contextlib.contextmanager\n    def context(self) -&gt; Generator[None, Any, None]:\n        \"\"\"A context manager to activate this instance.\"\"\"\n        token = self.activate()\n        try:\n            yield\n        finally:\n            self.deactivate(token)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingManager.activate","title":"activate","text":"<pre><code>activate() -&gt; Token[str | None]\n</code></pre> <p>Start tracking <code>Pending</code> in the  current context.</p> Referenced by: <ul> <li> Reference pending <code></code>\u00a0PendingManager <code></code>\u00a0deactivate </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def activate(self) -&gt; contextvars.Token[str | None]:\n    \"\"\"\n    Start tracking `Pending` in the  current context.\n    \"\"\"\n    return self._activate()\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingManager.deactivate","title":"deactivate","text":"<pre><code>deactivate(token: Token[str | None]) -&gt; None\n</code></pre> <p>Stop tracking using the token.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def deactivate(self, token: contextvars.Token[str | None]) -&gt; None:\n    \"\"\"\n    Stop tracking using the token.\n\n    Args:\n        token: The token returned from [activate][].\n    \"\"\"\n    self._deactivate(token)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingManager.deactivate(token)","title":"<code>token</code>","text":"(<code>Token[str | None]</code>)           \u2013            <p>The token returned from activate.</p>"},{"location":"reference/pending/#async_kernel.pending.PendingManager.context","title":"context","text":"<pre><code>context() -&gt; Generator[None, Any, None]\n</code></pre> <p>A context manager to activate this instance.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>@contextlib.contextmanager\ndef context(self) -&gt; Generator[None, Any, None]:\n    \"\"\"A context manager to activate this instance.\"\"\"\n    token = self.activate()\n    try:\n        yield\n    finally:\n        self.deactivate(token)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingGroup","title":"PendingGroup","text":"<p>               Bases: <code>PendingTracker</code>, <code>AsyncContextManagerMixin</code></p> <p>An asynchronous context manager for tracking async_kernel.pending.Pending created in the context.</p> <p>If any pending is set with an exception, the pending group and all tracked pending will be cancelled. The context will exit once all registered pending are complete or when after the cancellation_timeout period has elapsed.</p> Features <ul> <li>The context will exit after all tracked pending are done or removed.</li> <li>Cancelled or failed pending will cancel all other pending in the group.</li> <li>Pending can be manually removed from the group while the group is active.</li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> Usage <p>Enter the async context and create new pending.</p> <pre><code>async with PendingGroup() as pg:\n    assert pg.caller.to_thread(lambda: None) in pg.pending\n</code></pre> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller </li> <li> pending <code></code>\u00a0Pending <code></code>\u00a0trackers </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>cancel</code>             \u2013              <p>Cancel the pending group (thread-safe).</p> </li> <li> <code>cancelled</code>             \u2013              <p>Return True if the pending group is cancelled.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cancellation_timeout</code>           \u2013            <p>The maximum time to wait for cancelled pending to be done.</p> </li> <li> <code>caller</code>               (<code>Fixed[Self, Caller]</code>)           \u2013            <p>The caller where the pending group was instantiated.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class PendingGroup(PendingTracker, anyio.AsyncContextManagerMixin):\n    \"\"\"\n    An asynchronous context manager for tracking [async_kernel.pending.Pending][] created in the context.\n\n    If any pending is set with an exception, the pending group and all tracked pending\n    will be cancelled. The context will exit once all registered pending are complete or\n    when after the [cancellation_timeout][] period has elapsed.\n\n    Features:\n        - The context will exit after all tracked pending are done or removed.\n        - Cancelled or failed pending will cancel all other pending in the group.\n        - Pending can be manually removed from the group while the group is active.\n\n    Args:\n        shield: [Shield][anyio.CancelScope.shield] from external cancellation.\n\n    Usage:\n        Enter the async context and create new pending.\n\n        ```python\n        async with PendingGroup() as pg:\n            assert pg.caller.to_thread(lambda: None) in pg.pending\n        ```\n    \"\"\"\n\n    _parent_id: None | str = None\n    _cancel_scope: anyio.CancelScope\n    _cancelled: str | None = None\n    _leaving_context: bool = False\n    _failed: Fixed[Self, list[Pending]] = Fixed(list)\n    cancellation_timeout = 10\n    \"The maximum time to wait for cancelled pending to be done.\"\n\n    caller: Fixed[Self, Caller] = Fixed(lambda _: async_kernel.Caller())\n    \"The caller where the pending group was instantiated.\"\n\n    def __init__(self, *, shield: bool = False) -&gt; None:\n        self.caller  # noqa: B018\n        self._shield = shield\n        super().__init__()\n\n    @override\n    def _activate(self) -&gt; Token[str | None]:\n        self._parent_id = None if (parent_id := self._id_contextvar.get()) == self.id else parent_id\n        return super()._activate()\n\n    @contextlib.asynccontextmanager\n    async def __asynccontextmanager__(self) -&gt; AsyncGenerator[Self]:\n        if self._leaving_context:\n            msg = f\"Re-entry of {self.__class__} is not supported!\"\n            raise InvalidStateError(msg)\n        self._cancel_scope = anyio.CancelScope(shield=self._shield)\n        self._all_done = create_async_event()\n        token = self._activate()\n        try:\n            with self._cancel_scope:\n                try:\n                    yield self\n                    self._leaving_context = True\n                    if self._pending:\n                        await self._all_done\n                except (anyio.get_cancelled_exc_class(), Exception) as e:\n                    self.cancel(f\"An error occurred: {e!r}\")\n                    raise\n            if self._cancelled is not None:\n                if exceptions := [e for pen in self._failed if isinstance(e := pen.exception(), Exception)]:\n                    msg = \"One or more exceptions occurred in this context!\"\n                    raise ExceptionGroup(msg, exceptions)\n                raise PendingCancelled(self._cancelled)\n        finally:\n            self._leaving_context = True\n            self._deactivate(token)\n            self._instances.pop(self.id, None)\n            if self._pending:\n                if self._all_done or self._all_done.cancelled():\n                    self._all_done = create_async_event()\n                if self._pending and not self._all_done:\n                    with anyio.CancelScope(shield=True), anyio.move_on_after(self.cancellation_timeout):\n                        await self._all_done\n\n    @override\n    def add(self, pen: Pending) -&gt; None:\n        if pen not in self._pending:\n            self._pending.add(pen)\n            pen.add_done_callback(self._on_pending_done)\n        if (id_ := self._parent_id) and (parent := self._instances.get(id_)):\n            parent.add(pen)\n\n    @override\n    def _on_pending_done(self, pen: Pending) -&gt; None:\n        try:\n            self._pending.remove(pen)\n            if not pen.cancelled() and (pen.exception()):\n                self._failed.append(pen)\n                self.cancel(f\"Exception in member: {pen}\")\n        except KeyError:\n            pass\n        if self._leaving_context and not self._pending:\n            self._all_done.set()\n\n    @enable_signal_safety\n    def cancel(self, msg: str | None = None) -&gt; bool:\n        \"Cancel the pending group (thread-safe).\"\n        self._cancelled = \"\\n\".join(((self._cancelled or \"\"), msg or \"\"))\n        if not self._cancel_scope.cancel_called:\n            self.caller.call_direct(self._cancel_scope.cancel, msg)\n            for pen_ in self.pending:\n                pen_.cancel(msg)\n        return self.cancelled()\n\n    def cancelled(self) -&gt; bool:\n        \"\"\"Return True if the pending group is cancelled.\"\"\"\n        return bool(self._cancelled)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingGroup(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield from external cancellation.</p>"},{"location":"reference/pending/#async_kernel.pending.PendingGroup.cancellation_timeout","title":"cancellation_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cancellation_timeout = 10\n</code></pre> <p>The maximum time to wait for cancelled pending to be done.</p> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0PendingGroup </li> <li> pending <code></code>\u00a0PendingGroup </li> </ul> </li> </ul>"},{"location":"reference/pending/#async_kernel.pending.PendingGroup.caller","title":"caller  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>caller: Fixed[Self, Caller] = Fixed(lambda _: Caller())\n</code></pre> <p>The caller where the pending group was instantiated.</p>"},{"location":"reference/pending/#async_kernel.pending.PendingGroup.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; bool\n</code></pre> <p>Cancel the pending group (thread-safe).</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>@enable_signal_safety\ndef cancel(self, msg: str | None = None) -&gt; bool:\n    \"Cancel the pending group (thread-safe).\"\n    self._cancelled = \"\\n\".join(((self._cancelled or \"\"), msg or \"\"))\n    if not self._cancel_scope.cancel_called:\n        self.caller.call_direct(self._cancel_scope.cancel, msg)\n        for pen_ in self.pending:\n            pen_.cancel(msg)\n    return self.cancelled()\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.PendingGroup.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Return True if the pending group is cancelled.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Return True if the pending group is cancelled.\"\"\"\n    return bool(self._cancelled)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending","title":"Pending","text":"<p>               Bases: <code>Awaitable[T]</code></p> <p>A thread-safe, cancellable, awaitable object representing a pending asynchronous result.</p> <p>The <code>Pending</code> class provides a mechanism for waiting on a result or exception to be set, either asynchronously or synchronously. It supports cancellation, metadata storage, and callback registration for completion events.</p> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> caller <ul> <li> <code></code>\u00a0Caller <code></code>\u00a0queue_call </li> <li> <code></code>\u00a0PendingGroup </li> <li> <code></code>\u00a0caller </li> </ul> </li> <li> pending <ul> <li> <code></code>\u00a0PendingGroup </li> <li> <code></code>\u00a0PendingManager </li> <li> <code></code>\u00a0PendingTracker </li> <li> <code></code>\u00a0pending </li> </ul> </li> </ul> </li> <li> Usage Usage Caller </li> </ul> Returned by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0as_completed </li> <li> <code></code>\u00a0call_later </li> <li> <code></code>\u00a0call_soon </li> <li> <code></code>\u00a0call_using_backend </li> <li> <code></code>\u00a0current_pending </li> <li> <code></code>\u00a0queue_call </li> <li> <code></code>\u00a0queue_get </li> <li> <code></code>\u00a0schedule_call </li> <li> <code></code>\u00a0to_thread </li> <li> <code></code>\u00a0wait </li> </ul> </li> <li> pending <code></code>\u00a0PendingTracker <code></code>\u00a0pending </li> </ul> </li> </ul> Used by: <ul> <li> Reference pending <code></code>\u00a0PendingTracker <code></code>\u00a0add </li> </ul> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Initializes a new Pending object with optional creation options and metadata.</p> </li> <li> <code>wait</code>             \u2013              <p>Wait for a result or exception to be set (thread-safe) returning the pending if specified.</p> </li> <li> <code>wait_sync</code>             \u2013              <p>Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.</p> </li> <li> <code>set_result</code>             \u2013              <p>Set the result (low-level-thread-safe).</p> </li> <li> <code>set_exception</code>             \u2013              <p>Set the exception (low-level-thread-safe).</p> </li> <li> <code>cancel</code>             \u2013              <p>Cancel the instance.</p> </li> <li> <code>cancelled</code>             \u2013              <p>Return True if the pending is cancelled.</p> </li> <li> <code>set_canceller</code>             \u2013              <p>Set a callback to handle cancellation (low-level).</p> </li> <li> <code>done</code>             \u2013              <p>Returns True if a result or exception has been set.</p> </li> <li> <code>add_done_callback</code>             \u2013              <p>Add a callback for when the pending is done (not thread-safe).</p> </li> <li> <code>remove_done_callback</code>             \u2013              <p>Remove all instances of a callback from the callbacks list.</p> </li> <li> <code>result</code>             \u2013              <p>Return the result.</p> </li> <li> <code>exception</code>             \u2013              <p>Return the exception.</p> </li> <li> <code>add_to_trackers</code>             \u2013              <p>Add this pending to the trackers active in the current context that are include.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>REPR_OMIT</code>               (<code>set[str]</code>)           \u2013            <p>Keys of metadata to omit when creating a repr of the instance.</p> </li> <li> <code>metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The metadata passed as keyword arguments to the instance during creation.</p> </li> <li> <code>trackers</code>               (<code>type[PendingTracker] | tuple[type[PendingTracker], ...]</code>)           \u2013            <p>A tuple of async_kernel.pending.PendingTracker subclasses that the pending is permitted to register with.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>class Pending(Awaitable[T]):\n    \"\"\"\n    A thread-safe, cancellable, awaitable object representing a pending asynchronous result.\n\n    The `Pending` class provides a mechanism for waiting on a result or exception to be set,\n    either asynchronously or synchronously. It supports cancellation, metadata storage, and\n    callback registration for completion events.\n    \"\"\"\n\n    __slots__ = [\n        \"__weakref__\",\n        \"_cancelled\",\n        \"_canceller\",\n        \"_done\",\n        \"_done_callbacks\",\n        \"_exception\",\n        \"_result\",\n        \"context\",\n        \"trackers\",\n    ]\n\n    REPR_OMIT: ClassVar[set[str]] = {\"func\", \"args\", \"kwargs\"}\n    \"Keys of metadata to omit when creating a repr of the instance.\"\n\n    _metadata_mappings: ClassVar[dict[int, dict[str, Any]]] = {}\n    \"A mapping of instance's id its metadata.\"\n\n    _cancelled: str | None\n    _canceller: Callable[[str | None], Any]\n    _exception: Exception\n    _done: bool\n    _result: T\n    context: contextvars.Context\n    trackers: type[PendingTracker] | tuple[type[PendingTracker], ...]\n    \"\"\"\n    A tuple of [async_kernel.pending.PendingTracker][] subclasses that the pending is permitted to register with.\n\n    Should be specified during init.\n\n    For some pending it may not make sense for it to be added to a [PendingGroup][]\n    Instead specify `PendingManager` instead of `PendingTracker`.\n    \"\"\"\n\n    @property\n    def metadata(self) -&gt; dict[str, Any]:\n        \"\"\"\n        The metadata passed as keyword arguments to the instance during creation.\n        \"\"\"\n        return self._metadata_mappings[id(self)]\n\n    def __init__(\n        self,\n        trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = (),\n        context: contextvars.Context | None = None,\n        **metadata: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initializes a new Pending object with optional creation options and metadata.\n\n        Args:\n            trackers: A subclass or tuple of `PendingTracker` subclasses to which the pending can be added given the context.\n            **metadata: Arbitrary keyword arguments containing metadata to associate with this Pending instance.\n                trackers: Enabled by default. To deactivate tracking pass `trackers=False`\n\n        Behavior:\n            - Initializes internal state for tracking completion and cancellation\n            - Stores provided metadata in a class-level mapping\n        \"\"\"\n        self._done_callbacks: deque[Callable[[Self], Any]] = deque()\n        self._metadata_mappings[id(self)] = metadata\n        self._done = False\n        self._cancelled = None\n        self.trackers = trackers\n\n        # A copy the context is required to avoid `PendingTracker.id` leakage.\n        self.context = context = context.copy() if context else contextvars.copy_context()\n\n        # PendingTacker registration.\n        for cls in PendingTracker._subclasses:  # pyright: ignore[reportPrivateUsage]\n            if id_ := context.get(cls._id_contextvar):  # pyright: ignore[reportPrivateUsage]\n                if trackers and issubclass(cls, trackers) and (tracker := PendingTracker._instances.get(id_)):  # pyright: ignore[reportPrivateUsage]\n                    tracker.add(self)\n                else:\n                    # Clear `PendingTracker.id`.\n                    context.run(cls._id_contextvar.set, None)  # pyright: ignore[reportPrivateUsage]\n\n    def __del__(self):\n        self._metadata_mappings.pop(id(self), None)\n\n    @override\n    def __repr__(self) -&gt; str:\n        rep = (\n            \"&lt;Pending\"\n            + ((\" \u26d4\" + (f\"message={self._cancelled!s}\" if self._cancelled else \"\")) if self.cancelled() else \"\")\n            + ((f\" \u2757 {e!r}\" if (e := getattr(self, \"_exception\", None)) else \" \ud83c\udfc1\") if self._done else \" \ud83c\udfc3\")\n        )\n        rep = f\"{rep} at {id(self)}\"\n        with contextlib.suppress(Exception):\n            if md := self.metadata:\n                rep = f\"{rep} metadata:\"\n                if \"func\" in md:\n                    items = [f\"{k}={truncated_rep.repr(v)}\" for k, v in md.items() if k not in self.REPR_OMIT]\n                    rep += f\" | {md['func']} {' | '.join(items) if items else ''}\"\n                else:\n                    rep += f\"{truncated_rep.repr(md)}\"\n        return rep + \" &gt;\"\n\n    @override\n    def __await__(self) -&gt; Generator[Any, None, T]:\n        return self.wait().__await__()\n\n    if TYPE_CHECKING:\n\n        @overload\n        async def wait(\n            self, *, timeout: float | None = ..., protect: bool = False | ..., result: Literal[True] = True\n        ) -&gt; T: ...\n\n        @overload\n        async def wait(self, *, timeout: float | None = ..., protect: bool = ..., result: Literal[False]) -&gt; None: ...\n\n    async def wait(self, *, timeout: float | None = None, protect: bool = False, result: bool = True) -&gt; T | None:\n        \"\"\"\n        Wait for a result or exception to be set (thread-safe) returning the pending if specified.\n\n        Args:\n            timeout: Timeout in seconds.\n            protect: Protect the instance from external cancellation.\n            result: Whether the result should be returned (use `result=False` to avoid exceptions raised by [Pending.result][]).\n\n        Raises:\n            TimeoutError: When the timeout expires and a result or exception has not been set.\n            PendingCancelled: If `result=True` and the pending has been cancelled.\n            Exception: If `result=True` and an exception was set on the pending.\n        \"\"\"\n        try:\n            if not self._done or self._done_callbacks:\n                event = create_async_event()\n                self._done_callbacks.appendleft(lambda _: event.set())\n                if not self._done or self._done_callbacks:\n                    if timeout is None:\n                        await event\n                    else:\n                        with anyio.fail_after(timeout):\n                            await event\n            else:\n                await async_checkpoint(force=True)\n            return self.result() if result else None\n        except (anyio.get_cancelled_exc_class(), TimeoutError) as e:\n            if not protect:\n                self.cancel(f\"Cancelled due to cancellation or timeout: {e}.\")\n            raise\n\n    if TYPE_CHECKING:\n\n        @overload\n        def wait_sync(self, *, timeout: float | None = ..., result: Literal[True] = True) -&gt; T: ...\n\n        @overload\n        def wait_sync(self, *, timeout: float | None = ..., result: Literal[False]) -&gt; None: ...\n\n    def wait_sync(self, *, timeout: float | None = None, result: bool = True) -&gt; T | None:\n        \"\"\"\n        Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.\n\n        Args:\n            timeout: Timeout in seconds.\n            result: Whether the result should be returned (use `result=False` to avoid exceptions raised by [Pending.result][]).\n\n        Raises:\n            TimeoutError: When the timeout expires and a result or exception has not been set.\n            PendingCancelled: If `result=True` and the pending has been cancelled.\n            Exception: If `result=True` and an exception was set on the pending.\n\n        Warning:\n            **Blocking the thread in which the result or exception is set will cause in deadlock.**\n        \"\"\"\n        if not self._done:\n            done = Event()\n            self._done_callbacks.appendleft(lambda _: done.set())\n            if not self._done:\n                done.wait(timeout)\n            if not self._done:\n                msg = f\"Timeout waiting for {self}\"\n                raise TimeoutError(msg)\n        else:\n            green_checkpoint(force=True)\n        return self.result() if result else None\n\n    def _set_done(self, mode: Literal[\"result\", \"exception\"], value) -&gt; None:\n        if self._done:\n            raise InvalidStateError\n        self._done = True\n        setattr(self, \"_\" + mode, value)\n        while self._done_callbacks:\n            cb = self._done_callbacks.pop()\n            try:\n                cb(self)\n            except Exception:\n                pass\n\n    def set_result(self, value: T, *, reset: bool = False) -&gt; None:\n        \"\"\"\n        Set the result (low-level-thread-safe).\n\n        Args:\n            value: The result.\n            reset: Revert to being not done.\n\n        Warning:\n            - When using reset ensure to proivide sufficient time for any waiters to retrieve the result.\n        \"\"\"\n        self._set_done(\"result\", value)\n        if reset:\n            self._done = False\n\n    def set_exception(self, exception: BaseException) -&gt; None:\n        \"\"\"\n        Set the exception (low-level-thread-safe).\n        \"\"\"\n        self._set_done(\"exception\", exception)\n\n    @enable_signal_safety\n    def cancel(self, msg: str | None = None, *, _force: bool = False) -&gt; bool:\n        \"\"\"\n        Cancel the instance.\n\n        Args:\n            msg: The message to use when cancelling.\n\n        Notes:\n            - Cancellation cannot be undone.\n            - The result will not be *done* until either [Pending.set_result][] or [Pending.set_exception][] is called.\n\n        Returns: If it has been cancelled.\n        \"\"\"\n        try:\n            if not self._done:\n                if (cancelled := self._cancelled or \"\") and msg:\n                    msg = f\"{cancelled}\\n{msg}\"\n                self._cancelled = msg or cancelled\n                if canceller := getattr(self, \"_canceller\", None):\n                    canceller(msg)\n            return self.cancelled()\n        finally:\n            if _force and not self._done:\n                self._set_done(\"result\", None)\n\n    def cancelled(self) -&gt; bool:\n        \"\"\"Return True if the pending is cancelled.\"\"\"\n        return self._cancelled is not None\n\n    def set_canceller(self, canceller: Callable[[str | None], Any]) -&gt; None:\n        \"\"\"\n        Set a callback to handle cancellation (low-level).\n\n        Args:\n            canceller: A callback that performs the cancellation of the pending.\n                - It must accept the cancellation message as the first argument.\n                - The cancellation call is not thread-safe.\n\n        Notes:\n            - `set_result` must be called to mark the pending as completed.\n\n        Example:\n            ```python\n            pen = Pending()\n            pen.cancel()\n            assert not pen.done()\n            pen.set_canceller(lambda msg: pen.set_result(None))\n            assert pen.done()\n            ```\n        \"\"\"\n        if self._done or hasattr(self, \"_canceller\"):\n            raise InvalidStateError\n        self._canceller = canceller\n        if self.cancelled():\n            self.cancel()\n\n    def done(self) -&gt; bool:\n        \"\"\"\n        Returns True if a result or exception has been set.\n        \"\"\"\n        return self._done\n\n    def add_done_callback(self, fn: Callable[[Self], Any]) -&gt; None:\n        \"\"\"\n        Add a callback for when the pending is done (not thread-safe).\n\n        If the pending is already done it will called immediately.\n        \"\"\"\n        if not self._done:\n            self._done_callbacks.append(fn)\n        else:\n            fn(self)\n\n    def remove_done_callback(self, fn: Callable[[Self], object], /) -&gt; int:\n        \"\"\"\n        Remove all instances of a callback from the callbacks list.\n\n        Returns the number of callbacks removed.\n        \"\"\"\n        n = 0\n        while fn in self._done_callbacks:\n            n += 1\n            self._done_callbacks.remove(fn)\n        return n\n\n    def result(self) -&gt; T:\n        \"\"\"\n        Return the result.\n\n        Raises:\n            PendingCancelled: If the pending has been cancelled.\n            InvalidStateError: If the pending isn't done yet.\n        \"\"\"\n        if e := self.exception():\n            raise e from None\n        try:\n            return self._result\n        except AttributeError:\n            raise InvalidStateError from None\n\n    def exception(self) -&gt; BaseException | None:\n        \"\"\"\n        Return the exception.\n\n        Raises:\n            PendingCancelled: If the instance has been cancelled.\n        \"\"\"\n        if self._cancelled is not None:\n            raise PendingCancelled(self._cancelled)\n        return getattr(self, \"_exception\", None)\n\n    def add_to_trackers(self) -&gt; Self:\n        \"\"\"\n        Add this pending to the trackers active in the current context that are include.\n        \"\"\"\n        if trackers := self.trackers:\n            for cls_ in PendingTracker._subclasses:  # pyright: ignore[reportPrivateUsage]\n                if (\n                    issubclass(cls_, trackers)\n                    and (id_ := cls_._id_contextvar.get())  # pyright: ignore[reportPrivateUsage]\n                    and (pm := PendingTracker._instances.get(id_))  # pyright: ignore[reportPrivateUsage]\n                ):\n                    pm.add(self)\n        return self\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.REPR_OMIT","title":"REPR_OMIT  <code>class-attribute</code>","text":"<pre><code>REPR_OMIT: set[str] = {'func', 'args', 'kwargs'}\n</code></pre> <p>Keys of metadata to omit when creating a repr of the instance.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre> <p>The metadata passed as keyword arguments to the instance during creation.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.trackers","title":"trackers  <code>instance-attribute</code>","text":"<pre><code>trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = trackers\n</code></pre> <p>A tuple of async_kernel.pending.PendingTracker subclasses that the pending is permitted to register with.</p> <p>Should be specified during init.</p> <p>For some pending it may not make sense for it to be added to a PendingGroup Instead specify <code>PendingManager</code> instead of <code>PendingTracker</code>.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.__init__","title":"__init__","text":"<pre><code>__init__(\n    trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = (),\n    context: Context | None = None,\n    **metadata: Any,\n) -&gt; None\n</code></pre> <p>Parameters:</p> Behavior <ul> <li>Initializes internal state for tracking completion and cancellation</li> <li>Stores provided metadata in a class-level mapping</li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def __init__(\n    self,\n    trackers: type[PendingTracker] | tuple[type[PendingTracker], ...] = (),\n    context: contextvars.Context | None = None,\n    **metadata: Any,\n) -&gt; None:\n    \"\"\"\n    Initializes a new Pending object with optional creation options and metadata.\n\n    Args:\n        trackers: A subclass or tuple of `PendingTracker` subclasses to which the pending can be added given the context.\n        **metadata: Arbitrary keyword arguments containing metadata to associate with this Pending instance.\n            trackers: Enabled by default. To deactivate tracking pass `trackers=False`\n\n    Behavior:\n        - Initializes internal state for tracking completion and cancellation\n        - Stores provided metadata in a class-level mapping\n    \"\"\"\n    self._done_callbacks: deque[Callable[[Self], Any]] = deque()\n    self._metadata_mappings[id(self)] = metadata\n    self._done = False\n    self._cancelled = None\n    self.trackers = trackers\n\n    # A copy the context is required to avoid `PendingTracker.id` leakage.\n    self.context = context = context.copy() if context else contextvars.copy_context()\n\n    # PendingTacker registration.\n    for cls in PendingTracker._subclasses:  # pyright: ignore[reportPrivateUsage]\n        if id_ := context.get(cls._id_contextvar):  # pyright: ignore[reportPrivateUsage]\n            if trackers and issubclass(cls, trackers) and (tracker := PendingTracker._instances.get(id_)):  # pyright: ignore[reportPrivateUsage]\n                tracker.add(self)\n            else:\n                # Clear `PendingTracker.id`.\n                context.run(cls._id_contextvar.set, None)  # pyright: ignore[reportPrivateUsage]\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.__init__(trackers)","title":"<code>trackers</code>","text":"(<code>type[PendingTracker] | tuple[type[PendingTracker], ...]</code>, default:                   <code>()</code> )           \u2013            <p>A subclass or tuple of <code>PendingTracker</code> subclasses to which the pending can be added given the context.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.__init__(**metadata)","title":"<code>**metadata</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Arbitrary keyword arguments containing metadata to associate with this Pending instance. trackers: Enabled by default. To deactivate tracking pass <code>trackers=False</code></p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    *,\n    timeout: float | None = ...,\n    protect: bool = False | ...,\n    result: Literal[True] = True,\n) -&gt; T\n</code></pre><pre><code>wait(*, timeout: float | None = ..., protect: bool = ..., result: Literal[False]) -&gt; None\n</code></pre> <pre><code>wait(\n    *, timeout: float | None = None, protect: bool = False, result: bool = True\n) -&gt; T | None\n</code></pre> <p>Wait for a result or exception to be set (thread-safe) returning the pending if specified.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>When the timeout expires and a result or exception has not been set.</p> </li> <li> <code>PendingCancelled</code>             \u2013            <p>If <code>result=True</code> and the pending has been cancelled.</p> </li> <li> <code>Exception</code>             \u2013            <p>If <code>result=True</code> and an exception was set on the pending.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>async def wait(self, *, timeout: float | None = None, protect: bool = False, result: bool = True) -&gt; T | None:\n    \"\"\"\n    Wait for a result or exception to be set (thread-safe) returning the pending if specified.\n\n    Args:\n        timeout: Timeout in seconds.\n        protect: Protect the instance from external cancellation.\n        result: Whether the result should be returned (use `result=False` to avoid exceptions raised by [Pending.result][]).\n\n    Raises:\n        TimeoutError: When the timeout expires and a result or exception has not been set.\n        PendingCancelled: If `result=True` and the pending has been cancelled.\n        Exception: If `result=True` and an exception was set on the pending.\n    \"\"\"\n    try:\n        if not self._done or self._done_callbacks:\n            event = create_async_event()\n            self._done_callbacks.appendleft(lambda _: event.set())\n            if not self._done or self._done_callbacks:\n                if timeout is None:\n                    await event\n                else:\n                    with anyio.fail_after(timeout):\n                        await event\n        else:\n            await async_checkpoint(force=True)\n        return self.result() if result else None\n    except (anyio.get_cancelled_exc_class(), TimeoutError) as e:\n        if not protect:\n            self.cancel(f\"Cancelled due to cancellation or timeout: {e}.\")\n        raise\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait(protect)","title":"<code>protect</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Protect the instance from external cancellation.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait(result)","title":"<code>result</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the result should be returned (use <code>result=False</code> to avoid exceptions raised by Pending.result).</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait_sync","title":"wait_sync","text":"<pre><code>wait_sync(*, timeout: float | None = ..., result: Literal[True] = True) -&gt; T\n</code></pre><pre><code>wait_sync(*, timeout: float | None = ..., result: Literal[False]) -&gt; None\n</code></pre> <pre><code>wait_sync(*, timeout: float | None = None, result: bool = True) -&gt; T | None\n</code></pre> <p>Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>When the timeout expires and a result or exception has not been set.</p> </li> <li> <code>PendingCancelled</code>             \u2013            <p>If <code>result=True</code> and the pending has been cancelled.</p> </li> <li> <code>Exception</code>             \u2013            <p>If <code>result=True</code> and an exception was set on the pending.</p> </li> </ul> Warning <p>Blocking the thread in which the result or exception is set will cause in deadlock.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def wait_sync(self, *, timeout: float | None = None, result: bool = True) -&gt; T | None:\n    \"\"\"\n    Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.\n\n    Args:\n        timeout: Timeout in seconds.\n        result: Whether the result should be returned (use `result=False` to avoid exceptions raised by [Pending.result][]).\n\n    Raises:\n        TimeoutError: When the timeout expires and a result or exception has not been set.\n        PendingCancelled: If `result=True` and the pending has been cancelled.\n        Exception: If `result=True` and an exception was set on the pending.\n\n    Warning:\n        **Blocking the thread in which the result or exception is set will cause in deadlock.**\n    \"\"\"\n    if not self._done:\n        done = Event()\n        self._done_callbacks.appendleft(lambda _: done.set())\n        if not self._done:\n            done.wait(timeout)\n        if not self._done:\n            msg = f\"Timeout waiting for {self}\"\n            raise TimeoutError(msg)\n    else:\n        green_checkpoint(force=True)\n    return self.result() if result else None\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait_sync(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait_sync(result)","title":"<code>result</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the result should be returned (use <code>result=False</code> to avoid exceptions raised by Pending.result).</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_result","title":"set_result","text":"<pre><code>set_result(value: T, *, reset: bool = False) -&gt; None\n</code></pre> <p>Set the result (low-level-thread-safe).</p> <p>Parameters:</p> Warning <ul> <li>When using reset ensure to proivide sufficient time for any waiters to retrieve the result.</li> </ul> Referenced by: <ul> <li> Reference pending <code></code>\u00a0Pending <code></code>\u00a0cancel </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def set_result(self, value: T, *, reset: bool = False) -&gt; None:\n    \"\"\"\n    Set the result (low-level-thread-safe).\n\n    Args:\n        value: The result.\n        reset: Revert to being not done.\n\n    Warning:\n        - When using reset ensure to proivide sufficient time for any waiters to retrieve the result.\n    \"\"\"\n    self._set_done(\"result\", value)\n    if reset:\n        self._done = False\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_result(value)","title":"<code>value</code>","text":"(<code>T</code>)           \u2013            <p>The result.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_result(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Revert to being not done.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_exception","title":"set_exception","text":"<pre><code>set_exception(exception: BaseException) -&gt; None\n</code></pre> <p>Set the exception (low-level-thread-safe).</p> Referenced by: <ul> <li> Reference pending <code></code>\u00a0Pending <code></code>\u00a0cancel </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def set_exception(self, exception: BaseException) -&gt; None:\n    \"\"\"\n    Set the exception (low-level-thread-safe).\n    \"\"\"\n    self._set_done(\"exception\", exception)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None, *, _force: bool = False) -&gt; bool\n</code></pre> <p>Cancel the instance.</p> <p>Parameters:</p> Notes <ul> <li>Cancellation cannot be undone.</li> <li>The result will not be done until either Pending.set_result or Pending.set_exception is called.</li> </ul> <p>Returns: If it has been cancelled.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>@enable_signal_safety\ndef cancel(self, msg: str | None = None, *, _force: bool = False) -&gt; bool:\n    \"\"\"\n    Cancel the instance.\n\n    Args:\n        msg: The message to use when cancelling.\n\n    Notes:\n        - Cancellation cannot be undone.\n        - The result will not be *done* until either [Pending.set_result][] or [Pending.set_exception][] is called.\n\n    Returns: If it has been cancelled.\n    \"\"\"\n    try:\n        if not self._done:\n            if (cancelled := self._cancelled or \"\") and msg:\n                msg = f\"{cancelled}\\n{msg}\"\n            self._cancelled = msg or cancelled\n            if canceller := getattr(self, \"_canceller\", None):\n                canceller(msg)\n        return self.cancelled()\n    finally:\n        if _force and not self._done:\n            self._set_done(\"result\", None)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.cancel(msg)","title":"<code>msg</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The message to use when cancelling.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Return True if the pending is cancelled.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Return True if the pending is cancelled.\"\"\"\n    return self._cancelled is not None\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_canceller","title":"set_canceller","text":"<pre><code>set_canceller(canceller: Callable[[str | None], Any]) -&gt; None\n</code></pre> <p>Set a callback to handle cancellation (low-level).</p> <p>Parameters:</p> Notes <ul> <li><code>set_result</code> must be called to mark the pending as completed.</li> </ul> Example <pre><code>pen = Pending()\npen.cancel()\nassert not pen.done()\npen.set_canceller(lambda msg: pen.set_result(None))\nassert pen.done()\n</code></pre> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def set_canceller(self, canceller: Callable[[str | None], Any]) -&gt; None:\n    \"\"\"\n    Set a callback to handle cancellation (low-level).\n\n    Args:\n        canceller: A callback that performs the cancellation of the pending.\n            - It must accept the cancellation message as the first argument.\n            - The cancellation call is not thread-safe.\n\n    Notes:\n        - `set_result` must be called to mark the pending as completed.\n\n    Example:\n        ```python\n        pen = Pending()\n        pen.cancel()\n        assert not pen.done()\n        pen.set_canceller(lambda msg: pen.set_result(None))\n        assert pen.done()\n        ```\n    \"\"\"\n    if self._done or hasattr(self, \"_canceller\"):\n        raise InvalidStateError\n    self._canceller = canceller\n    if self.cancelled():\n        self.cancel()\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_canceller(canceller)","title":"<code>canceller</code>","text":"(<code>Callable[[str | None], Any]</code>)           \u2013            <p>A callback that performs the cancellation of the pending. - It must accept the cancellation message as the first argument. - The cancellation call is not thread-safe.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.done","title":"done","text":"<pre><code>done() -&gt; bool\n</code></pre> <p>Returns True if a result or exception has been set.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Returns True if a result or exception has been set.\n    \"\"\"\n    return self._done\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.add_done_callback","title":"add_done_callback","text":"<pre><code>add_done_callback(fn: Callable[[Self], Any]) -&gt; None\n</code></pre> <p>Add a callback for when the pending is done (not thread-safe).</p> <p>If the pending is already done it will called immediately.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def add_done_callback(self, fn: Callable[[Self], Any]) -&gt; None:\n    \"\"\"\n    Add a callback for when the pending is done (not thread-safe).\n\n    If the pending is already done it will called immediately.\n    \"\"\"\n    if not self._done:\n        self._done_callbacks.append(fn)\n    else:\n        fn(self)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.remove_done_callback","title":"remove_done_callback","text":"<pre><code>remove_done_callback(fn: Callable[[Self], object]) -&gt; int\n</code></pre> <p>Remove all instances of a callback from the callbacks list.</p> <p>Returns the number of callbacks removed.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def remove_done_callback(self, fn: Callable[[Self], object], /) -&gt; int:\n    \"\"\"\n    Remove all instances of a callback from the callbacks list.\n\n    Returns the number of callbacks removed.\n    \"\"\"\n    n = 0\n    while fn in self._done_callbacks:\n        n += 1\n        self._done_callbacks.remove(fn)\n    return n\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.result","title":"result","text":"<pre><code>result() -&gt; T\n</code></pre> <p>Return the result.</p> <p>Raises:</p> <ul> <li> <code>PendingCancelled</code>             \u2013            <p>If the pending has been cancelled.</p> </li> <li> <code>InvalidStateError</code>             \u2013            <p>If the pending isn't done yet.</p> </li> </ul> Referenced by: <ul> <li> Reference pending <code></code>\u00a0Pending <ul> <li> <code></code>\u00a0wait </li> <li> <code></code>\u00a0wait_sync </li> </ul> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def result(self) -&gt; T:\n    \"\"\"\n    Return the result.\n\n    Raises:\n        PendingCancelled: If the pending has been cancelled.\n        InvalidStateError: If the pending isn't done yet.\n    \"\"\"\n    if e := self.exception():\n        raise e from None\n    try:\n        return self._result\n    except AttributeError:\n        raise InvalidStateError from None\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.exception","title":"exception","text":"<pre><code>exception() -&gt; BaseException | None\n</code></pre> <p>Return the exception.</p> <p>Raises:</p> <ul> <li> <code>PendingCancelled</code>             \u2013            <p>If the instance has been cancelled.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def exception(self) -&gt; BaseException | None:\n    \"\"\"\n    Return the exception.\n\n    Raises:\n        PendingCancelled: If the instance has been cancelled.\n    \"\"\"\n    if self._cancelled is not None:\n        raise PendingCancelled(self._cancelled)\n    return getattr(self, \"_exception\", None)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.add_to_trackers","title":"add_to_trackers","text":"<pre><code>add_to_trackers() -&gt; Self\n</code></pre> <p>Add this pending to the trackers active in the current context that are include.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def add_to_trackers(self) -&gt; Self:\n    \"\"\"\n    Add this pending to the trackers active in the current context that are include.\n    \"\"\"\n    if trackers := self.trackers:\n        for cls_ in PendingTracker._subclasses:  # pyright: ignore[reportPrivateUsage]\n            if (\n                issubclass(cls_, trackers)\n                and (id_ := cls_._id_contextvar.get())  # pyright: ignore[reportPrivateUsage]\n                and (pm := PendingTracker._instances.get(id_))  # pyright: ignore[reportPrivateUsage]\n            ):\n                pm.add(self)\n    return self\n</code></pre>"},{"location":"reference/typing/","title":"typing","text":"<p>Classes:</p> <ul> <li> <code>Backend</code>           \u2013            <p>An enum of library names corresponding to anyio.</p> </li> <li> <code>Loop</code>           \u2013            <p>An enum of event loop names that available to start using detail.</p> </li> <li> <code>Channel</code>           \u2013            <p>An enum of channel names Ref.</p> </li> <li> <code>RunMode</code>           \u2013            <p>An Enum of the run modes available for handling Messages.</p> </li> <li> <code>MsgType</code>           \u2013            <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> </li> <li> <code>Tags</code>           \u2013            <p>Tags recognised by the shell.</p> </li> <li> <code>CallerState</code>           \u2013            <p>The State of a async_kernel.caller.Caller.</p> </li> <li> <code>MsgHeader</code>           \u2013            <p>A message header.</p> </li> <li> <code>Message</code>           \u2013            <p>A message.</p> </li> <li> <code>Job</code>           \u2013            <p>A <code>Message</code> bundle.</p> </li> <li> <code>ExecuteContent</code>           \u2013            <p>Ref.</p> </li> <li> <code>FixedCreate</code>           \u2013            <p>A TypedDict relevant to Fixed.</p> </li> <li> <code>FixedCreated</code>           \u2013            <p>A TypedDict relevant to Fixed.</p> </li> <li> <code>RunSettings</code>           \u2013            <p>A dict of settings to use with async_kernel.event_loop.run.</p> </li> <li> <code>CallerCreateOptions</code>           \u2013            <p>Options to use when creating an instance of a Caller.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>NoValue</code>           \u2013            <p>A sentinel to indicate a value has not been provided.</p> </li> <li> <code>DebugMessage</code>           \u2013            <p>A TypeAlias for a debug message.</p> </li> <li> <code>Content</code>           \u2013            <p>A TypeAlias for the content in <code>Message</code>.</p> </li> <li> <code>HandlerType</code>           \u2013            <p>A TypeAlias for the handler of message requests.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.NoValue","title":"NoValue  <code>module-attribute</code>","text":"<pre><code>NoValue = Sentinel('NoValue')\n</code></pre> <p>A sentinel to indicate a value has not been provided.</p> Used by: <ul> <li> Reference <ul> <li> asyncshell <code></code>\u00a0SubshellManager <code></code>\u00a0get_shell </li> <li> caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0as_completed </li> <li> <code></code>\u00a0schedule_call </li> </ul> </li> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0iopub_send </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0iopub_send </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.DebugMessage","title":"DebugMessage  <code>module-attribute</code>","text":"<pre><code>DebugMessage = dict[str, Any]\n</code></pre> <p>A TypeAlias for a debug message.</p> Used by: <ul> <li> Reference debugger <code></code>\u00a0Debugger <ul> <li> <code></code>\u00a0do_attach </li> <li> <code></code>\u00a0do_configuration_done </li> <li> <code></code>\u00a0do_debug_info </li> <li> <code></code>\u00a0do_dump_cell </li> <li> <code></code>\u00a0do_initialize </li> <li> <code></code>\u00a0do_inspect_variables </li> <li> <code></code>\u00a0do_modules </li> <li> <code></code>\u00a0do_rich_inspect_variables </li> <li> <code></code>\u00a0do_set_breakpoints </li> <li> <code></code>\u00a0do_source </li> <li> <code></code>\u00a0do_stack_trace </li> <li> <code></code>\u00a0do_variables </li> <li> <code></code>\u00a0process_request </li> <li> <code></code>\u00a0send_dap_request </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Content","title":"Content  <code>module-attribute</code>","text":"<pre><code>Content = dict[str, Any]\n</code></pre> <p>A TypeAlias for the content in <code>Message</code>.</p> Notes <ul> <li>The content of a message handler can provide 'buffers'. When present,      the buffers are extracted from dict and handled separately by the interface.</li> </ul> Returned by: <ul> <li> Reference <ul> <li> asyncshell <code></code>\u00a0AsyncInteractiveShell <ul> <li> <code></code>\u00a0do_complete_request </li> <li> <code></code>\u00a0execute_request </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0is_complete_request </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0comm_info_request </li> <li> <code></code>\u00a0complete_request </li> <li> <code></code>\u00a0create_subshell_request </li> <li> <code></code>\u00a0debug_request </li> <li> <code></code>\u00a0delete_subshell_request </li> <li> <code></code>\u00a0execute_request </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0interrupt_request </li> <li> <code></code>\u00a0is_complete_request </li> <li> <code></code>\u00a0kernel_info_request </li> <li> <code></code>\u00a0list_subshell_request </li> <li> <code></code>\u00a0shutdown_request </li> </ul> </li> <li> typing <code></code>\u00a0Message <code></code>\u00a0content </li> <li> utils <code></code>\u00a0error_to_content </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0iopub_send </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0comm_close </li> <li> <code></code>\u00a0comm_info_request </li> <li> <code></code>\u00a0comm_msg </li> <li> <code></code>\u00a0comm_open </li> <li> <code></code>\u00a0complete_request </li> <li> <code></code>\u00a0create_subshell_request </li> <li> <code></code>\u00a0debug_request </li> <li> <code></code>\u00a0delete_subshell_request </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0interrupt_request </li> <li> <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0is_complete_request </li> <li> <code></code>\u00a0kernel_info_request </li> <li> <code></code>\u00a0list_subshell_request </li> <li> <code></code>\u00a0shutdown_request </li> </ul> </li> <li> typing <code></code>\u00a0HandlerType </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.HandlerType","title":"HandlerType  <code>module-attribute</code>","text":"<pre><code>HandlerType = Callable[[Job], Awaitable[Content | None]]\n</code></pre> <p>A TypeAlias for the handler of message requests.</p> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0run_handler </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Backend","title":"Backend","text":"<p>               Bases: <code>StrEnum</code></p> <p>An enum of library names corresponding to anyio.</p> Referenced by: <ul> <li> Usage Command line and kernel configuration Backend </li> <li> Reference event_loop <ul> <li> <code></code>\u00a0run </li> <li> <code></code>\u00a0run </li> </ul> </li> </ul> Returned by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <code></code>\u00a0backend </li> <li> typing <code></code>\u00a0RunSettings <code></code>\u00a0backend </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0call_using_backend </li> <li> <code></code>\u00a0schedule_call </li> </ul> </li> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0backend </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0backend </li> </ul> </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>asyncio</code>           \u2013            <p>An asyncio style event loop.</p> </li> <li> <code>trio</code>           \u2013            <p>A trio style event loop.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class Backend(enum.StrEnum):\n    \"An enum of library names corresponding to anyio.\"\n\n    asyncio = \"asyncio\"\n    \"An asyncio style event loop.\"\n\n    trio = \"trio\"\n    \"A trio style event loop.\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Backend.asyncio","title":"asyncio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asyncio = 'asyncio'\n</code></pre> <p>An asyncio style event loop.</p> Referenced by: <ul> <li> Reference event_loop <code></code>\u00a0run </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Backend.trio","title":"trio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trio = 'trio'\n</code></pre> <p>A trio style event loop.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop","title":"Loop","text":"<p>               Bases: <code>StrEnum</code></p> <p>An enum of event loop names that available to start using detail.</p> Referenced by: <ul> <li> Reference event_loop <code></code>\u00a0run </li> </ul> Returned by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <code></code>\u00a0loop </li> <li> interface <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0loop </li> <li> typing <code></code>\u00a0RunSettings <code></code>\u00a0loop </li> </ul> </li> </ul> Used by: <ul> <li> Reference interface <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0loop </li> </ul> <p>Attributes:</p> <ul> <li> <code>tk</code>           \u2013            <p>An eventloop for tkinter.</p> </li> <li> <code>qt</code>           \u2013            <p>An event loop for Qt.</p> </li> <li> <code>gtk</code>           \u2013            <p>Not implemented GTK.</p> </li> <li> <code>wx</code>           \u2013            <p>Not implemented wxPython.</p> </li> <li> <code>osx</code>           \u2013            <p>Not implemented</p> </li> <li> <code>custom</code>           \u2013            <p>A custom loop that does is fit the other values.</p> </li> <li> <code>asyncio</code>           \u2013            <p>Provided for testing purposes only.</p> </li> <li> <code>trio</code>           \u2013            <p>Provided for testing purposes only.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class Loop(enum.StrEnum):\n    \"An enum of event loop names that available to start using [detail][async_kernel.event_loop.run.run].\"\n\n    tk = \"tk\"\n    \"An eventloop for [tkinter][].\"\n\n    qt = \"qt\"\n    \"An event loop for [Qt](https://wiki.qt.io/Qt_for_Python).\"\n\n    gtk = \"gtk\"\n    \"Not implemented [GTK](https://www.gtk.org/).\"\n\n    wx = \"wx\"\n    \"Not implemented [wxPython](https://wxpython.org/).\"\n\n    osx = \"osx\"\n    \"Not implemented\"\n\n    custom = \"custom\"\n    \"A custom loop that does is fit the other values.\"\n\n    asyncio = \"asyncio\"\n    \"Provided for testing purposes only.\"\n\n    trio = \"trio\"\n    \"Provided for testing purposes only.\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Loop.tk","title":"tk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tk = 'tk'\n</code></pre> <p>An eventloop for tkinter.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.qt","title":"qt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qt = 'qt'\n</code></pre> <p>An event loop for Qt.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.gtk","title":"gtk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gtk = 'gtk'\n</code></pre> <p>Not implemented GTK.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.wx","title":"wx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wx = 'wx'\n</code></pre> <p>Not implemented wxPython.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.osx","title":"osx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>osx = 'osx'\n</code></pre> <p>Not implemented</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.custom","title":"custom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom = 'custom'\n</code></pre> <p>A custom loop that does is fit the other values.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.asyncio","title":"asyncio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asyncio = 'asyncio'\n</code></pre> <p>Provided for testing purposes only.</p>"},{"location":"reference/typing/#async_kernel.typing.Loop.trio","title":"trio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trio = 'trio'\n</code></pre> <p>Provided for testing purposes only.</p>"},{"location":"reference/typing/#async_kernel.typing.Channel","title":"Channel","text":"<p>               Bases: <code>StrEnum</code></p> <p>An enum of channel names Ref.</p> Returned by: <ul> <li> Reference <ul> <li> interface <code></code>\u00a0ZMQKernelInterface <ul> <li> <code></code>\u00a0ports </li> <li> <code></code>\u00a0sockets </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0all_concurrency_run_modes </li> <li> typing <code></code>\u00a0Message <code></code>\u00a0channel </li> </ul> </li> </ul> Used by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0msg </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0msg </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>heartbeat</code>           \u2013            </li> <li> <code>shell</code>           \u2013            </li> <li> <code>stdin</code>           \u2013            </li> <li> <code>control</code>           \u2013            </li> <li> <code>iopub</code>           \u2013            </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class Channel(enum.StrEnum):\n    \"An enum of channel names [Ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introduction).\"\n\n    heartbeat = \"hb\"\n    \"\"\n    shell = \"shell\"\n    \"\"\n    stdin = \"stdin\"\n    \"\"\n    control = \"control\"\n    \"\"\n    iopub = \"iopub\"\n    \"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Channel.heartbeat","title":"heartbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>heartbeat = 'hb'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Channel.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = 'shell'\n</code></pre> Returned by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0callers </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0callers </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0callers </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0msg </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0msg </li> <li> <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0receive_msg_loop </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0msg_handler </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Channel.stdin","title":"stdin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stdin = 'stdin'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Channel.control","title":"control  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>control = 'control'\n</code></pre> Returned by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0callers </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0callers </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0callers </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> interface <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0receive_msg_loop </li> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0msg_handler </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Channel.iopub","title":"iopub  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub = 'iopub'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.RunMode","title":"RunMode","text":"<p>               Bases: <code>StrEnum</code></p> <p>An Enum of the run modes available for handling Messages.</p> <p>async_kernel.kernel.Kernel.msg_handler uses get_run_mode to map the message type and channel (<code>shell</code> or <code>control</code>) to the <code>RunMode</code>.</p> Cell overrides <p>The user can also specify an execution mode in execute requests.</p> <p>Top line comment:     <pre><code># task\n</code></pre>     or</p> <pre><code>```python\n##task\n```\n</code></pre> Returned by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>queue</code>           \u2013            <p>Run the message handler using async_kernel.caller.Caller.queue_call.</p> </li> <li> <code>task</code>           \u2013            <p>Run the message handler using async_kernel.caller.Caller.call_soon.</p> </li> <li> <code>thread</code>           \u2013            <p>Run the message handler using async_kernel.caller.Caller.to_thread to start use a 'worker'.</p> </li> <li> <code>direct</code>           \u2013            <p>Run the message handler using async_kernel.caller.Caller.call_direct.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class RunMode(enum.StrEnum):\n    \"\"\"\n    An Enum of the run modes available for handling [Messages][async_kernel.typing.Message].\n\n    [async_kernel.kernel.Kernel.msg_handler][] uses [get_run_mode][async_kernel.kernel.Kernel.get_run_mode]\n    to map the message type and channel (`shell` or `control`) to the `RunMode`.\n\n    Cell overrides:\n        The user can also specify an execution mode in execute requests.\n\n        Top line comment:\n            ```python\n            # task\n            ```\n            or\n\n            ```python\n            ##task\n            ```\n    \"\"\"\n\n    @override\n    def __str__(self):\n        return f\"# {self.name}\"\n\n    @override\n    def __eq__(self, value: object, /) -&gt; bool:\n        return str(value) in {self.name, str(self), repr(self)}\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n\n    queue = \"queue\"\n    \"Run the message handler using [async_kernel.caller.Caller.queue_call][].\"\n\n    task = \"task\"\n    \"Run the message handler using [async_kernel.caller.Caller.call_soon][].\"\n\n    thread = \"thread\"\n    \"Run the message handler using [async_kernel.caller.Caller.to_thread][] to start use a 'worker'.\"\n\n    direct = \"direct\"\n    \"\"\"\n    Run the message handler using [async_kernel.caller.Caller.call_direct][].\n\n    Warning: \n        - This mode runs directly in the caller scheduler as soon as it is received.\n        - Use this only for fast running high priority code.\n    \"\"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.RunMode.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue = 'queue'\n</code></pre> <p>Run the message handler using async_kernel.caller.Caller.queue_call.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task = 'task'\n</code></pre> <p>Run the message handler using async_kernel.caller.Caller.call_soon.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.thread","title":"thread  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>thread = 'thread'\n</code></pre> <p>Run the message handler using async_kernel.caller.Caller.to_thread to start use a 'worker'.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.direct","title":"direct  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direct = 'direct'\n</code></pre> <p>Run the message handler using async_kernel.caller.Caller.call_direct.</p> Warning <ul> <li>This mode runs directly in the caller scheduler as soon as it is received.</li> <li>Use this only for fast running high priority code.</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgType","title":"MsgType","text":"<p>               Bases: <code>StrEnum</code></p> <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> <p>Some message types are on the control channel only.</p> Referenced by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0run_handler </li> </ul> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0all_concurrency_run_modes </li> <li> typing <code></code>\u00a0MsgHeader <code></code>\u00a0msg_type </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0msg_handler </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>kernel_info_request</code>           \u2013            <p>async_kernel.kernel.Kernel.kernel_info_request</p> </li> <li> <code>comm_info_request</code>           \u2013            <p>async_kernel.kernel.Kernel.comm_info_request</p> </li> <li> <code>execute_request</code>           \u2013            <p>async_kernel.kernel.Kernel.execute_request</p> </li> <li> <code>complete_request</code>           \u2013            <p>async_kernel.kernel.Kernel.complete_request</p> </li> <li> <code>is_complete_request</code>           \u2013            <p>async_kernel.kernel.Kernel.is_complete_request</p> </li> <li> <code>inspect_request</code>           \u2013            <p>async_kernel.kernel.Kernel.inspect_request</p> </li> <li> <code>history_request</code>           \u2013            <p>async_kernel.kernel.Kernel.history_request</p> </li> <li> <code>comm_open</code>           \u2013            <p>async_kernel.kernel.Kernel.comm_open</p> </li> <li> <code>comm_msg</code>           \u2013            <p>async_kernel.kernel.Kernel.comm_msg</p> </li> <li> <code>comm_close</code>           \u2013            <p>async_kernel.kernel.Kernel.comm_close</p> </li> <li> <code>interrupt_request</code>           \u2013            <p>async_kernel.kernel.Kernel.interrupt_request (control channel only)</p> </li> <li> <code>shutdown_request</code>           \u2013            <p>async_kernel.kernel.Kernel.shutdown_request (control channel only)</p> </li> <li> <code>debug_request</code>           \u2013            <p>async_kernel.kernel.Kernel.debug_request (control channel only)</p> </li> <li> <code>create_subshell_request</code>           \u2013            <p>async_kernel.kernel.Kernel.create_subshell_request (control channel only)</p> </li> <li> <code>delete_subshell_request</code>           \u2013            <p>async_kernel.kernel.Kernel.delete_subshell_request (control channel only)</p> </li> <li> <code>list_subshell_request</code>           \u2013            <p>async_kernel.kernel.Kernel.debug_request (control channel only)</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class MsgType(enum.StrEnum):\n    \"\"\"\n    An enumeration of Message `msg_type` for [shell and control messages]( https://jupyter-client.readthedocs.io/en/stable/messaging.html#messages-on-the-shell-router-dealer-channel).\n\n    Some message types are on the [control channel](https://jupyter-client.readthedocs.io/en/stable/messaging.html#messages-on-the-control-router-dealer-channel) only.\n    \"\"\"\n\n    kernel_info_request = \"kernel_info_request\"\n    \"[async_kernel.kernel.Kernel.kernel_info_request][]\"\n\n    comm_info_request = \"comm_info_request\"\n    \"[async_kernel.kernel.Kernel.comm_info_request][]\"\n\n    execute_request = \"execute_request\"\n    \"[async_kernel.kernel.Kernel.execute_request][]\"\n\n    complete_request = \"complete_request\"\n    \"[async_kernel.kernel.Kernel.complete_request][]\"\n\n    is_complete_request = \"is_complete_request\"\n    \"[async_kernel.kernel.Kernel.is_complete_request][]\"\n\n    inspect_request = \"inspect_request\"\n    \"[async_kernel.kernel.Kernel.inspect_request][]\"\n\n    history_request = \"history_request\"\n    \"[async_kernel.kernel.Kernel.history_request][]\"\n\n    comm_open = \"comm_open\"\n    \"[async_kernel.kernel.Kernel.comm_open][]\"\n\n    comm_msg = \"comm_msg\"\n    \"[async_kernel.kernel.Kernel.comm_msg][]\"\n\n    comm_close = \"comm_close\"\n    \"[async_kernel.kernel.Kernel.comm_close][]\"\n\n    # Control\n    interrupt_request = \"interrupt_request\"\n    \"[async_kernel.kernel.Kernel.interrupt_request][] (control channel only)\"\n\n    shutdown_request = \"shutdown_request\"\n    \"[async_kernel.kernel.Kernel.shutdown_request][] (control channel only)\"\n\n    debug_request = \"debug_request\"\n    \"[async_kernel.kernel.Kernel.debug_request][] (control channel only)\"\n\n    create_subshell_request = \"create_subshell_request\"\n    \"[async_kernel.kernel.Kernel.create_subshell_request][] (control channel only)\"\n\n    delete_subshell_request = \"delete_subshell_request\"\n    \"[async_kernel.kernel.Kernel.delete_subshell_request][] (control channel only)\"\n\n    list_subshell_request = \"list_subshell_request\"\n    \"[async_kernel.kernel.Kernel.debug_request][] (control channel only)\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgType.kernel_info_request","title":"kernel_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_info_request = 'kernel_info_request'\n</code></pre> <p>async_kernel.kernel.Kernel.kernel_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_info_request","title":"comm_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_info_request = 'comm_info_request'\n</code></pre> <p>async_kernel.kernel.Kernel.comm_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.execute_request","title":"execute_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request = 'execute_request'\n</code></pre> <p>async_kernel.kernel.Kernel.execute_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.complete_request","title":"complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>complete_request = 'complete_request'\n</code></pre> <p>async_kernel.kernel.Kernel.complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.is_complete_request","title":"is_complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_complete_request = 'is_complete_request'\n</code></pre> <p>async_kernel.kernel.Kernel.is_complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.inspect_request","title":"inspect_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_request = 'inspect_request'\n</code></pre> <p>async_kernel.kernel.Kernel.inspect_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.history_request","title":"history_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_request = 'history_request'\n</code></pre> <p>async_kernel.kernel.Kernel.history_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_open","title":"comm_open  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_open = 'comm_open'\n</code></pre> <p>async_kernel.kernel.Kernel.comm_open</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_msg","title":"comm_msg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_msg = 'comm_msg'\n</code></pre> <p>async_kernel.kernel.Kernel.comm_msg</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_close","title":"comm_close  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_close = 'comm_close'\n</code></pre> <p>async_kernel.kernel.Kernel.comm_close</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.interrupt_request","title":"interrupt_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupt_request = 'interrupt_request'\n</code></pre> <p>async_kernel.kernel.Kernel.interrupt_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.shutdown_request","title":"shutdown_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shutdown_request = 'shutdown_request'\n</code></pre> <p>async_kernel.kernel.Kernel.shutdown_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.debug_request","title":"debug_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_request = 'debug_request'\n</code></pre> <p>async_kernel.kernel.Kernel.debug_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.create_subshell_request","title":"create_subshell_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>create_subshell_request = 'create_subshell_request'\n</code></pre> <p>async_kernel.kernel.Kernel.create_subshell_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.delete_subshell_request","title":"delete_subshell_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delete_subshell_request = 'delete_subshell_request'\n</code></pre> <p>async_kernel.kernel.Kernel.delete_subshell_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.list_subshell_request","title":"list_subshell_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list_subshell_request = 'list_subshell_request'\n</code></pre> <p>async_kernel.kernel.Kernel.debug_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.Tags","title":"Tags","text":"<p>               Bases: <code>StrEnum</code></p> <p>Tags recognised by the shell.</p> Info <p>Tags are can be added per cell.</p> <ul> <li>Jupyter: via the right side bar.</li> <li>VScode: via Jupyter variables explorer</li> </ul> Used by: <ul> <li> Reference utils <code></code>\u00a0get_tag_value </li> </ul> <p>Attributes:</p> <ul> <li> <code>raises_exception</code>           \u2013            <p>Indicates the cell should expect an exception to be raised. </p> </li> <li> <code>suppress_error</code>           \u2013            <p>Suppress exceptions that occur during execution of the code cell.</p> </li> <li> <code>stop_on_error</code>           \u2013            <p>Override <code>stop_on_error</code>.</p> </li> <li> <code>timeout</code>           \u2013            <p>Specify a timeout in seconds for code execution to complete.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class Tags(enum.StrEnum):\n    \"\"\"\n    Tags recognised by the [shell][async_kernel.asyncshell.AsyncInteractiveShell].\n\n    Info:\n        Tags are can be added per cell.\n\n        - Jupyter: via the [right side bar](https://jupyterlab.readthedocs.io/en/stable/user/interface.html#left-and-right-sidebar).\n        - VScode: via [Jupyter variables explorer](https://code.visualstudio.com/docs/python/jupyter-support-py#_variables-explorer-and-data-viewer)\n    \"\"\"\n\n    @override\n    def __eq__(self, value: object, /) -&gt; bool:\n        return str(value).replace(\"-\", \"_\").split(\"=\")[0] == self.name\n\n    @override\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n\n    def get_bool(self, value: str | Tags, default: bool = True) -&gt; bool:\n        try:\n            return value.split(\"=\")[1].lower() == \"true\"\n        except Exception:\n            return default\n\n    def get_float(self, value: str | Tags, default: float = 0.0) -&gt; float:\n        try:\n            return float(value.split(\"=\")[1])\n        except Exception:\n            return default\n\n    def get_string(self, value: str | Tags, default: str = \"\") -&gt; str:\n        try:\n            return value.split(\"=\")[1]\n        except Exception:\n            return default\n\n    raises_exception = \"raises-exception\"\n    \"\"\"\n    Indicates the cell should expect an exception to be raised. \n\n    Notes:\n        - When an exception is raised, stop_on_error is False/\n        - When an exception is **not** raised an exception will be raise and stop_on_error is True.\n    \"\"\"\n\n    suppress_error = \"suppress-error\"\n    \"\"\"\n    Suppress exceptions that occur during execution of the code cell.\n\n    The default message is '\u26a0'\n\n    Examples:\n\n        - suppress-error \n        - suppress-error=The suppression message.\n\n    Warning:\n        The code block will return as 'ok' (not published).\n    \"\"\"\n\n    stop_on_error = \"stop-on-error\"\n    \"\"\"\n    Override `stop_on_error`.\n\n    Examples:\n\n        - True\n            - stop_on_error=true\n            - stop_on_error=True\n        - False\n            - stop_on_error=False\n    \"\"\"\n\n    timeout = \"timeout=\"\n    \"\"\"\n    Specify a timeout in seconds for code execution to complete.\n\n    Examples:\n\n        - timeout=0.0 (no timeout)\n        - timeout=0.1 (100 ms)\n    \"\"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Tags.raises_exception","title":"raises_exception  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raises_exception = 'raises-exception'\n</code></pre> <p>Indicates the cell should expect an exception to be raised. </p> Notes <ul> <li>When an exception is raised, stop_on_error is False/</li> <li>When an exception is not raised an exception will be raise and stop_on_error is True.</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Tags.suppress_error","title":"suppress_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error = 'suppress-error'\n</code></pre> <p>Suppress exceptions that occur during execution of the code cell.</p> <p>The default message is '\u26a0'</p> <p>Examples:</p> <pre><code>- suppress-error \n- suppress-error=The suppression message.\n</code></pre> Warning <p>The code block will return as 'ok' (not published).</p> Referenced by: <ul> <li> About Contributing Development Notebooks </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Tags.stop_on_error","title":"stop_on_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_on_error = 'stop-on-error'\n</code></pre> <p>Override <code>stop_on_error</code>.</p> <p>Examples:</p> <pre><code>- True\n    - stop_on_error=true\n    - stop_on_error=True\n- False\n    - stop_on_error=False\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Tags.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout = 'timeout='\n</code></pre> <p>Specify a timeout in seconds for code execution to complete.</p> <p>Examples:</p> <pre><code>- timeout=0.0 (no timeout)\n- timeout=0.1 (100 ms)\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.CallerState","title":"CallerState","text":"<p>               Bases: <code>Enum</code></p> <p>The State of a async_kernel.caller.Caller.</p> Returned by: <ul> <li> Reference caller <code></code>\u00a0Caller <code></code>\u00a0stop </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class CallerState(enum.Enum):\n    \"The State of a [async_kernel.caller.Caller][].\"\n\n    initial = enum.auto()\n    start_sync = enum.auto()\n    running = enum.auto()\n    stopping = enum.auto()\n    stopped = enum.auto()\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader","title":"MsgHeader","text":"<p>               Bases: <code>TypedDict</code></p> <p>A message header.</p> Returned by: <ul> <li> Reference typing <code></code>\u00a0Message <ul> <li> <code></code>\u00a0header </li> <li> <code></code>\u00a0parent_header </li> </ul> </li> </ul> Used by: <ul> <li> Reference interface <ul> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0msg </li> </ul> </li> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0msg </li> </ul> </li> <li> <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0iopub_send </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>msg_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>session</code>               (<code>str</code>)           \u2013            </li> <li> <code>username</code>               (<code>str</code>)           \u2013            </li> <li> <code>date</code>               (<code>str | datetime</code>)           \u2013            </li> <li> <code>msg_type</code>               (<code>MsgType | str</code>)           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> <li> <code>subshell_id</code>               (<code>NotRequired[str | None]</code>)           \u2013            </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class MsgHeader(TypedDict):\n    \"A [message header](https://jupyter-client.readthedocs.io/en/stable/messaging.html#message-header).\"\n\n    msg_id: str\n    \"\"\n    session: str\n    \"\"\n    username: str\n    \"\"\n    date: str | datetime.datetime\n    \"\"\n    msg_type: MsgType | str\n    \"\"\n    version: str\n    \"\"\n    subshell_id: NotRequired[str | None]\n    \"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_id","title":"msg_id  <code>instance-attribute</code>","text":"<pre><code>msg_id: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: str | datetime\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_type","title":"msg_type  <code>instance-attribute</code>","text":"<pre><code>msg_type: MsgType | str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.subshell_id","title":"subshell_id  <code>instance-attribute</code>","text":"<pre><code>subshell_id: NotRequired[str | None]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Message","title":"Message","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[T]</code></p> <p>A message.</p> Referenced by: <ul> <li> Reference typing <ul> <li> <code></code>\u00a0RunMode </li> <li> <code></code>\u00a0typing </li> </ul> </li> </ul> Returned by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0msg </li> <li> <code></code>\u00a0BaseKernelInterface <code></code>\u00a0msg </li> <li> <code></code>\u00a0CallableKernelInterface <code></code>\u00a0unpack </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0get_parent </li> <li> typing <code></code>\u00a0Job <code></code>\u00a0msg </li> <li> utils <code></code>\u00a0get_parent </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> interface <ul> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0msg </li> </ul> </li> <li> <code></code>\u00a0BaseKernelInterface <ul> <li> <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0msg </li> </ul> </li> <li> <code></code>\u00a0CallableKernelInterface <code></code>\u00a0pack </li> <li> <code></code>\u00a0ZMQKernelInterface <code></code>\u00a0iopub_send </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0iopub_send </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>channel</code>               (<code>Channel</code>)           \u2013            <p>The channel of the message.</p> </li> <li> <code>header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> <li> <code>parent_header</code>               (<code>MsgHeader | None</code>)           \u2013            <p>ref</p> </li> <li> <code>metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>ref</p> </li> <li> <code>content</code>               (<code>T | Content</code>)           \u2013            <p>ref</p> </li> <li> <code>buffers</code>               (<code>list[bytearray | bytes]</code>)           \u2013            </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class Message(TypedDict, Generic[T]):\n    \"A [message](https://jupyter-client.readthedocs.io/en/stable/messaging.html#general-message-format).\"\n\n    channel: Channel\n    \"The channel of the message.\"\n\n    header: MsgHeader\n    \"[ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#message-header)\"\n\n    parent_header: MsgHeader | None\n    \"[ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#parent-header)\"\n\n    metadata: dict[str, Any]\n    \"[ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#metadata)\"\n\n    content: T | Content\n    \"\"\"[ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#metadata)\n\n    See also:\n        - [ExecuteContent][]\n    \"\"\"\n    buffers: list[bytearray | bytes]\n    \"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Message.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: Channel\n</code></pre> <p>The channel of the message.</p>"},{"location":"reference/typing/#async_kernel.typing.Message.header","title":"header  <code>instance-attribute</code>","text":"<pre><code>header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.parent_header","title":"parent_header  <code>instance-attribute</code>","text":"<pre><code>parent_header: MsgHeader | None\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: T | Content\n</code></pre> <p>ref</p> See also <ul> <li>ExecuteContent</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.buffers","title":"buffers  <code>instance-attribute</code>","text":"<pre><code>buffers: list[bytearray | bytes]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job","title":"Job","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[T]</code></p> <p>A <code>Message</code> bundle.</p> Returned by: <ul> <li> Reference utils <code></code>\u00a0get_job </li> </ul> Used by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0comm_close </li> <li> <code></code>\u00a0comm_info_request </li> <li> <code></code>\u00a0comm_msg </li> <li> <code></code>\u00a0comm_open </li> <li> <code></code>\u00a0complete_request </li> <li> <code></code>\u00a0create_subshell_request </li> <li> <code></code>\u00a0debug_request </li> <li> <code></code>\u00a0delete_subshell_request </li> <li> <code></code>\u00a0execute_request </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0interrupt_request </li> <li> <code></code>\u00a0is_complete_request </li> <li> <code></code>\u00a0kernel_info_request </li> <li> <code></code>\u00a0list_subshell_request </li> <li> <code></code>\u00a0msg_handler </li> <li> <code></code>\u00a0run_handler </li> <li> <code></code>\u00a0shutdown_request </li> </ul> </li> <li> typing <code></code>\u00a0HandlerType </li> <li> utils <ul> <li> <code></code>\u00a0get_metadata </li> <li> <code></code>\u00a0get_parent </li> <li> <code></code>\u00a0get_tags </li> </ul> </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>msg</code>               (<code>Message[T]</code>)           \u2013            <p>The message received over the socket.</p> </li> <li> <code>ident</code>               (<code>bytes | list[bytes]</code>)           \u2013            <p>The ident associated with the message and its origin.</p> </li> <li> <code>received_time</code>               (<code>float</code>)           \u2013            <p>The time the message was received.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class Job(TypedDict, Generic[T]):\n    \"A `Message` bundle.\"\n\n    msg: Message[T]\n    \"The message received over the socket.\"\n\n    ident: bytes | list[bytes]\n    \"The ident associated with the message and its origin.\"\n\n    received_time: float\n    \"The time the message was received.\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: Message[T]\n</code></pre> <p>The message received over the socket.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.ident","title":"ident  <code>instance-attribute</code>","text":"<pre><code>ident: bytes | list[bytes]\n</code></pre> <p>The ident associated with the message and its origin.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.received_time","title":"received_time  <code>instance-attribute</code>","text":"<pre><code>received_time: float\n</code></pre> <p>The time the message was received.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent","title":"ExecuteContent","text":"<p>               Bases: <code>TypedDict</code></p> <p>Ref.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0Message <code></code>\u00a0content </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0execute_request </li> </ul> <p>Attributes:</p> <ul> <li> <code>code</code>               (<code>str</code>)           \u2013            <p>The code to execute.</p> </li> <li> <code>silent</code>               (<code>bool</code>)           \u2013            </li> <li> <code>store_history</code>               (<code>bool</code>)           \u2013            </li> <li> <code>user_expressions</code>               (<code>dict[str, str]</code>)           \u2013            </li> <li> <code>allow_stdin</code>               (<code>bool</code>)           \u2013            </li> <li> <code>stop_on_error</code>               (<code>bool</code>)           \u2013            </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class ExecuteContent(TypedDict):\n    \"[Ref](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\n\n    code: str\n    \"The code to execute.\"\n    silent: bool\n    \"\"\n    store_history: bool\n    \"\"\n    user_expressions: dict[str, str]\n    \"\"\n    allow_stdin: bool\n    \"\"\n    stop_on_error: bool\n    \"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>The code to execute.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.silent","title":"silent  <code>instance-attribute</code>","text":"<pre><code>silent: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.store_history","title":"store_history  <code>instance-attribute</code>","text":"<pre><code>store_history: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.user_expressions","title":"user_expressions  <code>instance-attribute</code>","text":"<pre><code>user_expressions: dict[str, str]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.allow_stdin","title":"allow_stdin  <code>instance-attribute</code>","text":"<pre><code>allow_stdin: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.stop_on_error","title":"stop_on_error  <code>instance-attribute</code>","text":"<pre><code>stop_on_error: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreate","title":"FixedCreate","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[S]</code></p> <p>A TypedDict relevant to Fixed.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>owner</code>               (<code>S</code>)           \u2013            </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class FixedCreate(TypedDict, Generic[S]):\n    \"A TypedDict relevant to Fixed.\"\n\n    name: str\n    \"\"\n    owner: S\n    \"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreate.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreate.owner","title":"owner  <code>instance-attribute</code>","text":"<pre><code>owner: S\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreated","title":"FixedCreated","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[S, T]</code></p> <p>A TypedDict relevant to Fixed.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>owner</code>               (<code>S</code>)           \u2013            </li> <li> <code>obj</code>               (<code>T</code>)           \u2013            </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class FixedCreated(TypedDict, Generic[S, T]):\n    \"A TypedDict relevant to Fixed.\"\n\n    name: str\n    \"\"\n    owner: S\n    \"\"\n    obj: T\n    \"\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreated.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreated.owner","title":"owner  <code>instance-attribute</code>","text":"<pre><code>owner: S\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreated.obj","title":"obj  <code>instance-attribute</code>","text":"<pre><code>obj: T\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.RunSettings","title":"RunSettings","text":"<p>               Bases: <code>TypedDict</code></p> <p>A dict of settings to use with async_kernel.event_loop.run.</p> Subclassed by: <ul> <li> Reference typing <code></code>\u00a0CallerCreateOptions </li> </ul> Used by: <ul> <li> Reference event_loop <ul> <li> <code></code>\u00a0Host <code></code>\u00a0run </li> <li> <code></code>\u00a0run </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>backend</code>               (<code>NotRequired[Backend | Literal['asyncio', 'trio']]</code>)           \u2013            <p>The backend to use for the caller.</p> </li> <li> <code>backend_options</code>               (<code>NotRequired[dict | None]</code>)           \u2013            <p>The backend options to specify for anyio.run (or <code>start_guest_run</code> when a loop is specified).</p> </li> <li> <code>loop</code>               (<code>NotRequired[Loop | None]</code>)           \u2013            <p>The type of eventloop where the backend will run.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class RunSettings(TypedDict):\n    \"A dict of settings to use with [async_kernel.event_loop.run][].\"\n\n    backend: NotRequired[Backend | Literal[\"asyncio\", \"trio\"]]\n    \"The backend to use for the caller.\"\n\n    backend_options: NotRequired[dict | None]\n    \"The backend options to specify for [anyio.run][] (or `start_guest_run` when a loop is specified).\"\n\n    loop: NotRequired[Loop | None]\n    \"The type of eventloop where the backend will run.\"\n\n    \"Options to use when calling [async_kernel.eventloop.run][].\"\n    loop_options: NotRequired[dict | None]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.RunSettings.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend: NotRequired[Backend | Literal['asyncio', 'trio']]\n</code></pre> <p>The backend to use for the caller.</p>"},{"location":"reference/typing/#async_kernel.typing.RunSettings.backend_options","title":"backend_options  <code>instance-attribute</code>","text":"<pre><code>backend_options: NotRequired[dict | None]\n</code></pre> <p>The backend options to specify for anyio.run (or <code>start_guest_run</code> when a loop is specified).</p>"},{"location":"reference/typing/#async_kernel.typing.RunSettings.loop","title":"loop  <code>instance-attribute</code>","text":"<pre><code>loop: NotRequired[Loop | None]\n</code></pre> <p>The type of eventloop where the backend will run.</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions","title":"CallerCreateOptions","text":"<p>               Bases: <code>RunSettings</code></p> <p>Options to use when creating an instance of a Caller.</p> Used by: <ul> <li> Reference caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0__new__ </li> <li> <code></code>\u00a0get </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>NotRequired[str]</code>)           \u2013            <p>The name for the new caller instance.</p> </li> <li> <code>log</code>               (<code>NotRequired[LoggerAdapter]</code>)           \u2013            <p>A logging adapter to use for the caller.</p> </li> <li> <code>protected</code>               (<code>NotRequired[bool]</code>)           \u2013            <p>The caller should be protected against accidental closure (default=<code>False</code>).</p> </li> <li> <code>zmq_context</code>               (<code>NotRequired[Context[Any]]</code>)           \u2013            <p>A zmq Context to use.</p> </li> </ul> Source code in <code>src/async_kernel/typing.py</code> <pre><code>class CallerCreateOptions(RunSettings):\n    \"Options to use when creating an instance of a [Caller][async_kernel.caller.Caller].\"\n\n    name: NotRequired[str]\n    \"The name for the new caller instance.\"\n\n    log: NotRequired[logging.LoggerAdapter]\n    \"A logging adapter to use for the caller.\"\n\n    \"Options to pass when calling [anyio.run][].\"\n    protected: NotRequired[bool]\n    \"The caller should be protected against accidental closure (default=`False`).\"\n\n    zmq_context: NotRequired[zmq.Context[Any]]\n    \"A zmq Context to use.\"\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>The name for the new caller instance.</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: NotRequired[LoggerAdapter]\n</code></pre> <p>A logging adapter to use for the caller.</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.protected","title":"protected  <code>instance-attribute</code>","text":"<pre><code>protected: NotRequired[bool]\n</code></pre> <p>The caller should be protected against accidental closure (default=<code>False</code>).</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.zmq_context","title":"zmq_context  <code>instance-attribute</code>","text":"<pre><code>zmq_context: NotRequired[Context[Any]]\n</code></pre> <p>A zmq Context to use.</p>"},{"location":"reference/utils/","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>mark_thread_pydev_do_not_trace</code>             \u2013              <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> </li> <li> <code>get_kernel</code>             \u2013              <p>Get the current kernel.</p> </li> <li> <code>get_job</code>             \u2013              <p>Get the job for the current context.</p> </li> <li> <code>get_parent</code>             \u2013              <p>Get the parent message for the current context.</p> </li> <li> <code>get_subshell_id</code>             \u2013              <p>Get the <code>subshell_id</code> for the current context.</p> </li> <li> <code>subshell_context</code>             \u2013              <p>A context manager to work in the context of a shell or subshell.</p> </li> <li> <code>get_metadata</code>             \u2013              <p>Gets the metadata for the current context.</p> </li> <li> <code>get_tags</code>             \u2013              <p>Gets the tags for the current context.</p> </li> <li> <code>get_tag_value</code>             \u2013              <p>Get the value for the tag from a collection of tags.</p> </li> <li> <code>get_timeout</code>             \u2013              <p>Gets the timeout from tags or using the current context.</p> </li> <li> <code>get_execution_count</code>             \u2013              <p>Gets the execution count for the current context, defaults to the current kernel count.</p> </li> <li> <code>setattr_nested</code>             \u2013              <p>Replace an existing nested attribute/trait of an object.</p> </li> <li> <code>error_to_content</code>             \u2013              <p>Convert the error to a dict.</p> </li> </ul>"},{"location":"reference/utils/#async_kernel.utils.mark_thread_pydev_do_not_trace","title":"mark_thread_pydev_do_not_trace","text":"<pre><code>mark_thread_pydev_do_not_trace(thread: Thread | None = None, *, remove=False) -&gt; None\n</code></pre> <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def mark_thread_pydev_do_not_trace(thread: threading.Thread | None = None, *, remove=False) -&gt; None:\n    \"\"\"Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).\"\"\"\n    thread = thread or threading.current_thread()\n    thread.pydev_do_not_trace = not remove  # pyright: ignore[reportAttributeAccessIssue]\n    thread.is_pydev_daemon_thread = not remove  # pyright: ignore[reportAttributeAccessIssue]\n    return\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_kernel","title":"get_kernel","text":"<pre><code>get_kernel() -&gt; Kernel\n</code></pre> <p>Get the current kernel.</p> Referenced by: <ul> <li> Reference asyncshell <code></code>\u00a0KernelMagics <code></code>\u00a0subshell </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_kernel() -&gt; Kernel:\n    \"Get the current kernel.\"\n    return async_kernel.Kernel()\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_job","title":"get_job","text":"<pre><code>get_job() -&gt; Job[dict] | dict\n</code></pre> <p>Get the job for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_job() -&gt; Job[dict] | dict:\n    \"Get the job for the current context.\"\n    try:\n        return _job_var.get()\n    except Exception:\n        return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_parent","title":"get_parent","text":"<pre><code>get_parent(job: Job | None = None) -&gt; Message[dict[str, Any]] | None\n</code></pre> <p>Get the parent message for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_parent(job: Job | None = None, /) -&gt; Message[dict[str, Any]] | None:\n    \"Get the [parent message]() for the current context.\"\n    return (job or get_job()).get(\"msg\")\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_subshell_id","title":"get_subshell_id","text":"<pre><code>get_subshell_id() -&gt; str | None\n</code></pre> <p>Get the <code>subshell_id</code> for the current context.</p> Referenced by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveSubshell </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_subshell_id() -&gt; str | None:\n    \"Get the `subshell_id` for the current context.\"\n    return get_kernel().shell.subshell_id\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.subshell_context","title":"subshell_context","text":"<pre><code>subshell_context(subshell_id: str | None) -&gt; Generator[None, Any, None]\n</code></pre> <p>A context manager to work in the context of a shell or subshell.</p> <p>Parameters:</p> Referenced by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveSubshell </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>@contextmanager\ndef subshell_context(subshell_id: str | None) -&gt; Generator[None, Any, None]:\n    \"\"\"A context manager to work in the context of a shell or subshell.\n\n    Args:\n        subshell_id: An existing subshell or the main shell if subshell_id is None.\n    \"\"\"\n    with get_kernel().subshell_manager.get_shell(subshell_id).context():\n        yield\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.subshell_context(subshell_id)","title":"<code>subshell_id</code>","text":"(<code>str | None</code>)           \u2013            <p>An existing subshell or the main shell if subshell_id is None.</p>"},{"location":"reference/utils/#async_kernel.utils.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(job: Job | None = None) -&gt; dict[str, Any] | None\n</code></pre> <p>Gets the metadata for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_metadata(job: Job | None = None, /) -&gt; dict[str, Any] | None:\n    \"Gets the metadata for the current context.\"\n    try:\n        return (job or _job_var.get())[\"msg\"][\"metadata\"]\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_tags","title":"get_tags","text":"<pre><code>get_tags(job: Job | None = None) -&gt; list[str]\n</code></pre> <p>Gets the tags for the current context.</p> Referenced by: <ul> <li> Reference utils <code></code>\u00a0get_tag_value </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_tags(job: Job | None = None, /) -&gt; list[str]:\n    \"Gets the tags for the current context.\"\n    try:\n        return get_metadata(job)[\"tags\"]  # pyright: ignore[reportOptionalSubscript]\n    except Exception:\n        return []\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_tag_value","title":"get_tag_value","text":"<pre><code>get_tag_value(\n    tag: Tags, default: _TagType, /, *, tags: list[str] | None = None\n) -&gt; _TagType\n</code></pre> <p>Get the value for the tag from a collection of tags.</p> <p>Parameters:</p> <p>The tag value is the value trailing behind =. The value is transformed according to the type of the default. Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_tag_value(tag: Tags, default: _TagType, /, *, tags: list[str] | None = None) -&gt; _TagType:\n    \"\"\"\n    Get the value for the tag from a collection of tags.\n\n    Args:\n        tag: The tag to get the value from.\n        default: The default value if a tag is not found. The default is also used to determine the type for conversion of the value.\n        tags: A list of tags to search. When not provide [get_tags][] is used.\n\n    The tag value is the value trailing behind &lt;tag&gt;=&lt;value&gt;. The value is transformed according to\n    the type of the default.\n    \"\"\"\n    for t in tags if tags is not None else get_tags():\n        if t == tag:\n            if isinstance(default, float):\n                return tag.get_float(t, default)\n            if isinstance(default, bool):\n                return tag.get_bool(t, default)\n            if isinstance(default, str):\n                return tag.get_string(t, default)\n            return int(tag.get_float(t, default))\n    return default\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_tag_value(tag)","title":"<code>tag</code>","text":"(<code>Tags</code>)           \u2013            <p>The tag to get the value from.</p>"},{"location":"reference/utils/#async_kernel.utils.get_tag_value(default)","title":"<code>default</code>","text":"(<code>_TagType</code>)           \u2013            <p>The default value if a tag is not found. The default is also used to determine the type for conversion of the value.</p>"},{"location":"reference/utils/#async_kernel.utils.get_tag_value(tags)","title":"<code>tags</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of tags to search. When not provide get_tags is used.</p>"},{"location":"reference/utils/#async_kernel.utils.get_timeout","title":"get_timeout","text":"<pre><code>get_timeout(*, tags: list[str] | None = None) -&gt; float\n</code></pre> <p>Gets the timeout from tags or using the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_timeout(*, tags: list[str] | None = None) -&gt; float:\n    \"Gets the timeout from tags or using the current context.\"\n    if math.isnan(timeout := get_tag_value(Tags.timeout, math.nan, tags=tags)):\n        return get_kernel().shell.timeout\n    return max(timeout, 0.0)\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execution_count","title":"get_execution_count","text":"<pre><code>get_execution_count() -&gt; int\n</code></pre> <p>Gets the execution count for the current context, defaults to the current kernel count.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execution_count() -&gt; int:\n    \"Gets the execution count for the current context, defaults to the current kernel count.\"\n\n    return get_kernel().shell.execution_count\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested","title":"setattr_nested","text":"<pre><code>setattr_nested(obj: object, name: str, value: str | Any) -&gt; dict[str, Any]\n</code></pre> <p>Replace an existing nested attribute/trait of an object.</p> <p>If the attribute name contains dots, it is interpreted as a nested attribute. For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The mapping of the name to the set value if the value has been set.</p> </li> <li> <code>dict[str, Any]</code>           \u2013            <p>An empty dict indicates the value was not set.</p> </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def setattr_nested(obj: object, name: str, value: str | Any) -&gt; dict[str, Any]:\n    \"\"\"\n    Replace an existing nested attribute/trait of an object.\n\n    If the attribute name contains dots, it is interpreted as a nested attribute.\n    For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.\n\n    Args:\n        obj: The object to set the attribute on.\n        name: The name of the attribute to set.\n        value: The value to set the attribute to.\n\n    Returns:\n        The mapping of the name to the set value if the value has been set.\n        An empty dict indicates the value was not set.\n    \"\"\"\n    import traitlets  # noqa: PLC0415\n\n    if len(bits := name.split(\".\")) &gt; 1:\n        try:\n            obj = getattr(obj, bits[0])\n        except Exception:\n            return {}\n        setattr_nested(obj, \".\".join(bits[1:]), value)\n    if (isinstance(obj, traitlets.HasTraits) and obj.has_trait(name)) or hasattr(obj, name):\n        try:\n            setattr(obj, name, value)\n        except Exception:\n            setattr(obj, name, eval(value))\n        return {name: getattr(obj, name)}\n    return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(obj)","title":"<code>obj</code>","text":"(<code>object</code>)           \u2013            <p>The object to set the attribute on.</p>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The name of the attribute to set.</p>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(value)","title":"<code>value</code>","text":"(<code>str | Any</code>)           \u2013            <p>The value to set the attribute to.</p>"},{"location":"reference/utils/#async_kernel.utils.error_to_content","title":"error_to_content","text":"<pre><code>error_to_content(error: BaseException) -&gt; Content\n</code></pre> <p>Convert the error to a dict.</p> <p>ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#request-reply</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def error_to_content(error: BaseException, /) -&gt; Content:\n    \"\"\"\n    Convert the error to a dict.\n\n    ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#request-reply\n    \"\"\"\n    return {\n        \"status\": \"error\",\n        \"ename\": type(error).__name__,\n        \"evalue\": str(error),\n        \"traceback\": traceback.format_exception(error),\n    }\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Async kernel provides a Jupyter kernel that can be used in:</p> <ul> <li>Jupyter</li> <li>VS code</li> <li>Other places that can us a python kernel without a gui event loop</li> </ul> <p>Normal Execute requests are queued for execution and will be run sequentially. Awaiting in cells is fully supported and will not block shell messaging.</p> <p>Please refer to the notebooks which demonstrate some usage examples.</p>"},{"location":"usage/#blocking-code","title":"Blocking code","text":"<p>Blocking code should be run in a separate thread using one of the following:</p> <ol> <li>anyio</li> <li>async_kernel.caller.Caller.to_thread</li> <li>Using the backend's library<ul> <li>asyncio.to_thread</li> <li>trio.to_thread.run_sync</li> </ul> </li> </ol>"},{"location":"usage/#caller","title":"Caller","text":"<p>Caller was originally developed to simplify message handling in the Kernel. It is now a capable tool in its own right with a convenient interface for executing synchronous and asynchronous code in a given thread's event loop.</p> <p>Job scheduling is synchronous, and for methods that return a Pending, the execution result can be cancelled, awaited from any thread or waited synchronously blocking the thread until the Pending is done.</p>"},{"location":"usage/#get-a-caller","title":"Get a Caller","text":"<p>If there is an event loop in the current thread, it is recommended to use:</p> <pre><code>caller = Caller()\n</code></pre>"},{"location":"usage/#modifier","title":"Modifier","text":"<p>A modifier can be passed as the first arg to modify which caller instance is returned:</p> <pre><code>caller = Caller(\"MainThread\")\n</code></pre> <p>The options are:</p> <ul> <li>\"CurrentThread\": A caller for the current thread. An event loop must be running in the current thread for this to work.</li> <li>\"MainThread\": A caller for the main thread. An event loop must be running in the main thread and if called from inside   a different thread, the caller must have already been created in the main thread.</li> <li>\"NewThread\": A new thread is always created.</li> <li>\"manual\": A new thread is created. The scheduler must be started manually by either entering the async context   or calling Caller.start_sync.</li> </ul>"},{"location":"usage/#callerget","title":"<code>Caller.get</code>","text":"<p>Caller.get caller.get can be used to create child callers that belong to the parent. When the parent is stopped the children are stopped.</p> <p>The following options are copied from the parent or can be specified.</p> <ul> <li>'zmq_context'</li> <li>'backend'</li> <li>'backend_options' (only if the backend matches)</li> </ul>"},{"location":"usage/#callerto_thread","title":"<code>Caller.to_thread</code>","text":"<p>Caller.to_thread performs execute requests in a dedicated caller using the same backend and zmq context as the parent. A pool of workers is retained to handle to thread calls, but are shutdown when no longer required.</p>"},{"location":"usage/#worker-lifespan","title":"worker lifespan","text":"<p>The <code>to_thread</code> call is synchronous and returns a Pending for the result of execution. When the Pending is done the worker becomes 'idle'. The following settings affect what happens to the idle worker:</p> <ul> <li>Caller.MAX_IDLE_POOL_INSTANCES:   When a worker becomes idle it will stop immediately if the number of idle workers equals this value.</li> <li>Caller.IDLE_WORKER_SHUTDOWN_DURATION:   If this value is greater than zero a thread is started that periodically checks and stops workers   that have been idle for a duration exceeding this value.</li> </ul> <pre><code>my_worker = caller.get(\"my own worker\", backend=\"trio\")\n</code></pre> <p>When called inside a thread without a running event loop, a new thread can be started with an event loop.</p> <pre><code>caller = Caller(name=\"my event loop\", backend=\"asyncio\")\n</code></pre>"},{"location":"usage/commands/","title":"Command line and kernel configuration","text":"<p>The command <code>async-kernel</code> and alias <code>async_kernel</code> are provided at the command line.</p> <p>The primary options available are:</p> <ul> <li>Add kernel spec: <code>-a &lt;name&gt; &lt;options&gt;</code></li> <li>Remove a kernel spec <code>-r &lt;name&gt;</code></li> <li>Start a kernel: <code>-f &lt;path to config file&gt;</code></li> </ul>"},{"location":"usage/commands/#kernel-spec","title":"Kernel spec","text":"<p>The kernel spec can be configured via the command line:</p> <p>Example</p> <pre><code>async-kernel -a async --backend=trio --loop=tk --display_name=\"Async python tk trio\"\n</code></pre> <p>The kernel spec looks like this:</p> <pre><code>{\n    \"argv\": [\n        \"python\",\n        \"-m\",\n        \"async_kernel\",\n        \"-f\",\n        \"{connection_file}\",\n        \"--start_interface=async_kernel.interface.start_kernel_zmq_interface\",\n        \"--kernel_name=async\",\n        \"--backend=trio\",\n        \"--loop=tk\"\n    ],\n    \"env\": {},\n    \"display_name\": \"Async python tk trio\",\n    \"language\": \"python\",\n    \"interrupt_mode\": \"message\",\n    \"metadata\": {\n        \"debugger\": true,\n        \"concurrent\": true\n    },\n    \"kernel_protocol_version\": \"5.5\"\n}\n</code></pre> <p>A single kernel spec is created when async kernel is installed with the following defaults.</p> <p>Defaults</p> <ul> <li>name: 'async'</li> <li>display_name: 'async'</li> <li>backend: <code>asyncio</code></li> <li>backend_options: <code>{'use_uvloop':True}</code> if uvloop or winloop is installed</li> <li>loop: <code>None</code></li> <li>loop_options: <code>None</code></li> </ul> <p>The kernel spec can be updated by adding a kernel spec with the same name ('async').</p>"},{"location":"usage/commands/#backend","title":"Backend","text":"<p>There are two supported backends 'asyncio' and 'trio'.</p> <p>In CPython the backend is started using anyio.run. The type of backend can be specified at the attribute <code>interface.backend</code>. The backend_options can be specified at the attribute `interface.backend_options'. Options can be written as a literal python string.</p> <pre><code>async-kernel -a async-trio --interface.backend=trio\n</code></pre>"},{"location":"usage/commands/#host-loop-gui-event-loops-tk-qt","title":"Host loop (gui event loops - tk, qt)","text":"<p>Typically event loops don't like to share the thread with any other event loop. Trio provides the function trio.lowlevel.start_guest_run which allows it to run as a guest alongside the host event loop by means of callbacks. The author of aiologic has provided an (experimental) asyncio equivalent (gist).</p> <p>Async kernel supports configuration of one host and one backend for the kernel. Below are some example kernel specs for host and backend kernel specs.</p>"},{"location":"usage/commands/#tk","title":"tk","text":"<pre><code># tk host asyncio backend\nasync-kernel -a async-tk --interface.loop=tk\n\n# tk host trio backend\nasync-kernel -a async-tk --interface.loop=tk --backend=trio\n</code></pre>"},{"location":"usage/commands/#qt","title":"qt","text":"<pre><code># qt host asyncio backend\nasync-kernel -a async-qt --interface.loop=qt\n\n# qt host trio backend\nasync-kernel -a async-qt-trio --interface.loop=qt --interface.backend=trio\n\n# PySide6 is default.  You can specify a different module via `loop_options`\nasync-kernel -a async-qt --interface.loop=qt --interface.loop_options={'module':'PySide2'}\n</code></pre>"},{"location":"usage/commands/#loop-options","title":"Loop options","text":"<p>Options can be provided to configure how a loop loads. There are only a few options available at present.</p> <ul> <li><code>host_class'</code>[type[Host| str]]` : A customised subclass of a Host   or a dotted import path to the customised Host.</li> <li>`'module': The module name on which to base the event loop. (Only applies to 'qt').</li> </ul>"},{"location":"usage/commands/#backend-options","title":"Backend options","text":"<p>Options can be provided for how the backend is started.</p> <ul> <li>With a (gui) loop: Options for <code>start_guest_run</code><ul> <li>trio.lowlevel.start_guest_run</li> <li>asyncio<ul> <li>host_uses_signal_set_wakeup_fd</li> <li>loop_factory,</li> <li>task_factory,</li> <li>context,</li> <li>debug,</li> </ul> </li> </ul> </li> <li>Without a (gui) loop: <code>backend_options</code> in anyio.run</li> </ul> <pre><code># If uvloop is installed it will be used by default. You can do this to disable it.\nasync-kernel -a async \"--interface.loop_options={'use_uvloop':False}\"\n</code></pre>"},{"location":"usage/commands/#custom-arguments","title":"Custom arguments","text":"<p>Additional arguments can be included when defining the kernel spec, these include:</p> <ul> <li>Arguments for async_kernel.kernelspec.write_kernel_spec<ul> <li><code>--start_interface</code></li> <li><code>--fullpath=False</code></li> <li><code>--display_name</code></li> <li><code>--prefix</code></li> </ul> </li> <li>Nested attributes can be set on the kernel via `kernel.[nested.attribute.name']'.   Each parameter should be specified as if it were a 'flag' as follows.</li> </ul> <p>Prefix each setting with \"--\" and join using the delimiter \"=\".</p> <pre><code>--&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;=&lt;VALUE&gt;\n</code></pre> <p>or, with compact notation to set a Boolean value as a Boolean flag.</p> <pre><code># True\n--&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;\n\n# False\n--no-&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;\n</code></pre>"},{"location":"usage/commands/#examples","title":"Examples","text":"write_kernel_spec argumentKernel attributeKernel Boolean attribute as a flag <p>start_interface</p> <p>To specify an alternate kernel factory.</p> <pre><code>--start_interface=my_module.my_interface_factory\n</code></pre> <p>fullpath (True)</p> <pre><code>--fullpath\n</code></pre> <p>display name</p> <p>To set the kernel display name to <code>True</code>.</p> <pre><code>\"--display_name=My kernel display name\"\n</code></pre> <p>Set the execute request timeout trait on the kernel shell.</p> <pre><code>--shell.timeout=0.1\n</code></pre> <p>Set <code>kernel.quiet=True</code>:</p> <pre><code>--quiet\n</code></pre> <p>Set <code>kernel.quiet=False</code>:</p> <pre><code>--no=quiet\n</code></pre>"},{"location":"usage/commands/#remove-a-kernel-spec","title":"Remove a kernel spec","text":"<p>Use the flag <code>-r</code> or <code>--remove</code> to remove a kernelspec.</p> <p>If you added the custom kernel spec above, you can remove it with:</p> <pre><code>async-kernel -r async-trio-custom\n</code></pre>"},{"location":"usage/commands/#start-a-kernel","title":"Start a kernel","text":"<p>Use the flag <code>-f</code> or <code>--connection_file</code> followed by the full path to the connection file. To skip providing a connection file</p> <p>This will start the default kernel (async).</p> <pre><code>async-kernel -f .\n</code></pre> <p>Additional settings can be passed as arguments.</p> <pre><code>async-kernel -f . --kernel_name=async-trio-custom --display_name='My custom kernel' --quiet=False\n</code></pre> <p>The call above will start a new kernel with a 'trio' backend. The quiet setting is a parameter that gets set on kernel. Parameters of this type are converted using [eval] prior to setting.</p> <p>For further detail, see the API for the command line handler command_line.</p>"},{"location":"usage/message_handling/","title":"Message handling","text":"<ul> <li> <p>When a message is received the <code>msg_handler</code> is called with:</p> <ul> <li>'job' (a dict of <code>msg</code>, <code>received_time</code> and <code>ident</code>)</li> <li>The <code>channel</code></li> <li><code>msg_type</code></li> <li>A function <code>send_reply</code></li> </ul> </li> <li> <p>The <code>msg_handler</code></p> <ul> <li>determines the <code>subshell_id</code> and run mode.</li> <li>obtains the <code>handler</code> from the kernel with the same name as the <code>msg_type</code>.</li> <li>determines the run mode</li> <li>creates cached version of the <code>run_handler</code> with a unique version per:<ul> <li>The <code>handler</code></li> <li><code>channel</code></li> <li><code>subshell_id</code></li> <li>send_reply (constant or per-channel)</li> </ul> </li> <li>Obtains the caller associated with the channel and schedules execution of the cached handler</li> </ul> </li> </ul>"},{"location":"usage/message_handling/#run-mode","title":"Run mode","text":"<p>The run modes available are:</p> <ul> <li><code>RunMode.direct</code> \u2192 async_kernel.caller.Caller.call_direct   Run the request directly in the scheduler.</li> <li><code>RunMode.queue</code> \u2192 async_kernel.caller.Caller.queue_call   Run the request in a queue dedicated to the subshell, handler &amp; channel.</li> <li><code>RunMode.task</code> \u2192 async_kernel.caller.Caller.call_soon   Run the request in a separate task.</li> <li><code>RunMode.thread</code> \u2192 async_kernel.caller.Caller.to_thread   Run the request in a separate worker thread.</li> </ul> <p>These are the currently assigned run modes.</p> SocketID shell control comm_close direct direct comm_info_request direct direct comm_msg queue queue comm_open direct direct complete_request thread thread create_subshell_request None thread debug_request None queue delete_subshell_request None thread execute_request queue queue history_request thread thread inspect_request thread thread interrupt_request direct direct is_complete_request thread thread kernel_info_request direct direct list_subshell_request None direct shutdown_request None direct"}]}