{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Async kernel","text":"<p>Async kernel is an asynchronous Python Jupyter kernel with concurrent message handling.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Concurrent message handling</li> <li>Configurable backend</li> <li>Debugger client<ul> <li>anyio<ul> <li><code>asyncio</code> backend (default)<sup>1</sup></li> <li><code>trio</code> backend</li> </ul> </li> </ul> </li> <li>IPython shell   provides:<ul> <li>code execution</li> <li>magic</li> <li>code completions</li> <li>history</li> </ul> </li> <li>Thread-safe execution and cancellation (utilising aiologic synchronisation primitives).<ul> <li>Caller - code execution in a chosen event loop</li> <li>Pending - wait/await/cancel the pending result</li> </ul> </li> <li>GUI event loops<ul> <li> inline</li> <li> ipympl</li> <li> tk</li> <li> qt</li> </ul> </li> </ul> <p>Documentation</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install async-kernel\n</code></pre>"},{"location":"#trio-backend","title":"Trio backend","text":"<p>To add a kernel spec for a <code>trio</code> backend.</p> <pre><code>pip install trio\nasync-kernel -a async-trio\n</code></pre> <p>See also: command line usage.</p>"},{"location":"#asynchronous-event-loops","title":"Asynchronous event loops","text":"<p>Async kernel uses <code>Caller</code> for concurrent message handling.</p> <p>There are two callers:</p> <ul> <li><code>Shell</code> - runs in the <code>MainThread</code> handling user related requests<sup>2</sup>.</li> <li><code>Control</code> - runs in a separate thread handling control related requests.</li> </ul>"},{"location":"#messaging","title":"Messaging","text":"<p>Messages are received in a separate thread (per-channel) then handled in the associated thread (shell/control) concurrently according to the determined run mode.</p>"},{"location":"#run-mode","title":"Run mode","text":"<p>The run modes available are:</p> <ul> <li><code>RunMode.direct</code> \u2192 <code>Caller.call_direct</code>:   Run the request in the scheduler.</li> <li><code>RunMode.queue</code> \u2192 <code>Caller.queue_call</code>:   Run the request in a queue dedicated to the handler &amp; channel.</li> <li><code>RunMode.task</code> \u2192 <code>Caller.call_soon</code>:   Run the request in a separate task.</li> <li><code>RunMode.thread</code> \u2192 <code>Caller.to_thread</code>:   Run the request in a separate worker thread.</li> </ul> <p>These are the currently assigned run modes.</p> MsgType shell control comm_close queue queue comm_info_request queue queue comm_msg queue queue comm_open queue queue complete_request queue queue debug_request None queue execute_request queue task history_request thread thread inspect_request thread thread interrupt_request queue queue is_complete_request queue queue kernel_info_request queue queue shutdown_request None queue"},{"location":"#further-detail","title":"Further detail","text":"<ul> <li><code>MsgType</code> docs.</li> <li><code>Kernel.receive_msg_loop</code> docs.</li> <li>Concurrency notebook.</li> </ul>"},{"location":"#origin","title":"Origin","text":"<p>Async kernel started as a fork of IPyKernel. Thank you to the original contributors of IPyKernel that made Async kernel possible.</p> <ol> <li> <p>Uvloop is not a dependency of async-kernel but will be used if it has been installed.\u00a0\u21a9</p> </li> <li> <p>The Shell can run in other threads with the associated limitations with regard to signalling and interrupts.\u00a0\u21a9</p> </li> </ol>"},{"location":"commands/","title":"Command line","text":"<p><code>async-kernel</code> (and alias <code>async_kernel</code>) is provided on the command line. The main options are:</p> <ul> <li>Add kernel spec</li> <li>Remove a kernel spec</li> <li>Start a kernel</li> </ul>"},{"location":"commands/#add-a-kernel-spec","title":"Add a kernel spec","text":"<p>Use the argument <code>-a</code> followed by the kernel name to add a new kernel spec. Include 'trio' in the kernel name to use a 'trio' backend. Any valid kernel name is allowed (whitespace is not allowed).</p> <p>Recommended kernel names are:</p> <ul> <li>'async': Default kernel that is installed that provides a the default 'asyncio' backend.</li> <li>'async-trio': A trio backend. Note: trio must be installed separately.</li> </ul> <p>Add a trio kernel spec.</p> <pre><code>async-kernel -a async-trio\n</code></pre>"},{"location":"commands/#custom-arguments","title":"Custom arguments","text":"<p>Additional arguments can be included when defining the kernel spec, these include:</p> <ul> <li>Arguments for async_kernel.kernelspec.write_kernel_spec<ul> <li><code>--kernel_factory</code></li> <li><code>--fullpath=False</code></li> <li><code>--display_name</code></li> <li><code>--prefix</code></li> </ul> </li> <li>Nested attributes on the kernel via `kernel.\\' <p>Each parameter should be specified as if it were a 'flag' as follows.</p> <p>Prefix with \"--\" and join with the delimiter \"=\".</p> <pre><code>--&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;=&lt;VALUE&gt;\n</code></pre> <p>or, with compact notation to set a Boolean value as a Boolean flag.</p> <pre><code># True\n--&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;\n\n# False\n--no-&lt;PARAMETER or DOTTED.ATTRIBUTE.NAME&gt;\n</code></pre>"},{"location":"commands/#examples","title":"Examples","text":"write_kernel_spec argumentKernel attributeKernel Boolean attribute as a flag <p>kernel_factory</p> <p>To specify an alternate kernel factory.</p> <pre><code>--kernel_factory=my_module.my_kernel_factory\n</code></pre> <p>fullpath (True)</p> <pre><code>--fullpath\n</code></pre> <p>display name</p> <p>To set the kernel display name to <code>True</code>.</p> <pre><code>\"--display_name=My kernel display name\"\n</code></pre> <p>Set the execute request timeout trait on the kernel shell.</p> <pre><code>--shell.execute_request_timeout=0.1\n</code></pre> <p>Set <code>kernel.quiet=True</code>:</p> <pre><code>--quiet\n</code></pre> <p>Set <code>kernel.quiet=False</code>:</p> <pre><code>--no=quiet\n</code></pre>"},{"location":"commands/#remove-a-kernel-spec","title":"Remove a kernel spec","text":"<p>Use the flag <code>-r</code> or <code>--remove</code> to remove a kernelspec.</p> <p>If you added the custom kernel spec above, you can remove it with:</p> <pre><code>async-kernel -r async-trio-custom\n</code></pre>"},{"location":"commands/#start-a-kernel","title":"Start a kernel","text":"<p>Use the flag <code>-f</code> or <code>--connection_file</code> followed by the full path to the connection file. To skip providing a connection file</p> <p>This will start the default kernel (async).</p> <pre><code>async-kernel -f .\n</code></pre> <p>Additional settings can be passed as arguments.</p> <pre><code>async-kernel -f . --kernel_name=async-trio-custom --display_name='My custom kernel' --quiet=False\n</code></pre> <p>The call above will start a new kernel with a 'trio' backend. The quiet setting is a parameter that gets set on kernel. Parameters of this type are converted using [eval] prior to setting.</p> <p>For further detail, see the API for the command line handler command_line.</p>"},{"location":"about/","title":"About","text":"<ul> <li>Contributing</li> <li>Changelog</li> <li>License</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":""},{"location":"about/changelog/#miscellaneous","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Bugfixes for 'Fixed' class #206</li> </ul>"},{"location":"about/changelog/#090-rc1-2025-11-18","title":"0.9.0-rc.1 - 2025-11-18","text":""},{"location":"about/changelog/#breaking-changes","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Caller - instance checks names of children rather than all instances. #204</p> </li> <li> <p>Caller restructuring adding new features and breaking changes plus added 'Fixed' class and renamed Future to Pending. #197</p> </li> <li> <p>Caller enhancements and breaking changes #195</p> </li> <li> <p>Remove unnecessary context copy and call from queue_call. #194</p> </li> </ul>"},{"location":"about/changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Added Caller.zmq_context #198</p> </li> <li> <p>Use queue run mode instead of direct which is no slower, but probably 'safer'. #193</p> </li> </ul>"},{"location":"about/changelog/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Docs #203</p> </li> <li> <p>Update readme. #202</p> </li> <li> <p>Docs and shuffle code inside the kernel #200</p> </li> <li> <p>Update mkdocs and mkdocstrings python - have released insiders features. #192</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_1","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.9.0-rc.1 #205</p> </li> <li> <p>Add the trait Kernel.print_kernel_messages which when set to false prevents messages from being printed. #201</p> </li> <li> <p>General tidy and remove unrequired tests. #199</p> </li> </ul>"},{"location":"about/changelog/#080-2025-11-12","title":"0.8.0 - 2025-11-12","text":""},{"location":"about/changelog/#breaking-changes_1","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Rename 'RunMode.blocking' to 'RunMode.direct'. #190</p> </li> <li> <p>Add slots to Future. #186</p> </li> <li> <p>Drop Future.init positional argument 'retain_metadata' #185</p> </li> </ul>"},{"location":"about/changelog/#documentation_1","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Maintenance and documentation. #187</li> </ul>"},{"location":"about/changelog/#miscellaneous_2","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.8.0 #191</p> </li> <li> <p>Prepare for release v0.7.2 #189</p> </li> <li> <p>General maintenance #188</p> </li> </ul>"},{"location":"about/changelog/#071-2025-11-11","title":"0.7.1 - 2025-11-11","text":""},{"location":"about/changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>Added Kernel.schedule_job, exposed Kernel.caller #181</li> </ul>"},{"location":"about/changelog/#documentation_2","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Improve docstrings: #182</li> </ul>"},{"location":"about/changelog/#miscellaneous_3","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.7.1 #184</p> </li> <li> <p>Make all Threads daemon and add daemon option to Caller.start_new. #183</p> </li> </ul>"},{"location":"about/changelog/#070-2025-11-10","title":"0.7.0 - 2025-11-10","text":""},{"location":"about/changelog/#breaking-changes_2","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Drop 'run_mode' key from Job dict. #174</p> </li> <li> <p>Remove usage of KernelConcurrencyMode. It was functional but unnecessary. #173</p> </li> <li> <p>Run shell and control socket loops in threads without event loops. #172</p> </li> </ul>"},{"location":"about/changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Use BinarySemaphore instead of Lock for best performance in send_reply. #178</p> </li> <li> <p>Use a lock in send_reply. #175</p> </li> </ul>"},{"location":"about/changelog/#documentation_3","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Use BinarySemaphore instead of Lock for best performance in send_reply and update readme. #179</li> </ul>"},{"location":"about/changelog/#miscellaneous_4","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.7.0 #180</p> </li> <li> <p>Switch from mdformat to prettier for formatting markdown #177</p> </li> <li> <p>Improve typehints in tests. #176</p> </li> <li> <p>Added Kernel.run and permit the kernel to run outside the main thread #171</p> </li> </ul>"},{"location":"about/changelog/#070-rc2-2025-11-07","title":"0.7.0-rc.2 - 2025-11-07","text":""},{"location":"about/changelog/#features_3","title":"\ud83d\ude80 Features","text":"<ul> <li>Use low-level async primatives in caller module. #169</li> </ul>"},{"location":"about/changelog/#miscellaneous_5","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.7.0-rc.2 #170</li> </ul>"},{"location":"about/changelog/#070-rc1-2025-11-04","title":"0.7.0-rc.1 - 2025-11-04","text":""},{"location":"about/changelog/#breaking-changes_3","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Use aiologic for thread-safe Event and Lock. #164</li> </ul>"},{"location":"about/changelog/#miscellaneous_6","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.7.0-rc.1 #167</li> </ul>"},{"location":"about/changelog/#063-2025-11-04","title":"0.6.3 - 2025-11-04","text":""},{"location":"about/changelog/#miscellaneous_7","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.3 #166</p> </li> <li> <p>Kernel.execute_request unnecessarily sent a thread call to a new thread. #165</p> </li> <li> <p>Update pre-commit #163</p> </li> <li> <p>Use a dependency floor in requirements and upgrade lock file. #162</p> </li> <li> <p>Make AsyncInteractiveShell.enable_gui raise NotImplementedError for unsupported guis. #161</p> </li> </ul>"},{"location":"about/changelog/#062-2025-10-29","title":"0.6.2 - 2025-10-29","text":""},{"location":"about/changelog/#miscellaneous_8","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.2 #160</p> </li> <li> <p>Bump the actions group with 2 updates #158</p> </li> <li> <p>Don't reraise caught cancelled error in Caller_wrap_call. #159</p> </li> <li> <p>Ensure debugInfo is fullly populated. #157</p> </li> </ul>"},{"location":"about/changelog/#061-2025-10-17","title":"0.6.1 - 2025-10-17","text":""},{"location":"about/changelog/#features_4","title":"\ud83d\ude80 Features","text":"<ul> <li>Added Kernel.get_parent. #155</li> </ul>"},{"location":"about/changelog/#miscellaneous_9","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.1 #156</p> </li> <li> <p>Bump astral-sh/setup-uv from 6 to 7 in the actions group #154</p> </li> </ul>"},{"location":"about/changelog/#060-2025-09-30","title":"0.6.0 - 2025-09-30","text":""},{"location":"about/changelog/#breaking-changes_4","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Remove 'name' argument from get_instance (it can be provided as a kwarg. #152</p> </li> <li> <p>Rename Caller.to_thread_by_name to Caller.to_thread_advanced change the first argument from a string or None to a dict. #151</p> </li> </ul>"},{"location":"about/changelog/#features_5","title":"\ud83d\ude80 Features","text":"<ul> <li>Add hooks to AsyncDisplayPublisher #150</li> </ul>"},{"location":"about/changelog/#miscellaneous_10","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.6.0 #153</p> </li> <li> <p>Better handling of Keyboard Interrupt. #149</p> </li> </ul>"},{"location":"about/changelog/#054-2025-09-28","title":"0.5.4 - 2025-09-28","text":""},{"location":"about/changelog/#miscellaneous_11","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.4 #148</p> </li> <li> <p>Add functools.wraps decorator to kernel._wrap_handler to make it easier to identify which function it is wrapping. #147</p> </li> <li> <p>Minimize calls to 'expensive' thread.Event methods #146</p> </li> </ul>"},{"location":"about/changelog/#053-2025-09-27","title":"0.5.3 - 2025-09-27","text":""},{"location":"about/changelog/#documentation_4","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Various documentation improvements. #144</li> </ul>"},{"location":"about/changelog/#miscellaneous_12","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.3 #145</p> </li> <li> <p>Tidy up Caller queues and  remove kernel.CancelledError. #143</p> </li> <li> <p>Refactored ReentrantAsyncLock and AsyncLock with a new method 'base'. #142</p> </li> </ul>"},{"location":"about/changelog/#052-2025-09-26","title":"0.5.2 - 2025-09-26","text":""},{"location":"about/changelog/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix debugger #140</li> </ul>"},{"location":"about/changelog/#miscellaneous_13","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.2 #141</p> </li> <li> <p>Refactor Kernel and Subclass Caller from anyio.AsyncContextManagerMixin #139</p> </li> </ul>"},{"location":"about/changelog/#051-2025-09-25","title":"0.5.1 - 2025-09-25","text":""},{"location":"about/changelog/#features_6","title":"\ud83d\ude80 Features","text":"<ul> <li>Take advantage of current_token in utils.wait_thread_event. #136</li> </ul>"},{"location":"about/changelog/#miscellaneous_14","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.5.1 #138</p> </li> <li> <p>Reinstate test_debugger for windows. #137</p> </li> </ul>"},{"location":"about/changelog/#050-2025-09-24","title":"0.5.0 - 2025-09-24","text":""},{"location":"about/changelog/#breaking-changes_5","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Simplify queue with breaking changes #134</li> </ul>"},{"location":"about/changelog/#miscellaneous_15","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.5.0 #135</li> </ul>"},{"location":"about/changelog/#040-2025-09-23","title":"0.4.0 - 2025-09-23","text":""},{"location":"about/changelog/#breaking-changes_6","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Revise message handling for comm_msg #129</p> </li> <li> <p>Improve Calller.get_instance to start a caller for the main thread if there isn't one running. #127</p> </li> </ul>"},{"location":"about/changelog/#features_7","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Make Caller.queue_call and Caller.queue_call_no_wait thread safe #131</p> </li> <li> <p>Add  Caller.get_runner. #126</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_16","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.4.0 #133</p> </li> <li> <p>Maintenance #132</p> </li> <li> <p>Put _send_reply back inside run_handler. #130</p> </li> <li> <p>Prevent memory leaks in caller scheduled futures #128</p> </li> <li> <p>Housekeeping #125</p> </li> </ul>"},{"location":"about/changelog/#030-2025-09-14","title":"0.3.0 - 2025-09-14","text":""},{"location":"about/changelog/#breaking-changes_7","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Caller.queue_call - divide into queue_get_sender, queue_call and queue_call_no_wait. #123</p> </li> <li> <p>Stricter handling in Caller class. #122</p> </li> <li> <p>Add AsyncEvent  class. #118</p> </li> </ul>"},{"location":"about/changelog/#features_8","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Store Caller.call_later function details in the futures  metadata #119</p> </li> <li> <p>Add metadata to Future. #116</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_17","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.3.0 #124</p> </li> <li> <p>AsyncEvent maintenance - make more robust #120</p> </li> <li> <p>Switch from pytest-retry to pytest-rerun failures. #117</p> </li> <li> <p>Refactor Caller to speed up initialization of Future by removing the creation of the threading event. #115</p> </li> </ul>"},{"location":"about/changelog/#021-2025-09-10","title":"0.2.1 - 2025-09-10","text":""},{"location":"about/changelog/#breaking-changes_8","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Maintenance #105</li> </ul>"},{"location":"about/changelog/#features_9","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Divide Lock into AsyncLock and ReentrantAsyncLock #113</p> </li> <li> <p>Improve Lock class #112</p> </li> <li> <p>Add a context based Lock #111</p> </li> <li> <p>Add classmethod  Caller.wait #106</p> </li> <li> <p>Add 'shield' option to Caller.as_completed. #104</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_18","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.2.1 #114</p> </li> <li> <p>Bump actions/setup-python from 5 to 6 in the actions group #110</p> </li> <li> <p>Maintenance - Caller refactoring #109</p> </li> <li> <p>Drop WaitType for Literals directly in Caller.wait. #108</p> </li> <li> <p>Change Caller._queue_map to a WeakKeyDictionary. #107</p> </li> <li> <p>Refactor Caller.wait to avoid catching  exceptions. #103</p> </li> </ul>"},{"location":"about/changelog/#020-2025-09-06","title":"0.2.0 - 2025-09-06","text":""},{"location":"about/changelog/#breaking-changes_9","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Rename Caller.call_no_context to Caller.call_direct. #100</p> </li> <li> <p>Future - breaking changes- better compatibility of Future.result #96</p> </li> </ul>"},{"location":"about/changelog/#features_10","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Add the classmethod Caller.current_future. #99</p> </li> <li> <p>Add timeout, shield and result optional arguments to Future wait and wait_sync methods: #97</p> </li> <li> <p>Add  optional argument 'msg' to Future.cancel method. #95</p> </li> <li> <p>Support weakref on the Future class. #94</p> </li> </ul>"},{"location":"about/changelog/#documentation_5","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Documentation maintenance. #101</li> </ul>"},{"location":"about/changelog/#miscellaneous_19","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.2.0 #102</p> </li> <li> <p>Result should raise cancelled error, but was raising and InvalidStateError. #98</p> </li> </ul>"},{"location":"about/changelog/#014-2025-09-03","title":"0.1.4 - 2025-09-03","text":""},{"location":"about/changelog/#breaking-changes_10","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Optionally store a string representation of a kernel factory inside the kernel spec. #92</p> </li> <li> <p>Use capital 'V' instead of 'v'  for version flag in command_line. #88</p> </li> </ul>"},{"location":"about/changelog/#documentation_6","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Fix for publish-docs.yml not  setting the version info correctly. #90</p> </li> <li> <p>Include changelog in 'dev' version of docs. #89</p> </li> <li> <p>Development documentation updates and fixes for publish-docs.yml. #87</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_20","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.4 #93</p> </li> <li> <p>Ensure there is only one kernel instance including subclases. #91</p> </li> </ul>"},{"location":"about/changelog/#013-2025-09-02","title":"0.1.3 - 2025-09-02","text":""},{"location":"about/changelog/#features_11","title":"\ud83d\ude80 Features","text":"<ul> <li>Add version option to command line. #82</li> </ul>"},{"location":"about/changelog/#fixes_1","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix bug setting version for mike. #80</li> </ul>"},{"location":"about/changelog/#documentation_7","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update documentation #84</li> </ul>"},{"location":"about/changelog/#miscellaneous_21","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.3 #86</p> </li> <li> <p>Minor import changes. #85</p> </li> <li> <p>Change base class of Kernel from ConnectionFileMixin to HasTraits #83</p> </li> <li> <p>Overwrite subclass properties that should not be available. #81</p> </li> <li> <p>CI checks for python 3.14 #63</p> </li> </ul>"},{"location":"about/changelog/#012-2025-08-31","title":"0.1.2 - 2025-08-31","text":""},{"location":"about/changelog/#breaking-changes_11","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li> <p>Breaking changes to kernel initialisation and launching #78</p> </li> <li> <p>Enhancement -  Make kernel async enterable. #77</p> </li> </ul>"},{"location":"about/changelog/#documentation_8","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Fix alias for latest docs and limit release versions. #75</li> </ul>"},{"location":"about/changelog/#miscellaneous_22","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.2 #79</p> </li> <li> <p>CI and pre-commit maintenance #76</p> </li> </ul>"},{"location":"about/changelog/#011-2025-08-28","title":"0.1.1 - 2025-08-28","text":""},{"location":"about/changelog/#miscellaneous_23","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.1 #74</p> </li> <li> <p>Bugfixes - fix installing without trio and installing a kernelspec #73</p> </li> </ul>"},{"location":"about/changelog/#010-2025-08-28","title":"0.1.0 - 2025-08-28","text":""},{"location":"about/changelog/#breaking-changes_12","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Caller.queue_call add argument send_nowait  and convert to sync that optionally returns an awaitable. #71</li> </ul>"},{"location":"about/changelog/#features_12","title":"\ud83d\ude80 Features","text":"<ul> <li>Add anyio_backend_options and use uvloop by default #70</li> </ul>"},{"location":"about/changelog/#documentation_9","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Use mike for documentation versioning. #67</p> </li> <li> <p>Update docs, readme and project description. #66</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_24","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0 #72</p> </li> <li> <p>Drop matplotlib dependency. #69</p> </li> </ul>"},{"location":"about/changelog/#010-rc3-2025-08-26","title":"0.1.0-rc3 - 2025-08-26","text":""},{"location":"about/changelog/#features_13","title":"\ud83d\ude80 Features","text":"<ul> <li>Add more classifers and code coverage #64</li> </ul>"},{"location":"about/changelog/#miscellaneous_25","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc3 #65</p> </li> <li> <p>Add workflow_run event because the release is not triggered if  the release is created by another workflow. #62</p> </li> </ul>"},{"location":"about/changelog/#010-rc2-2025-08-26","title":"0.1.0-rc2 - 2025-08-26","text":""},{"location":"about/changelog/#miscellaneous_26","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.1.0-rc2 #61</li> </ul>"},{"location":"about/changelog/#010-rc1-2025-08-26","title":"0.1.0-rc1 - 2025-08-26","text":""},{"location":"about/changelog/#documentation_10","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update licensing and contribution notes #27</li> </ul>"},{"location":"about/changelog/#miscellaneous_27","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc1 #60</p> </li> <li> <p>Merge pull request #56 from fleming79/release/v0.1.0-rc1 #56</p> </li> <li> <p>Revise new release #55</p> </li> <li> <p>New release workflow in one step with publish option. #51</p> </li> <li> <p>Improve release workflow, update documentation and license info. #29</p> </li> <li> <p>Maintenance #26</p> </li> </ul>"},{"location":"about/changelog/#010-rc0-2025-08-24","title":"[0.1.0-rc0] - 2025-08-24","text":""},{"location":"about/changelog/#features_14","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>First release #18</p> </li> <li> <p>Switch to vcs for versioning. #2</p> </li> </ul>"},{"location":"about/changelog/#fixes_2","title":"\ud83d\udc1b Fixes","text":"<ul> <li> <p>Use no-local-version in pyproject.toml instead. #5</p> </li> <li> <p>Use no-local-version on ci. #4</p> </li> </ul>"},{"location":"about/changelog/#documentation_11","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Revise workflow to work with tags that start with 'v'. No longer sets the tag when writing the changelog. #16</p> </li> <li> <p>Switch to python installer to run git cliff. #14</p> </li> <li> <p>Revise changelog template. #12</p> </li> <li> <p>Do changelog as PR instead of push to main. #8</p> </li> <li> <p>Git cliff #7</p> </li> <li> <p>Fix mkdocs publishing #6</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_28","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Bugfix #25</p> </li> <li> <p>Update changelog #24</p> </li> <li> <p>Update changelog #22</p> </li> <li> <p>Release workflow changes #21</p> </li> <li> <p>Update release workflow to use a template that appends output from git-cliff #17</p> </li> <li> <p>Bump the actions group across 1 directory with 2 updates #3</p> </li> </ul>"},{"location":"about/contributing/","title":"Contributing","text":"<p>This project is under active development. Feel free to create an issue to provide feedback.</p>"},{"location":"about/contributing/#development","title":"Development","text":"<p>The development environment is provided by uv using locking and syncing.</p> <p>If you are working on a pull request make a fork of the project and work on the fork.</p> <pre><code>git clone &lt;your fork repository&gt;\ncd async-kernel\n</code></pre> <p>Synchronise the environment.</p> <pre><code>uv venv --python 3.11 # or whichever environment you are targeting.\nuv sync\n# Activate the environment\n</code></pre> <p>Additional steps to build documentation (optional):</p> <pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --shell.execute_request_timeout=0.1\n</code></pre>"},{"location":"about/contributing/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"about/contributing/#running-tests-with-coverage","title":"Running tests with coverage","text":"<p>We intend to maintain 100% code coverage on CI (Linux). The coverage report and badge  are generated with Codecov.</p> <p>You can run tests locally with coverage to see if the test will pass on CI using:</p> <pre><code>uv run pytest -vv --cov --cov-fail-under=100\n</code></pre> Info <p>We are only targeting 100% on linux for &gt;= 3.12 for the following reasons:</p> <ol> <li>linux is the only platform that reliably supports the <code>transport</code> type <code>ipc</code> for zmq sockets which is supported by async kerenel.</li> <li>Coverage on Python 3.11 doesn't correctly gather data for subprocesses giving invalid coverage reports.</li> </ol>"},{"location":"about/contributing/#pre-commit","title":"Pre-commit","text":"<p>Pre-commit(prek) runs a number of checks on the code and will also re-format it.</p> <p>Pre-commit will run automatically on submission of a PR but you can also run it locally as a tool with:</p> Changed filesAll files <pre><code>uvx prek run\n</code></pre> <pre><code>uvx prek run -a\n</code></pre>"},{"location":"about/contributing/#type-checking","title":"Type checking","text":"<p>Type checking is performed separately to pre-commit checks. Currently type checking is done using basedpyright. Other type checkers might be added in the future.</p> <pre><code>uv run basedpyright\n</code></pre>"},{"location":"about/contributing/#update-packages","title":"Update packages","text":"<p>To upgrade all packages use the command:</p> <pre><code>uv lock --upgrade\n</code></pre>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is generated from markdown files and the source using Material for MkDocs  and mike for versioning. Publishing of documentation is handled by the automation workflow 'publish-docs.yml'.</p> <p>The 'docs' group specified extra packages are required to build documentation.</p>"},{"location":"about/contributing/#sync-docs-group","title":"Sync 'docs' group","text":"<pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --shell.execute_request_timeout=0.1\n</code></pre>"},{"location":"about/contributing/#test-the-docs","title":"Test the docs","text":"<pre><code>uv run mkdocs build -s\n</code></pre> Info <p>The command:</p> <pre><code>uv run async-kernel -a async-docs --shell.execute_request_timeout=0.1\n</code></pre> <p>defines a new kernel spec with the name \"async-docs\" that sets the <code>shell.execute_request_timeout</code> to 100ms.</p> <p>The \"async-docs\" named kernel spec is used by mkdocs-jupyter to convert the notebooks for inclusion in the usage section of the documentation.</p>"},{"location":"about/contributing/#serve-locally","title":"Serve locally","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"about/contributing/#api-docstrings","title":"API / Docstrings","text":"<p>API documentation is included using mkdocstrings.</p> <p>Docstrings are written in docstring format google-notypes. Typing information is included automatically by griff.</p>"},{"location":"about/contributing/#see-also","title":"See also","text":"<ul> <li>cross-referencing</li> </ul>"},{"location":"about/contributing/#notebooks","title":"Notebooks","text":"<p>Notebooks are included in the documentation by the plugin mkdocs-jupyter.</p> <p>Info</p> <p>We use the kernel spec named 'async-docs' which has a cell execute timeout of 100ms. This is used to advance execution through long running cells.</p> <p>The suppress-error tag is inserted in code cells to enable with generating documentation. The symbol '\u26a0' is an indicator that the error was suppressed. Normally this is due to the timeout but there is no distinction on the type of error.</p>"},{"location":"about/contributing/#useful-links","title":"Useful links","text":"<p>These links are not relevant for docstrings.</p> <ul> <li>footnotes</li> <li>tooltips</li> </ul>"},{"location":"about/contributing/#releasing-async-kernel","title":"Releasing Async kernel","text":"<p>To make a new release go to the new_release.yml action and click 'Run workflow'.</p>"},{"location":"about/contributing/#new_releaseyml","title":"new_release.yml","text":"<p>The workflow does the following:</p> <ol> <li>Creates and merges a PR with the updated changelog generated with git-cliff.</li> <li>Starts a new Github release which adds a tag 'v' to the head of the main branch."},{"location":"about/contributing/#publish-to-pypiyml","title":"publish-to-pypi.yml","text":"<p>The publish-to-pypi<sup>1</sup> workflow will start automatically on completion of the \"new_release.yml\". It performs the following steps.</p> <ol> <li>Builds the distribution.</li> <li>Waits for manual approval to release.</li> <li>Uploads the release files to PyPi.</li> <li>Uploads the release files to the Github release.</li> </ol> <p>Once the new PR is available merge the PR into the main branch. Normally this will also trigger publication of the new release.</p>"},{"location":"about/contributing/#publish","title":"Publish","text":"<p>publish-to-pypi.yml is the workflow that publishes the release. It starts on a push to the main branch but can also be manually triggered. It will always publish to TestPyPI on a push. If the git head has a tag starting with 'v' it will also publish to PyPi. If it is published to PyPI successfully, it will also create a Github release.</p>"},{"location":"about/contributing/#run-ci-checks-locally","title":"Run ci checks locally","text":"<p>You can run tests locally to see if there is anything that might be caught by CI.</p> <pre><code>uvx prek run -a\nuv run pytest -vv --cov --cov-fail-under=100\nuv run basedpyright\nuv run mkdocs build -s\n</code></pre> <p>Note</p> <p>CI checks also run for a matrix of OS's and python versions. So even if all tests pass locally, tests can still fail for another os or python version.</p> <ol> <li> <p>This workflow also runs on push to the main branch, but will instead publish to TestPyPI.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Alan Fleming.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished \nto do so, subject to the following conditions:\n\nThe above copyright notice, shall be included in all copies or substantial \nportions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Notebooks<sup>1</sup> in this documentation show the result of each cell after executing for a short duration (~100ms).</p> <p>You can download the notebook with the button at the top right of the page for the notebook.</p> <ol> <li> <p>Further detail about how notebooks are generated is provided here.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebooks/caller/","title":"Caller","text":"In\u00a0[1]: Copied! <pre># A magic method provided by async kernel\n%callers\n</pre> # A magic method provided by async kernel %callers <pre>     Name    Running Protected                         Thread                         </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell           \u2713       \ud83d\udd10    &lt;_MainThread(MainThread, started 139999545806976)&gt; \u2190 current</pre> <pre>\n</pre> <pre>Control         \u2713       \ud83d\udd10    &lt;Thread(Control, started 139999472232128)&gt;</pre> <pre>\n</pre> In\u00a0[2]: Copied! <pre>from async_kernel import Caller\n\nCaller.get()\n</pre> from async_kernel import Caller  Caller.get() <pre>Caller&lt;Shell asyncio \ud83c\udfc3 \ud83e\uddd2 ['Control']&gt;</pre> In\u00a0[3]: suppress-error Copied! <pre>import random\nimport time\n\nimport ipywidgets as ipw\n\noutputs = {}\n\n\ndef my_func(n):\n    caller = Caller.get()\n    if not (out := outputs.get(caller)):\n        outputs[caller] = out = ipw.HTML(description=str(caller))\n        out.style.description_width = \"220px\"\n        display(out)\n    sleep_time = random.random() / 4\n    out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"\n    time.sleep(sleep_time)\n    return n\n\n\nasync def run_forever():\n    n = 0\n    while True:\n        n += 1\n        yield Caller.get().to_thread(my_func, n)\n\n\nasync for fut in Caller.get().as_completed(run_forever()):\n    result = await fut\n    print(f\"Finished: {result}\", end=\"\\r\")\n</pre> import random import time  import ipywidgets as ipw  outputs = {}   def my_func(n):     caller = Caller.get()     if not (out := outputs.get(caller)):         outputs[caller] = out = ipw.HTML(description=str(caller))         out.style.description_width = \"220px\"         display(out)     sleep_time = random.random() / 4     out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"     time.sleep(sleep_time)     return n   async def run_forever():     n = 0     while True:         n += 1         yield Caller.get().to_thread(my_func, n)   async for fut in Caller.get().as_completed(run_forever()):     result = await fut     print(f\"Finished: {result}\", end=\"\\r\") <pre>HTML(value='', description='Caller&lt;Thread-3 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-5 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-6 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-4 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-7 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-8 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-9 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_wi\u2026</pre> <pre>HTML(value='', description='Caller&lt;Thread-10 (async_kernel_caller) asyncio \ud83c\udfc3 &gt;', style=HTMLStyle(description_w\u2026</pre> <pre></pre> In\u00a0[4]: Copied! <pre>%callers\n</pre> %callers <pre>                 Name                Running Protected                                 Thread                                 </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell                                   \u2713       \ud83d\udd10    &lt;_MainThread(MainThread, started 139999545806976)&gt; \u2190 current</pre> <pre>\n</pre> <pre>Control                                 \u2713       \ud83d\udd10    &lt;Thread(Control, started 139999472232128)&gt;</pre> <pre>\n</pre> <pre>Thread-3 (async_kernel_caller)          \u2713            &lt;Thread(Thread-3 (async_kernel_caller), started 139998988850880)&gt;</pre> <pre>\n</pre> <pre>Thread-4 (async_kernel_caller)          \u2713            &lt;Thread(Thread-4 (async_kernel_caller), started 139998753978048)&gt;</pre> <pre>\n</pre> <pre>Thread-5 (async_kernel_caller)          \u2713            &lt;Thread(Thread-5 (async_kernel_caller), started 139998737196736)&gt;</pre> <pre>\n</pre> <pre>Thread-6 (async_kernel_caller)          \u2713            &lt;Thread(Thread-6 (async_kernel_caller), started 139998720415424)&gt;</pre> <pre>\n</pre> <pre>Thread-7 (async_kernel_caller)          \u2713            &lt;Thread(Thread-7 (async_kernel_caller), started 139998485542592)&gt;</pre> <pre>\n</pre> <pre>Thread-8 (async_kernel_caller)          \u2713            &lt;Thread(Thread-8 (async_kernel_caller), started 139998468761280)&gt;</pre> <pre>\n</pre> <pre>Thread-9 (async_kernel_caller)          \u2713            &lt;Thread(Thread-9 (async_kernel_caller), started 139998451979968)&gt;</pre> <pre>\n</pre> <pre>Thread-10 (async_kernel_caller)         \u2713            &lt;Thread(Thread-10 (async_kernel_caller), started 139998217107136)&gt;</pre> <pre>\n</pre> <pre>Thread-11 (async_kernel_caller)         \u2713            &lt;Thread(Thread-11 (async_kernel_caller), started 139998200325824)&gt;</pre> <pre>\n</pre>"},{"location":"notebooks/caller/#caller","title":"Caller\u00b6","text":"<p><code>Caller</code> is a class that makes it easy to call code in different threads/tasks.</p> <p>One caller instance is created per thread, and each of those instances can be retrieved by name using the <code>Caller.get</code> provided there is a running asynchronous event loop.</p>"},{"location":"notebooks/caller/#threads","title":"Threads\u00b6","text":"<p>The caller manages a pool of worker threads (not related to anyio worker threads) or you can specify the name of a new thread which you can manage yourself. Each thread has its own anyio event loop in which the code will be called.</p> <p>Most methods that perform execution return an <code>async_kernel.Pending</code> instance. The result can be obtained by awaiting it.</p>"},{"location":"notebooks/caller/#usage-by-the-kernel","title":"Usage by the kernel\u00b6","text":"<p>The kernel uses two <code>Caller</code> instances; one each for <code>shell</code> and <code>control</code>. The shell thread event loop is normally the <code>MainThread</code>, but is the thread wherever the kernel is started. The control event loop is always named <code>ControlThread</code> and is in the children of the shell caller. The caller instances are stored on the kernel at <code>kernel.callers[SocketID]</code>.</p>"},{"location":"notebooks/caller/#example","title":"Example\u00b6","text":"<p>This example requires ipywidgets!</p>"},{"location":"notebooks/concurrency/","title":"Concurrency","text":"In\u00a0[1]: Copied! <pre>from async_kernel import utils\nfrom async_kernel.typing import MsgType\n\nkernel = utils.get_kernel()\n\nkernel.get_run_mode(MsgType.comm_msg)\n</pre> from async_kernel import utils from async_kernel.typing import MsgType  kernel = utils.get_kernel()  kernel.get_run_mode(MsgType.comm_msg) <pre>&lt;RunMode.queue: 'queue'&gt;</pre> <p>Below is a list of the run modes according to the message type and channel (SocketID).</p> In\u00a0[2]: Copied! <pre>data = kernel.all_concurrency_run_modes()\ntry:\n    import pandas as pd\nexcept ImportError:\n    print(data)\nelse:\n    data = pd.DataFrame(data)\n    data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")\n    data = data.pivot(index=\"MsgType\", columns=[\"SocketID\"], values=\"RunMode\")  # noqa: PD010\n    data = data.reindex([\"shell\", \"control\"], axis=1)\n    display(data)\n</pre> data = kernel.all_concurrency_run_modes() try:     import pandas as pd except ImportError:     print(data) else:     data = pd.DataFrame(data)     data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")     data = data.pivot(index=\"MsgType\", columns=[\"SocketID\"], values=\"RunMode\")  # noqa: PD010     data = data.reindex([\"shell\", \"control\"], axis=1)     display(data) SocketID shell control MsgType comm_close queue queue comm_info_request queue queue comm_msg queue queue comm_open queue queue complete_request queue queue debug_request None queue execute_request queue task history_request thread thread inspect_request thread thread interrupt_request queue queue is_complete_request queue queue kernel_info_request queue queue shutdown_request None queue In\u00a0[3]: Copied! <pre>async def demo():\n    import threading\n\n    from aiologic import Event\n    from ipywidgets import Button\n\n    print(f\"Thread name: '{threading.current_thread().name}'\")\n    button = Button(description=\"Finish\")\n    event = Event()\n    button.on_click(lambda _: event.set())\n    display(button)\n    await event\n    button.close()\n    print(f\"Finished ... thread name: '{threading.current_thread().name}'\")\n    return \"Finished\"\n</pre> async def demo():     import threading      from aiologic import Event     from ipywidgets import Button      print(f\"Thread name: '{threading.current_thread().name}'\")     button = Button(description=\"Finish\")     event = Event()     button.on_click(lambda _: event.set())     display(button)     await event     button.close()     print(f\"Finished ... thread name: '{threading.current_thread().name}'\")     return \"Finished\" <p>Lets run it normally (queue)</p> In\u00a0[4]: suppress-error Copied! <pre>await demo()\n</pre> await demo() <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[5]: suppress-error Copied! <pre>##task\n# Tip: try running this cell while the previous cell is still busy.\nawait demo()\n</pre> ##task # Tip: try running this cell while the previous cell is still busy. await demo() <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[6]: thread suppress-error Copied! <pre># This time we'll use the tag to run the cell in a Thread\nawait demo()\n</pre> # This time we'll use the tag to run the cell in a Thread await demo() <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[7]: Copied! <pre>##thread\n%callers # magic provided by async kernel\n</pre> ##thread %callers # magic provided by async kernel <pre>                Name                Running Protected                                 Thread                                </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell                                  \u2713       \ud83d\udd10    &lt;_MainThread(MainThread, started 140579116093568)&gt;</pre> <pre>\n</pre> <pre>Control                                \u2713       \ud83d\udd10    &lt;Thread(Control, started 140578977216192)&gt;</pre> <pre>\n</pre> <pre>Thread-3 (async_kernel_caller)         \u2713            &lt;Thread(Thread-3 (async_kernel_caller), started 140578171344576)&gt; \u2190 current</pre> <pre>\n</pre>"},{"location":"notebooks/concurrency/#concurrency","title":"Concurrency\u00b6","text":"<p>Async kernel handles message requests concurrently. How the request is handled is a function of the channel and message type.</p> <p>The following <code>RunModes</code> are provided.</p> <ul> <li>direct: Run the handler directly in the message loop (recommend only for short running code)</li> <li>queue: Run in a queue (default for the <code>shell</code> channel)</li> <li>task: Run in a task (default for the <code>control</code> channel)</li> <li>thread: Run in a worker thread</li> </ul> <p>The kernel decides the run mode dynamically with the method get_run_mode.</p>"},{"location":"notebooks/concurrency/#execute-request-run-mode","title":"Execute request run mode\u00b6","text":"<p>There are a few options to modify how code cells are run.</p> <ul> <li>Metadata</li> <li>Directly in code</li> <li>tags</li> <li>Message header (in custom messages)</li> </ul> <p>Warning</p> <p>Only Jupyter lab is known to allow concurrent execution of cells.</p>"},{"location":"notebooks/concurrency/#code-for-example","title":"Code for example\u00b6","text":"<ul> <li>This example requires ipywidgets</li> <li>Ensure you are running an async kernel</li> </ul> <p>Lets define a function that we'll reuse for the remainder of the notebook.</p>"},{"location":"notebooks/concurrency/#run-mode-task","title":"Run mode: task\u00b6","text":"<p>The <code>task</code> mode instructs the kernel to execute the code in a task separate to the queue, Both <code>task</code> and <code>thread</code> execute modes can be started when the kernel is busy executing. There is no imposed limitation on the number of tasks (or threads) that can be run concurrently.</p> <p>See also the Caller example on how to call directly.</p>"},{"location":"notebooks/concurrency/#run-mode-thread","title":"Run mode: thread\u00b6","text":""},{"location":"notebooks/simple_example/","title":"Simple example","text":"In\u00a0[1]: Copied! <pre>import ipywidgets as ipw\nfrom aiologic import Event\n\nfrom async_kernel import Caller, utils\n\n\nasync def demo():\n    %callers\n    caller = Caller()  # Use caller set the event in the waiting thread\n    b = ipw.Button(description=\"Continue\")\n    display(b)\n    for i in range(1, 3):\n        b.description = f\"Continue {i}\"\n        event = Event()\n        b.on_click(lambda _: caller.call_soon(event.set))  # noqa: B023\n        print(f\"Waiting {i}\", end=\"\\r\")\n        await event\n    b.close()\n    print(\"\\nDone!\")\n</pre> import ipywidgets as ipw from aiologic import Event  from async_kernel import Caller, utils   async def demo():     %callers     caller = Caller()  # Use caller set the event in the waiting thread     b = ipw.Button(description=\"Continue\")     display(b)     for i in range(1, 3):         b.description = f\"Continue {i}\"         event = Event()         b.on_click(lambda _: caller.call_soon(event.set))  # noqa: B023         print(f\"Waiting {i}\", end=\"\\r\")         await event     b.close()     print(\"\\nDone!\") In\u00a0[2]: suppress-error Copied! <pre>print(utils.get_tags())\nawait demo()\n</pre> print(utils.get_tags()) await demo() <pre>[]</pre> <pre>\n</pre> <pre>     Name    Running Protected                         Thread                         </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell           \u2713       \ud83d\udd10    &lt;_MainThread(MainThread, started 139675056881792)&gt; \u2190 current</pre> <pre>\n</pre> <pre>Control         \u2713       \ud83d\udd10    &lt;Thread(Control, started 139674985277120)&gt;</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[3]: suppress-error Copied! <pre>##task\nawait demo()\n</pre> ##task await demo() <pre>     Name    Running Protected                         Thread                         </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell           \u2713       \ud83d\udd10    &lt;_MainThread(MainThread, started 139675056881792)&gt; \u2190 current</pre> <pre>\n</pre> <pre>Control         \u2713       \ud83d\udd10    &lt;Thread(Control, started 139674985277120)&gt;</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[4]: suppress-error Copied! <pre>##thread\nawait demo()\n</pre> ##thread await demo() <pre>                Name                Running Protected                                 Thread                                </pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>Shell                                  \u2713       \ud83d\udd10    &lt;_MainThread(MainThread, started 139675056881792)&gt;</pre> <pre>\n</pre> <pre>Control                                \u2713       \ud83d\udd10    &lt;Thread(Control, started 139674985277120)&gt;</pre> <pre>\n</pre> <pre>Thread-3 (async_kernel_caller)         \u2713            &lt;Thread(Thread-3 (async_kernel_caller), started 139674349729472)&gt; \u2190 current</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[5]: suppress-error Copied! <pre>async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):\n    pass\n</pre> async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):     pass <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):\n      2     pass\n\nTypeError: Caller.as_completed() missing 1 required positional argument: 'items'</pre>"},{"location":"notebooks/simple_example/#overview","title":"Overview\u00b6","text":"<p>This example demonstrates different ways that the same code can be executed. This is an overview of the four cells shown in the animation below.</p> <ol> <li>Define the coroutine function.<ol> <li>Cell 'magic' <code>%callers</code> prints a list of Caller instances and the thread in which it is executing.</li> <li>A button is created and and it runs a loop twice:<ol> <li>Creates any anyio event.</li> <li>Prints a statement.</li> <li>Waits for the button click to set the event.</li> </ol> </li> </ol> </li> <li>Execute <code>demo</code> normally.</li> <li>Execute <code>demo</code> concurrently in a task.</li> <li>Execute <code>demo</code> in a thread.</li> </ol> <p></p>"},{"location":"notebooks/simple_example/#calleras_completed","title":"Caller.as_completed\u00b6","text":"<p>See also: the caller notebook.</p>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides documentation for each module in async kernel.</p>"},{"location":"reference/#highlights","title":"Highlights","text":"<ul> <li>Kernel - The kernel.</li> <li>Caller - Simplifies event loop management and call scheduling.</li> <li>Pending - Represents a pending result that can be set, [a]waited and cancelled across threads.</li> <li>command_line - The command line interface.</li> </ul>"},{"location":"reference/asyncshell/","title":"asyncshell","text":"<p>Classes:</p> <ul> <li> <code>AsyncDisplayHook</code>           \u2013            <p>A displayhook subclass that publishes data using async_kernel.Kernel.iopub_send.</p> </li> <li> <code>AsyncDisplayPublisher</code>           \u2013            <p>A display publisher that publishes data using async_kernel.Kernel.iopub_send.</p> </li> <li> <code>AsyncInteractiveShell</code>           \u2013            <p>An IPython InteractiveShell adapted to work with Async kernel.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook","title":"async_kernel.asyncshell.AsyncDisplayHook","text":"<p>               Bases: <code>DisplayHook</code></p> <p>A displayhook subclass that publishes data using async_kernel.Kernel.iopub_send.</p> <p>This is intended to work with an InteractiveShell instance. It sends a dict of different representations of the object.</p> <p>Methods:</p> <ul> <li> <code>start_displayhook</code>             \u2013              <p>Start the display hook.</p> </li> <li> <code>write_output_prompt</code>             \u2013              <p>Write the output prompt.</p> </li> <li> <code>write_format_data</code>             \u2013              <p>Write format data to the message.</p> </li> <li> <code>finish_displayhook</code>             \u2013              <p>Finish up all displayhook activities.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.start_displayhook","title":"start_displayhook","text":"<pre><code>start_displayhook() -&gt; None\n</code></pre> <p>Start the display hook.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef start_displayhook(self) -&gt; None:\n    \"\"\"Start the display hook.\"\"\"\n    self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_output_prompt","title":"write_output_prompt","text":"<pre><code>write_output_prompt() -&gt; None\n</code></pre> <p>Write the output prompt.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_output_prompt(self) -&gt; None:\n    \"\"\"Write the output prompt.\"\"\"\n    self.content[\"execution_count\"] = self.prompt_count\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_format_data","title":"write_format_data","text":"<pre><code>write_format_data(format_dict, md_dict=None) -&gt; None\n</code></pre> <p>Write format data to the message.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_format_data(self, format_dict, md_dict=None) -&gt; None:\n    \"\"\"Write format data to the message.\"\"\"\n    self.content[\"data\"] = format_dict\n    self.content[\"metadata\"] = md_dict\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.finish_displayhook","title":"finish_displayhook","text":"<pre><code>finish_displayhook() -&gt; None\n</code></pre> <p>Finish up all displayhook activities.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef finish_displayhook(self) -&gt; None:\n    \"\"\"Finish up all displayhook activities.\"\"\"\n    if self.content:\n        self.kernel.iopub_send(\"display_data\", content=self.content)\n        self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher","title":"async_kernel.asyncshell.AsyncDisplayPublisher","text":"<pre><code>AsyncDisplayPublisher(shell=None, *args, **kwargs)\n</code></pre> <p>               Bases: <code>DisplayPublisher</code></p> <p>A display publisher that publishes data using async_kernel.Kernel.iopub_send.</p> <p>Methods:</p> <ul> <li> <code>publish</code>             \u2013              <p>Publish a display-data message.</p> </li> <li> <code>clear_output</code>             \u2013              <p>Clear output associated with the current execution (cell).</p> </li> <li> <code>register_hook</code>             \u2013              <p>Register a hook for when publish is called.</p> </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def __init__(self, shell=None, *args, **kwargs) -&gt; None:\n    super().__init__(shell, *args, **kwargs)\n    self._hooks = []\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish","title":"publish","text":"<pre><code>publish(\n    data: dict[str, Any],\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None\n</code></pre> <p>Publish a display-data message.</p> <p>Parameters:</p> <p>Reference</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef publish(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self,\n    data: dict[str, Any],\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Publish a display-data message.\n\n    Args:\n        data: A mime-bundle dict, keyed by mime-type.\n        metadata: Metadata associated with the data.\n        transient: Transient data that may only be relevant during a live display, such as display_id.\n            Transient data should not be persisted to documents.\n        update: If True, send an update_display_data message instead of display_data.\n\n    [Reference](https://jupyter-client.readthedocs.io/en/stable/messaging.html#update-display-data)\n    \"\"\"\n    content = {\"data\": data, \"metadata\": metadata or {}, \"transient\": transient or {}} | kwargs\n    msg_type = \"update_display_data\" if update else \"display_data\"\n    msg = utils.get_kernel().session.msg(msg_type, content, parent=utils.get_parent())  # pyright: ignore[reportArgumentType]\n    for hook in self._hooks:\n        try:\n            msg = hook(msg)\n        except Exception:\n            pass\n        if msg is None:\n            return\n    utils.get_kernel().iopub_send(msg)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(data)","title":"<code>data</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>A mime-bundle dict, keyed by mime-type.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(metadata)","title":"<code>metadata</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata associated with the data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(transient)","title":"<code>transient</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Transient data that may only be relevant during a live display, such as display_id. Transient data should not be persisted to documents.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(update)","title":"<code>update</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, send an update_display_data message instead of display_data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output","title":"clear_output","text":"<pre><code>clear_output(wait: bool = False) -&gt; None\n</code></pre> <p>Clear output associated with the current execution (cell).</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef clear_output(self, wait: bool = False) -&gt; None:\n    \"\"\"\n    Clear output associated with the current execution (cell).\n\n    Args:\n        wait: If True, the output will not be cleared immediately,\n            instead waiting for the next display before clearing.\n            This reduces bounce during repeated clear &amp; display loops.\n    \"\"\"\n    utils.get_kernel().iopub_send(msg_or_type=\"clear_output\", content={\"wait\": wait}, ident=self.topic)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output(wait)","title":"<code>wait</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the output will not be cleared immediately, instead waiting for the next display before clearing. This reduces bounce during repeated clear &amp; display loops.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.register_hook","title":"register_hook","text":"<pre><code>register_hook(hook: Callable[[dict], dict | None]) -&gt; None\n</code></pre> <p>Register a hook for when publish is called.</p> <p>The hook should return the message or None. Only return <code>None</code> when the message should not be sent.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>def register_hook(self, hook: Callable[[dict], dict | None]) -&gt; None:\n    \"\"\"Register a hook for when publish is called.\n\n    The hook should return the message or None.\n    Only return `None` when the message should *not* be sent.\n    \"\"\"\n    self._hooks.append(hook)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell","title":"async_kernel.asyncshell.AsyncInteractiveShell","text":"<p>               Bases: <code>InteractiveShell</code></p> <p>An IPython InteractiveShell adapted to work with Async kernel.</p> Notable differences <ul> <li>All execute requests are run asynchronously.</li> <li>Supports a soft timeout specified via metadata <code>{\"timeout\":&lt;value in seconds&gt;}</code><sup>1</sup>.</li> <li>Gui event loops(tk, qt, ...) are not presently supported.</li> <li>Not all features are support (see \"not-supported\" features listed below).</li> </ul> <ol> <li> <p>When the execution time exceeds the timeout value, the code execution will \"move on\".\u00a0\u21a9</p> </li> </ol> Referenced by: <ul> <li> Reference kernel <ul> <li> <code></code>\u00a0Kernel </li> <li> <code></code>\u00a0kernel </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0shell </li> </ul> <p>Methods:</p> <ul> <li> <code>run_cell_async</code>             \u2013              <p>Run a complete IPython cell asynchronously.</p> </li> <li> <code>init_magics</code>             \u2013              <p>Initialize magics.</p> </li> <li> <code>enable_gui</code>             \u2013              <p>Enable a given gui.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>execute_request_timeout</code>           \u2013            <p>A timeout in seconds to complete execute requests.</p> </li> <li> <code>run_cell</code>           \u2013            <p>Not supported -  use run_cell_async instead.</p> </li> <li> <code>debug</code>           \u2013            <p>Not supported - use the built in debugger instead.</p> </li> <li> <code>kernel</code>               (<code>Kernel</code>)           \u2013            <p>The current kernel.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.execute_request_timeout","title":"execute_request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request_timeout = CFloat(default_value=None, allow_none=True)\n</code></pre> <p>A timeout in seconds to complete execute requests.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.run_cell","title":"run_cell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_cell = None\n</code></pre> <p>Not supported -  use run_cell_async instead.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug = None\n</code></pre> <p>Not supported - use the built in debugger instead.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.kernel","title":"kernel  <code>property</code>","text":"<pre><code>kernel: Kernel\n</code></pre> <p>The current kernel.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.run_cell_async","title":"run_cell_async  <code>async</code>","text":"<pre><code>run_cell_async(\n    raw_cell: str,\n    store_history=False,\n    silent=False,\n    shell_futures=True,\n    *,\n    transformed_cell: str | None = None,\n    preprocessing_exc_tuple: tuple | None = None,\n    cell_id: str | None = None,\n) -&gt; ExecutionResult\n</code></pre> <p>Run a complete IPython cell asynchronously.</p> <p>This function runs execute requests for the kernel wrapping InteractiveShell.</p> Referenced by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveShell </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\nasync def run_cell_async(\n    self,\n    raw_cell: str,\n    store_history=False,\n    silent=False,\n    shell_futures=True,\n    *,\n    transformed_cell: str | None = None,\n    preprocessing_exc_tuple: tuple | None = None,\n    cell_id: str | None = None,\n) -&gt; ExecutionResult:\n    \"\"\"\n    Run a complete IPython cell asynchronously.\n\n    This function runs [execute requests][async_kernel.Kernel.execute_request] for the kernel\n    wrapping [InteractiveShell][IPython.core.interactiveshell.InteractiveShell.run_cell_async].\n    \"\"\"\n    with anyio.fail_after(delay=utils.get_execute_request_timeout()):\n        result: ExecutionResult = await super().run_cell_async(\n            raw_cell=raw_cell,\n            store_history=store_history,\n            silent=silent,\n            shell_futures=shell_futures,\n            transformed_cell=transformed_cell,\n            preprocessing_exc_tuple=preprocessing_exc_tuple,\n            cell_id=cell_id,\n        )\n    self.events.trigger(\"post_execute\")\n    if not silent:\n        self.events.trigger(\"post_run_cell\", result)\n    return result\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.init_magics","title":"init_magics","text":"<pre><code>init_magics() -&gt; None\n</code></pre> <p>Initialize magics.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef init_magics(self) -&gt; None:\n    \"\"\"Initialize magics.\"\"\"\n    super().init_magics()\n    self.register_magics(KernelMagics)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.enable_gui","title":"enable_gui","text":"<pre><code>enable_gui(gui=None) -&gt; None\n</code></pre> <p>Enable a given gui.</p> Supported guis <ul> <li> inline</li> <li> ipympl</li> <li> tk</li> <li> qt</li> </ul> Referenced by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveShell </li> </ul> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef enable_gui(self, gui=None) -&gt; None:\n    \"\"\"\n    Enable a given gui.\n\n    Supported guis:\n        - [x] inline\n        - [x] ipympl\n        - [ ] tk\n        - [ ] qt\n    \"\"\"\n    supported_no_eventloop = [None, \"inline\", \"ipympl\"]\n    if gui not in supported_no_eventloop:\n        msg = f\"The backend {gui=} is not supported by async-kernel. The currently supported gui options are: {supported_no_eventloop}.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/caller/","title":"caller","text":"<p>Classes:</p> <ul> <li> <code>Caller</code>           \u2013            <p>Caller is a task scheduler for running functions in a dedicated thread with an AnyIO event loop.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller","title":"async_kernel.caller.Caller","text":"<p>               Bases: <code>AsyncContextManagerMixin</code></p> <p>Caller is a task scheduler for running functions in a dedicated thread with an AnyIO event loop.</p> <p>This class manages the execution of callables in a thread-safe manner, providing mechanisms for scheduling, queuing, and managing the lifecycle of tasks and their associated threads and event loops. It supports advanced features such as delayed execution, per-function queues, cancellation, and specification of the AnyIO supported backend.</p> Key Features <ul> <li>One Caller instance per thread, accessible via class methods.</li> <li>Thread-safe scheduling of synchronous and asynchronous functions.</li> <li>Support for delayed and immediate execution (<code>call_later</code>, <code>call_soon</code>).</li> <li>Per-function execution queues with lifecycle management (<code>queue_call</code>, <code>queue_close</code>).</li> <li>Integration with AnyIO's async context management and task groups.</li> <li>Mechanisms for stopping, protecting, and pooling Caller instances.</li> <li>Utilities for running functions in separate threads (<code>to_thread</code>, <code>to_thread_advanced</code>).</li> <li>Methods for waiting on and iterating over multiple pending instances as they complete.</li> <li>IOpub socket per Caller instance.</li> <li>Threads</li> </ul> Usage <ul> <li>Use <code>Caller.get()</code> to get or create a Caller instances.</li> <li>Use <code>caller.get()</code> (same method from a caller instance) for inherited stopping.</li> <li>Use <code>call_soon</code>, <code>call_later</code>, or <code>schedule_call</code> to schedule work.</li> <li>Use <code>queue_call</code> for per-function task queues.</li> <li>Use <code>to_thread</code> to run work in a separate thread.</li> <li>Use <code>as_completed</code> and <code>wait</code> to manage multiple Pendings.</li> <li>Use <code>async with Caller(\"new\") = caller:</code> to use Caller as an     asynchronous context manager (useful to provide pytest fixtures for example).</li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>For invalid operations such as duplicate Caller creation or missing instances.</p> </li> <li> <code>ClosedResourceError</code>             \u2013            <p>When scheduling on a stopped Caller.</p> </li> </ul> Notes <ul> <li>It is safe to use the underlying libraries taskgroups</li> <li>aiologic provides thread-safe synchronisation primiates for working across threads.</li> <li>Once a caller is stopped it cannot be restarted, instead a new caller should be started.</li> </ul> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> typing <ul> <li> <code></code>\u00a0CallerCreateOptions </li> <li> <code></code>\u00a0typing </li> </ul> </li> </ul> </li> </ul> Returned by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <code></code>\u00a0all_callers </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0callers </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0schedule_job </li> </ul> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>Creates or retrieves an instance of the caller for a specific thread.</p> </li> <li> <code>get</code>             \u2013              <p>Retrieve or create a Caller instance associated with a specific thread or context.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the caller, cancelling all pending tasks and close the thread.</p> </li> <li> <code>current_pending</code>             \u2013              <p>A classmethod that returns the current result when called from inside a function scheduled by Caller.</p> </li> <li> <code>all_callers</code>             \u2013              <p>A classmethod to get a list of the callers.</p> </li> <li> <code>to_thread</code>             \u2013              <p>Call func in a worker thread using the same backend as the current instance.</p> </li> <li> <code>to_thread_advanced</code>             \u2013              <p>Call func in a current or new Caller according to the options.</p> </li> <li> <code>schedule_call</code>             \u2013              <p>Schedule <code>func</code> to be called inside a task running in the callers thread (thread-safe).</p> </li> <li> <code>call_later</code>             \u2013              <p>Schedule func to be called in caller's event loop copying the current context.</p> </li> <li> <code>call_soon</code>             \u2013              <p>Schedule func to be called in caller's event loop copying the current context.</p> </li> <li> <code>call_direct</code>             \u2013              <p>Schedule <code>func</code> to be called in caller's event loop directly.</p> </li> <li> <code>queue_get</code>             \u2013              <p>Returns <code>Pending</code> instance for <code>func</code> where the queue is running.</p> </li> <li> <code>queue_call</code>             \u2013              <p>Queue the execution of <code>func</code> in a queue unique to it and the caller instance (thread-safe).</p> </li> <li> <code>queue_close</code>             \u2013              <p>Close the execution queue associated with <code>func</code> (thread-safe).</p> </li> <li> <code>as_completed</code>             \u2013              <p>A classmethod iterator to get result as they complete.</p> </li> <li> <code>wait</code>             \u2013              <p>A classmethod to wait for the results given by items to complete.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>MAX_IDLE_POOL_INSTANCES</code>           \u2013            <p>The number of <code>pool</code> instances to leave idle (See also to_thread).</p> </li> <li> <code>stopped</code>           \u2013            <p>A thread-safe Event for when the caller is stopped.</p> </li> <li> <code>log</code>               (<code>LoggerAdapter[Any]</code>)           \u2013            </li> <li> <code>iopub_sockets</code>               (<code>WeakKeyDictionary[Thread, Socket]</code>)           \u2013            </li> <li> <code>iopub_url</code>               (<code>ClassVar</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the thread when the caller was created.</p> </li> <li> <code>thread</code>               (<code>Thread</code>)           \u2013            <p>The thread in which the caller will run.</p> </li> <li> <code>backend</code>               (<code>Backend</code>)           \u2013            <p>The <code>anyio</code> backend the caller is running in.</p> </li> <li> <code>protected</code>               (<code>bool</code>)           \u2013            <p>Returns <code>True</code> if the caller is protected from stopping.</p> </li> <li> <code>zmq_context</code>               (<code>Context | None</code>)           \u2013            <p>A zmq socket, which if present indicates that an iopub socket is loaded.</p> </li> <li> <code>running</code>           \u2013            <p>Returns <code>True</code> when the caller is available to run requests.</p> </li> <li> <code>children</code>               (<code>set[Self]</code>)           \u2013            <p>A copy of the set of instances that were created by the caller.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller.MAX_IDLE_POOL_INSTANCES","title":"MAX_IDLE_POOL_INSTANCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_IDLE_POOL_INSTANCES = 10\n</code></pre> <p>The number of <code>pool</code> instances to leave idle (See also to_thread).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stopped","title":"stopped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopped = Fixed(Event)\n</code></pre> <p>A thread-safe Event for when the caller is stopped.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: LoggerAdapter[Any]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.iopub_sockets","title":"iopub_sockets  <code>class-attribute</code>","text":"<pre><code>iopub_sockets: WeakKeyDictionary[Thread, Socket] = WeakKeyDictionary()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.iopub_url","title":"iopub_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub_url: ClassVar = 'inproc://iopub'\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the thread when the caller was created.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.thread","title":"thread  <code>property</code>","text":"<pre><code>thread: Thread\n</code></pre> <p>The thread in which the caller will run.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: Backend\n</code></pre> <p>The <code>anyio</code> backend the caller is running in.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.protected","title":"protected  <code>property</code>","text":"<pre><code>protected: bool\n</code></pre> <p>Returns <code>True</code> if the caller is protected from stopping.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.zmq_context","title":"zmq_context  <code>property</code>","text":"<pre><code>zmq_context: Context | None\n</code></pre> <p>A zmq socket, which if present indicates that an iopub socket is loaded.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre> <p>Returns <code>True</code> when the caller is available to run requests.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.children","title":"children  <code>property</code>","text":"<pre><code>children: set[Self]\n</code></pre> <p>A copy of the set of instances that were created by the caller.</p> Notes <ul> <li>When the parent is stopped, all children are stopped.</li> <li>All children are stopped prior to the parent exiting its async context.</li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__","title":"__new__","text":"<pre><code>__new__(\n    mode: Literal[\"existing\", \"new\"] = \"existing\",\n    /,\n    **kwargs: Unpack[CallerCreateOptions],\n) -&gt; Self\n</code></pre> <p>Creates or retrieves an instance of the caller for a specific thread.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>An instance of the caller associated with the specified thread.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If a caller already exists for the specified thread when mode is \"new\".</p> </li> </ul> Notes <ul> <li>There is only one caller per thread.</li> <li>The caller can always be access by using 'thread'.</li> <li>Caller.get() is the recommended way to get a running caller.</li> <li>A caller retains its own pool of workers.</li> <li>When a caller is shutdown its children are shutdown.</li> <li>New instances are added an instances children create when called via the instance methods:<ul> <li> caller.to_thread</li> <li> caller.to_thread_advanced</li> <li> caller.get (called via the instance)</li> <li> Caller.get (called via the class)</li> </ul> </li> <li>The 'name' of children is always unique and can be used to retrieve it with the above selected methods.</li> </ul> <p>Uasge:</p> <pre><code>=== \"As a context manager\"\n\n    ```python\n    async with Caller(\"new\") as caller:\n        ...\n    ```\n\n=== \"From a thread with a backend eventloop\"\n\n    ```python\n    caller = Caller.get()\n    ```\n\n=== \"Start a new thread\"\n\n```python\nmy_caller = Caller.get(name=\"My new caller thread\")\n```\n</code></pre> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __new__(\n    cls,\n    mode: Literal[\"existing\", \"new\"] = \"existing\",\n    /,\n    **kwargs: Unpack[CallerCreateOptions],\n) -&gt; Self:\n    \"\"\"\n    Creates or retrieves an instance of the caller for a specific thread.\n\n    Args:\n        mode: Determines whether to retrieve an existing instance (\"existing\" (Default)) or create a new one (\"new\").\n        **kwargs: Additional options for caller creation, which may include:\n            - thread: The thread to associate with the caller. Defaults to the current thread.\n            - backend: The backend to use. Defaults to the current async library.\n            - name: Name for the caller instance. Defaults to the thread's name.\n            - log: LoggerAdapter for the instance.\n            - protected: Whether the instance is protected. Defaults to False.\n            - backend_options: Additional options for the backend.\n            - zmq_context: ZeroMQ context to use.\n\n    Returns:\n        Self: An instance of the caller associated with the specified thread.\n\n    Raises:\n        RuntimeError: If a caller already exists for the specified thread when mode is \"new\".\n\n    Notes:\n        - There is only **one caller per thread**.\n        - The caller can always be access by using 'thread'.\n        - [Caller.get()][Caller.get] is the recommended way to get a *running* caller.\n        - A caller retains its own pool of workers.\n        - When a caller is shutdown its children are shutdown.\n        - New instances are added an instances children create when called via the instance methods:\n            - [x] [caller.to_thread][Caller.to_thread]\n            - [x] [caller.to_thread_advanced][Caller.to_thread_advanced]\n            - [x] [caller.get][Caller.get] (called via the instance)\n            - [ ] [Caller.get][Caller.get] (called via the class)\n        - The 'name' of children is always unique and can be used to retrieve it with the above selected methods.\n\n    Uasge:\n\n        === \"As a context manager\"\n\n            ```python\n            async with Caller(\"new\") as caller:\n                ...\n            ```\n\n        === \"From a thread with a backend eventloop\"\n\n            ```python\n            caller = Caller.get()\n            ```\n\n        === \"Start a new thread\"\n\n        ```python\n        my_caller = Caller.get(name=\"My new caller thread\")\n        ```\n\n    \"\"\"\n\n    thread = kwargs.get(\"thread\") or threading.current_thread()\n    if mode == \"existing\":\n        return cls.get(\"existing\", thread=thread)\n    with cls._rlock:\n        if thread in cls._instances:\n            msg = f\"A caller already exists for {thread=}\"\n            raise RuntimeError(msg)\n        inst = super().__new__(cls)\n        inst._backend = Backend(kwargs.get(\"backend\") or current_async_library())\n        inst._thread = thread\n        inst._name = kwargs.get(\"name\") or thread.name or str(thread)\n        inst.log = kwargs.get(\"log\") or logging.LoggerAdapter(logging.getLogger())\n        inst._protected = kwargs.get(\"protected\", False)\n        inst._backend_options = kwargs.get(\"backend_options\")\n        inst._zmq_context = kwargs.get(\"zmq_context\")\n        inst._resume = noop\n        inst.get = inst._wrap_get()\n        cls._instances[thread] = inst\n    return inst\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(mode)","title":"<code>mode</code>","text":"(<code>Literal['existing', 'new']</code>, default:                   <code>'existing'</code> )           \u2013            <p>Determines whether to retrieve an existing instance (\"existing\" (Default)) or create a new one (\"new\").</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[CallerCreateOptions]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional options for caller creation, which may include: - thread: The thread to associate with the caller. Defaults to the current thread. - backend: The backend to use. Defaults to the current async library. - name: Name for the caller instance. Defaults to the thread's name. - log: LoggerAdapter for the instance. - protected: Whether the instance is protected. Defaults to False. - backend_options: Additional options for the backend. - zmq_context: ZeroMQ context to use.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(mode: CallerGetModeType = 'auto', /, **kwargs: Unpack[CallerCreateOptions]) -&gt; Self\n</code></pre> <p>Retrieve or create a Caller instance associated with a specific thread or context.</p> <p>This method attempts to return an existing Caller instance for the current or specified thread. If no such instance exists, it creates a new one, potentially launching it in a new thread or using the main thread, depending on the provided mode and options.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The Caller instance associated with the specified thread or context.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If a Caller instance cannot be found or created according to the mode and options, or if reserved names are used improperly.</p> </li> </ul> Notes <ul> <li>If called with mode=\"MainThread\", retrieves or creates a Caller for the main thread.</li> <li>If called with mode=\"existing\", only returns an existing Caller, raising if none is found.</li> <li>If a new Caller is created, it is started in a new thread or context as appropriate.</li> </ul> Referenced by: <ul> <li> Usage Usage Caller Caller.get </li> <li> Reference caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0__new__ </li> <li> <code></code>\u00a0to_thread_advanced </li> </ul> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef get(cls, mode: CallerGetModeType = \"auto\", /, **kwargs: Unpack[CallerCreateOptions]) -&gt; Self:\n    \"\"\"\n    Retrieve or create a Caller instance associated with a specific thread or context.\n\n    This method attempts to return an existing Caller instance for the current or specified thread.\n    If no such instance exists, it creates a new one, potentially launching it in a new thread or\n    using the main thread, depending on the provided mode and options.\n\n    Parameters:\n        mode: Determines how the Caller is retrieved or created.\n            - \"auto\": Default behavior, uses the current thread or creates a new one as needed.\n            - \"MainThread\": Forces retrieval or creation of a Caller for the main thread.\n            - \"existing\": Only retrieves an existing Caller; raises if none is found.\n        **kwargs: Additional options for Caller creation, such as:\n            - thread: The thread to associate with the Caller.\n            - name: Name for the new thread (if created).\n            - backend: Async backend to use.\n            - backend_options: Options for the async backend.\n\n    Returns:\n        Self: The Caller instance associated with the specified thread or context.\n\n    Raises:\n        RuntimeError: If a Caller instance cannot be found or created according to the mode and options,\n            or if reserved names are used improperly.\n\n    Notes:\n        - If called with mode=\"MainThread\", retrieves or creates a Caller for the main thread.\n        - If called with mode=\"existing\", only returns an existing Caller, raising if none is found.\n        - If a new Caller is created, it is started in a new thread or context as appropriate.\n    \"\"\"\n    with cls._rlock:\n        if (name := kwargs.get(\"name\")) and (name.lower() == \"mainthread\"):\n            msg = f'{name=} is reserved! To get the caller for the main thread use `Caller.get(\"MainThread\")`'\n            raise RuntimeError(msg)\n        if mode == \"MainThread\":\n            kwargs = {\"thread\": threading.main_thread()}\n        thread = threading.current_thread() if not kwargs else kwargs.get(\"thread\")\n        if thread and (caller := cls._instances.get(thread)):\n            return caller\n        if (mode == \"existing\") or (thread and (thread is not threading.current_thread())):\n            msg = f\"Caller instance not found for {kwargs=}\"\n            raise RuntimeError(msg)\n\n        async def run_caller_in_context(caller: Self) -&gt; None:\n            # run the caller in context\n            async with caller:\n                if not pen.done():\n                    pen.set_result(caller)\n                await caller.stopped\n\n        def async_kernel_caller(options: dict) -&gt; None:\n            try:\n                if token := options.get(\"token\"):\n                    # A 'shadow' thead to run the caller from the 'current thread'\n                    pen.set_result(caller_)\n                    mark_thread_pydev_do_not_trace()\n                    anyio.from_thread.run(run_caller_in_context, caller_, token=token)\n                else:\n                    anyio.run(run_caller_in_context, caller_, **options)\n            except (BaseExceptionGroup, BaseException) as e:\n                if not pen.done():\n                    pen.set_exception(e)\n                if not \"shutdown\" not in str(e):\n                    raise\n\n        if thread:\n            args = [{\"token\": current_token()}]\n        else:\n            kernel = async_kernel.Kernel()\n            backend = kwargs.get(\"backend\") or current_async_library(failsafe=True)\n            backend = Backend(value=backend or kernel.anyio_backend)\n            backend_options = kwargs.get(\"backend_options\", kernel.anyio_backend_options.get(backend))\n            args = [{\"backend\": backend, \"backend_options\": backend_options}]\n        # Create and start the caller\n        pen: Pending[Self] = Pending()\n        thread_ = threading.Thread(target=async_kernel_caller, name=kwargs.get(\"name\"), args=args)\n        kwargs[\"thread\"] = thread = thread or thread_\n        caller_ = cls._instances.get(thread) or cls(\"new\", **kwargs)\n    thread_.start()\n\n    return pen.wait_sync()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.get(mode)","title":"<code>mode</code>","text":"(<code>CallerGetModeType</code>, default:                   <code>'auto'</code> )           \u2013            <p>Determines how the Caller is retrieved or created. - \"auto\": Default behavior, uses the current thread or creates a new one as needed. - \"MainThread\": Forces retrieval or creation of a Caller for the main thread. - \"existing\": Only retrieves an existing Caller; raises if none is found.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[CallerCreateOptions]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional options for Caller creation, such as: - thread: The thread to associate with the Caller. - name: Name for the new thread (if created). - backend: Async backend to use. - backend_options: Options for the async backend.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop","title":"stop","text":"<pre><code>stop(*, force=False) -&gt; None\n</code></pre> <p>Stop the caller, cancelling all pending tasks and close the thread.</p> <p>If the instance is protected, this is no-op unless force is used.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def stop(self, *, force=False) -&gt; None:\n    \"\"\"\n    Stop the caller, cancelling all pending tasks and close the thread.\n\n    If the instance is protected, this is no-op unless force is used.\n    \"\"\"\n    if self._protected and not force:\n        return\n    self._running = False\n    self._instances.pop(self.thread, None)\n    self._worker_pool.clear()\n    while self._queue:\n        item = self._queue.pop()\n        if isinstance(item, tuple):\n            item[1].cancel()\n            item[1].set_result(None)\n    for func in tuple(self._queue_map):\n        self.queue_close(func)\n    self._resume()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.current_pending","title":"current_pending  <code>classmethod</code>","text":"<pre><code>current_pending() -&gt; Pending[Any] | None\n</code></pre> <p>A classmethod that returns the current result when called from inside a function scheduled by Caller.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef current_pending(cls) -&gt; Pending[Any] | None:\n    \"\"\"A [classmethod][] that returns the current result when called from inside a function scheduled by Caller.\"\"\"\n    return cls._pending_var.get()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers","title":"all_callers  <code>classmethod</code>","text":"<pre><code>all_callers(running_only: bool = True) -&gt; list[Caller]\n</code></pre> <p>A classmethod to get a list of the callers.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef all_callers(cls, running_only: bool = True) -&gt; list[Caller]:\n    \"\"\"\n    A [classmethod][] to get a list of the callers.\n\n    Args:\n        running_only: Restrict the list to callers that are active (running in an async context).\n    \"\"\"\n    return [caller for caller in Caller._instances.values() if caller._running or not running_only]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers(running_only)","title":"<code>running_only</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Restrict the list to callers that are active (running in an async context).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread","title":"to_thread","text":"<pre><code>to_thread(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Pending[T]\n</code></pre> <p>Call func in a worker thread using the same backend as the current instance.</p> <p>Parameters:</p> Notes <ul> <li>A minimum number of caller instances are retained for this method.</li> <li>Async code run inside func should use taskgroups for creating task.</li> </ul> See also <ul> <li>Caller.to_thread_advanced</li> </ul> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0MAX_IDLE_POOL_INSTANCES </li> <li> <code></code>\u00a0__new__ </li> <li> <code></code>\u00a0as_completed </li> </ul> </li> <li> typing <code></code>\u00a0RunMode <code></code>\u00a0thread </li> </ul> </li> <li> Usage Usage <ul> <li> Blocking code </li> <li> Caller </li> </ul> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def to_thread(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Call func in a worker thread using the same backend as the current instance.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Notes:\n        - A minimum number of caller instances are retained for this method.\n        - Async code run inside func should use taskgroups for creating task.\n\n    See also:\n        - [Caller.to_thread_advanced][]\n    \"\"\"\n    return self.to_thread_advanced({\"name\": None}, func, *args, **kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_advanced","title":"to_thread_advanced","text":"<pre><code>to_thread_advanced(\n    options: CallerCreateOptions,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Pending[T]\n</code></pre> <p>Call func in a current or new Caller according to the options.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Pending[T]</code>           \u2013            <p>A result that can be awaited for the  result of func.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When a name is not supplied.</p> </li> </ul> Notes <ul> <li>When <code>options == {\"name\": None}</code> the caller is associated with a pool of workers.</li> <li>When called via from an instance any new callers are added to the the instances children (done in <code>_catch_new_instances</code>).</li> </ul> Referenced by: <ul> <li> Reference caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0__new__ </li> <li> <code></code>\u00a0to_thread </li> </ul> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def to_thread_advanced(\n    self,\n    options: CallerCreateOptions,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Call func in a current or new Caller according to the options.\n\n    Args:\n        options: Options to pass to [Caller.get][].\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Returns:\n        A result that can be awaited for the  result of func.\n\n    Raises:\n        ValueError: When a name is not supplied.\n\n    Notes:\n        - When `options == {\"name\": None}` the caller is associated with a pool of workers.\n        - When called via from an instance any new callers are added to the the instances children (done in `_catch_new_instances`).\n    \"\"\"\n\n    if is_worker := options == {\"name\": None}:\n        try:\n            caller = self._worker_pool.popleft()\n        except IndexError:\n            caller = self.get(name=None)\n    else:\n        if not options.get(\"name\"):\n            msg = \"A name was not provided in {options=}.\"\n            raise ValueError(msg)\n        caller = self.get(**options)\n    pen = caller.call_soon(func, *args, **kwargs)\n    if is_worker:\n\n        def _to_thread_on_done(_) -&gt; None:\n            if not caller.stopped and self._running:\n                if len(self._worker_pool) &lt; self.MAX_IDLE_POOL_INSTANCES:\n                    self._worker_pool.append(caller)\n                else:\n                    caller.stop()\n\n        pen.add_done_callback(_to_thread_on_done)\n    return pen\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_advanced(options)","title":"<code>options</code>","text":"(<code>CallerCreateOptions</code>)           \u2013            <p>Options to pass to Caller.get.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_advanced(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_advanced(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_advanced(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call","title":"schedule_call","text":"<pre><code>schedule_call(\n    func: Callable[..., CoroutineType[Any, Any, T] | T],\n    /,\n    args: tuple,\n    kwargs: dict,\n    context: Context | None = None,\n    **metadata: Any,\n) -&gt; Pending[T]\n</code></pre> <p>Schedule <code>func</code> to be called inside a task running in the callers thread (thread-safe).</p> <p>The methods call_soon and call_later use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def schedule_call(\n    self,\n    func: Callable[..., CoroutineType[Any, Any, T] | T],\n    /,\n    args: tuple,\n    kwargs: dict,\n    context: contextvars.Context | None = None,\n    **metadata: Any,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule `func` to be called inside a task running in the callers thread (thread-safe).\n\n    The methods [call_soon][Caller.call_soon] and [call_later][Caller.call_later]\n    use this method in the background,  they should be used in preference to this method since they provide type hinting for the arguments.\n\n    Args:\n        func: The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.\n        args: Arguments corresponding to in the call to  `func`.\n        kwargs: Keyword arguments to use with in the call to `func`.\n        context: The context to use, if not provided the current context is used.\n        **metadata: Additional metadata to store in the instance.\n    \"\"\"\n    if self._running is False:\n        msg = f\"{self} is {'stopped' if self.stopped else 'stopping'}!\"\n        raise RuntimeError(msg)\n    pen = Pending(func=func, args=args, kwargs=kwargs, caller=self, **metadata)\n    self._queue.append((context or contextvars.copy_context(), pen))\n    self._resume()\n    return pen\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(func)","title":"<code>func</code>","text":"(<code>Callable[..., CoroutineType[Any, Any, T] | T]</code>)           \u2013            <p>The function to be called. If it returns a coroutine, it will be awaited and its result will be returned.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(args)","title":"<code>args</code>","text":"(<code>tuple</code>)           \u2013            <p>Arguments corresponding to in the call to  <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(kwargs)","title":"<code>kwargs</code>","text":"(<code>dict</code>)           \u2013            <p>Keyword arguments to use with in the call to <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(context)","title":"<code>context</code>","text":"(<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>The context to use, if not provided the current context is used.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.schedule_call(**metadata)","title":"<code>**metadata</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional metadata to store in the instance.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later","title":"call_later","text":"<pre><code>call_later(\n    delay: float,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Pending[T]\n</code></pre> <p>Schedule func to be called in caller's event loop copying the current context.</p> <p>Parameters:</p> Info <p>All call arguments are packed into the instance's metadata.</p> Referenced by: <ul> <li> Reference caller <code></code>\u00a0Caller <code></code>\u00a0schedule_call </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_later(\n    self,\n    delay: float,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule func to be called in caller's event loop copying the current context.\n\n    Args:\n        func: The function.\n        delay: The minimum delay to add between submission and execution.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Info:\n        All call arguments are packed into the instance's metadata.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs, delay=delay, start_time=time.monotonic())\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(delay)","title":"<code>delay</code>","text":"(<code>float</code>)           \u2013            <p>The minimum delay to add between submission and execution.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon","title":"call_soon","text":"<pre><code>call_soon(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; Pending[T]\n</code></pre> <p>Schedule func to be called in caller's event loop copying the current context.</p> <p>Parameters:</p> Referenced by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <code></code>\u00a0schedule_call </li> <li> typing <code></code>\u00a0RunMode <code></code>\u00a0task </li> </ul> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_soon(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Pending[T]:\n    \"\"\"\n    Schedule func to be called in caller's event loop copying the current context.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n    \"\"\"\n    return self.schedule_call(func, args, kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct","title":"call_direct","text":"<pre><code>call_direct(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; None\n</code></pre> <p>Schedule <code>func</code> to be called in caller's event loop directly.</p> <p>This method is provided to facilitate lightweight thread-safe function calls that need to be performed from within the callers event loop/taskgroup.</p> <p>Parameters:</p> <p>Warning:</p> <pre><code>**Use this method for lightweight calls only!**\n</code></pre> Referenced by: <ul> <li> Reference typing <code></code>\u00a0RunMode <code></code>\u00a0direct </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_direct(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"\n    Schedule `func` to be called in caller's event loop directly.\n\n    This method is provided to facilitate lightweight *thread-safe* function calls that\n    need to be performed from within the callers event loop/taskgroup.\n\n    Args:\n        func: The function.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Warning:\n\n        **Use this method for lightweight calls only!**\n\n    \"\"\"\n    self._queue.append(functools.partial(func, *args, **kwargs))\n    self._resume()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_direct(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_get","title":"queue_get","text":"<pre><code>queue_get(func: Callable) -&gt; Pending[Never] | None\n</code></pre> <p>Returns <code>Pending</code> instance for <code>func</code> where the queue is running.</p> Warning <ul> <li>This instance loops until the instance is closed or func is garbage collected.</li> <li><code>queue_close</code> is the preferred means to shutdown the queue.</li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_get(self, func: Callable) -&gt; Pending[Never] | None:\n    \"\"\"Returns `Pending` instance for `func` where the queue is running.\n\n    Warning:\n        - This instance loops until the instance is closed or func is garbage collected.\n        - `queue_close` is the preferred means to shutdown the queue.\n    \"\"\"\n    return self._queue_map.get(hash(func))\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call","title":"queue_call","text":"<pre><code>queue_call(\n    func: Callable[P, T | CoroutineType[Any, Any, T]], /, *args: args, **kwargs: kwargs\n) -&gt; None\n</code></pre> <p>Queue the execution of <code>func</code> in a queue unique to it and the caller instance (thread-safe).</p> <p>Parameters:</p> Notes <ul> <li>The queue executor loop will stay open until one of the following occurs:<ol> <li>The method Caller.queue_close is called with <code>func</code>.</li> <li>If <code>func</code> is a method is deleted and garbage collected (using weakref.finalize).</li> </ol> </li> <li>The context of the initial call is is used for subsequent queue calls.</li> </ul> Referenced by: <ul> <li> Usage Usage Caller </li> <li> Reference typing <code></code>\u00a0RunMode <code></code>\u00a0queue </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_call(\n    self,\n    func: Callable[P, T | CoroutineType[Any, Any, T]],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"\n    Queue the execution of `func` in a queue unique to it and the caller instance (thread-safe).\n\n    Args:\n        func: The function.\n        *args: Arguments to use with `func`.\n        **kwargs: Keyword arguments to use with `func`.\n\n    Notes:\n        - The queue executor loop will stay open until one of the following occurs:\n            1. The method [Caller.queue_close][] is called with `func`.\n            2. If `func` is a method is deleted and garbage collected (using [weakref.finalize][]).\n        - The [context][contextvars.Context] of the initial call is is used for subsequent queue calls.\n    \"\"\"\n    key = hash(func)\n    if not (pen_ := self._queue_map.get(key)):\n        queue = deque()\n        with contextlib.suppress(TypeError):\n            weakref.finalize(func.__self__ if inspect.ismethod(func) else func, lambda: self.queue_close(key))\n\n        async def queue_loop(key: int, queue: deque) -&gt; None:\n            pen = self.current_pending()\n            assert pen\n            try:\n                while True:\n                    if queue:\n                        item, result = queue.popleft(), None\n                        try:\n                            result = item[0](*item[1], **item[2])\n                            if inspect.iscoroutine(object=result):\n                                await result\n                        except (anyio.get_cancelled_exc_class(), Exception) as e:\n                            if pen.cancelled():\n                                raise\n                            self.log.exception(\"Execution %s failed\", item, exc_info=e)\n                        finally:\n                            del item, result\n                        await anyio.sleep(0)\n                    else:\n                        event = create_async_event()\n                        pen.metadata[\"resume\"] = event.set\n                        if not queue:\n                            await event\n                        pen.metadata.pop(\"resume\")\n            finally:\n                self._queue_map.pop(key)\n\n        self._queue_map[key] = pen_ = self.call_soon(queue_loop, key=key, queue=queue)\n    pen_.metadata[\"kwargs\"][\"queue\"].append((func, args, kwargs))\n    if resume := pen_.metadata.get(\"resume\"):\n        resume()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | CoroutineType[Any, Any, T]]</code>)           \u2013            <p>The function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with <code>func</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close","title":"queue_close","text":"<pre><code>queue_close(func: Callable | int) -&gt; None\n</code></pre> <p>Close the execution queue associated with <code>func</code> (thread-safe).</p> <p>Parameters:</p> Referenced by: <ul> <li> Usage Usage Caller </li> <li> Reference caller <code></code>\u00a0Caller <code></code>\u00a0queue_call </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_close(self, func: Callable | int) -&gt; None:\n    \"\"\"\n    Close the execution queue associated with `func` (thread-safe).\n\n    Args:\n        func: The queue of the function to close.\n    \"\"\"\n    key = func if isinstance(func, int) else hash(func)\n    if pen := self._queue_map.pop(key, None):\n        pen.cancel()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close(func)","title":"<code>func</code>","text":"(<code>Callable | int</code>)           \u2013            <p>The queue of the function to close.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed","title":"as_completed  <code>async</code>","text":"<pre><code>as_completed(\n    items: Iterable[Pending[T]] | AsyncGenerator[Pending[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,\n    shield: bool = False,\n) -&gt; AsyncGenerator[Pending[T], Any]\n</code></pre> <p>A classmethod iterator to get result as they complete.</p> <p>Parameters:</p> Tip <ol> <li>Pass a generator if you wish to limit the number result jobs when calling to_thread/to_task etc.</li> <li>Pass a container with all results when the limiter is not relevant.</li> </ol> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def as_completed(\n    self,\n    items: Iterable[Pending[T]] | AsyncGenerator[Pending[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    shield: bool = False,\n) -&gt; AsyncGenerator[Pending[T], Any]:\n    \"\"\"\n    A [classmethod][] iterator to get result as they complete.\n\n    Args:\n        items: Either a container with existing results or generator of Pendings.\n        max_concurrent: The maximum number of concurrent results to monitor at a time.\n            This is useful when `items` is a generator utilising [Caller.to_thread][].\n            By default this will limit to `Caller.MAX_IDLE_POOL_INSTANCES`.\n        shield: Shield existing items from cancellation.\n\n    Tip:\n        1. Pass a generator if you wish to limit the number result jobs when calling to_thread/to_task etc.\n        2. Pass a container with all results when the limiter is not relevant.\n    \"\"\"\n    resume = noop\n    result_ready = noop\n    done_results: deque[Pending[T]] = deque()\n    results: set[Pending[T]] = set()\n    done = False\n    current_pending = self.current_pending()\n    if isinstance(items, set | list | tuple):\n        max_concurrent_ = 0\n    else:\n        max_concurrent_ = self.MAX_IDLE_POOL_INSTANCES if max_concurrent is NoValue else int(max_concurrent)\n\n    def result_done(pen: Pending[T]) -&gt; None:\n        done_results.append(pen)\n        result_ready()\n\n    async def iter_items():\n        nonlocal done, resume\n        gen = items if isinstance(items, AsyncGenerator) else iter(items)\n        try:\n            while True:\n                pen = await anext(gen) if isinstance(gen, AsyncGenerator) else next(gen)\n                assert pen is not current_pending, \"Would result in deadlock\"\n                pen.add_done_callback(result_done)\n                if not pen.done():\n                    results.add(pen)\n                    if max_concurrent_ and (len(results) == max_concurrent_):\n                        event = create_async_event()\n                        resume = event.set\n                        if len(results) == max_concurrent_:\n                            await event\n                        resume = noop\n\n        except (StopAsyncIteration, StopIteration):\n            return\n        finally:\n            done = True\n            resume()\n            result_ready()\n\n    pen_ = self.call_soon(iter_items)\n    try:\n        while not done or results:\n            if done_results:\n                pen = done_results.popleft()\n                results.discard(pen)\n                # Ensure all done callbacks are complete.\n                await pen.wait(result=False)\n                yield pen\n            else:\n                if max_concurrent_ and len(results) &lt; max_concurrent_:\n                    resume()\n                event = create_async_event()\n                result_ready = event.set\n                if not done or results:\n                    await event\n                result_ready = noop\n    finally:\n        pen_.cancel()\n        for pen in results:\n            pen.remove_done_callback(result_done)\n            if not shield:\n                pen.cancel(\"Cancelled by as_completed\")\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(items)","title":"<code>items</code>","text":"(<code>Iterable[Pending[T]] | AsyncGenerator[Pending[T]]</code>)           \u2013            <p>Either a container with existing results or generator of Pendings.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(max_concurrent)","title":"<code>max_concurrent</code>","text":"(<code>NoValue | int</code>, default:                   <code>NoValue</code> )           \u2013            <p>The maximum number of concurrent results to monitor at a time. This is useful when <code>items</code> is a generator utilising Caller.to_thread. By default this will limit to <code>Caller.MAX_IDLE_POOL_INSTANCES</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield existing items from cancellation.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    items: Iterable[Pending[T]],\n    *,\n    timeout: float | None = None,\n    return_when: Literal[\n        \"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"\n    ] = \"ALL_COMPLETED\",\n) -&gt; tuple[set[T], set[Pending[T]]]\n</code></pre> <p>A classmethod to wait for the results given by items to complete.</p> <p>Returns two sets of the results: (done, pending).</p> <p>Parameters:</p> Example <pre><code>done, pending = await asyncio.wait(items)\n</code></pre> <p>Info:     - This does not raise a TimeoutError!     - Pendings that aren't done when the timeout occurs are returned in the second set.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def wait(\n    self,\n    items: Iterable[Pending[T]],\n    *,\n    timeout: float | None = None,\n    return_when: Literal[\"FIRST_COMPLETED\", \"FIRST_EXCEPTION\", \"ALL_COMPLETED\"] = \"ALL_COMPLETED\",\n) -&gt; tuple[set[T], set[Pending[T]]]:\n    \"\"\"\n    A [classmethod][] to wait for the results given by items to complete.\n\n    Returns two sets of the results: (done, pending).\n\n    Args:\n        items: An iterable of results to wait for.\n        timeout: The maximum time before returning.\n        return_when: The same options as available for [asyncio.wait][].\n\n    Example:\n        ```python\n        done, pending = await asyncio.wait(items)\n        ```\n    Info:\n        - This does not raise a TimeoutError!\n        - Pendings that aren't done when the timeout occurs are returned in the second set.\n    \"\"\"\n    done = set()\n    if pending := set(items):\n        with anyio.move_on_after(timeout):\n            async for pen in self.as_completed(pending.copy(), shield=True):\n                _ = (pending.discard(pen), done.add(pen))\n                if return_when == \"FIRST_COMPLETED\":\n                    break\n                if return_when == \"FIRST_EXCEPTION\" and (pen.cancelled() or pen.exception()):\n                    break\n    return done, pending\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(items)","title":"<code>items</code>","text":"(<code>Iterable[Pending[T]]</code>)           \u2013            <p>An iterable of results to wait for.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum time before returning.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.wait(return_when)","title":"<code>return_when</code>","text":"(<code>Literal['FIRST_COMPLETED', 'FIRST_EXCEPTION', 'ALL_COMPLETED']</code>, default:                   <code>'ALL_COMPLETED'</code> )           \u2013            <p>The same options as available for asyncio.wait.</p>"},{"location":"reference/comm/","title":"comm","text":"<p>Classes:</p> <ul> <li> <code>Comm</code>           \u2013            <p>An implementation of <code>comm.BaseComms</code> for async-kernel  (on pypi).</p> </li> </ul>"},{"location":"reference/comm/#async_kernel.comm.Comm","title":"async_kernel.comm.Comm","text":"<p>               Bases: <code>BaseComm</code></p> <p>An implementation of <code>comm.BaseComms</code> for async-kernel  (on pypi).</p> Notes <ul> <li><code>kernel</code> is added/removed by the CommManager.</li> <li><code>kernel</code> is added to the CommManager by the kernel once the sockets have been opened.</li> <li>publish_msg is no-op when kernel is unset.</li> </ul> Referenced by: <ul> <li> Reference kernel <code></code>\u00a0Kernel </li> </ul> <p>Methods:</p> <ul> <li> <code>publish_msg</code>             \u2013              <p>Helper for sending a comm message on IOPub.</p> </li> <li> <code>handle_msg</code>             \u2013              <p>Handle a comm_msg message</p> </li> </ul>"},{"location":"reference/comm/#async_kernel.comm.Comm.publish_msg","title":"publish_msg","text":"<pre><code>publish_msg(\n    msg_type: str,\n    data: MaybeDict = None,\n    metadata: MaybeDict = None,\n    buffers: BuffersType = None,\n    **keys,\n)\n</code></pre> <p>Helper for sending a comm message on IOPub.</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef publish_msg(\n    self,\n    msg_type: str,\n    data: MaybeDict = None,\n    metadata: MaybeDict = None,\n    buffers: BuffersType = None,\n    **keys,\n):\n    \"\"\"Helper for sending a comm message on IOPub.\"\"\"\n    if (kernel := self.kernel) is None:\n        # Only send when the kernel is set\n        return\n    content = {\"data\": {} if data is None else data, \"comm_id\": self.comm_id} | keys\n    kernel.iopub_send(\n        msg_or_type=msg_type,\n        content=content,\n        metadata=metadata,\n        parent=None,\n        ident=self.topic,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"reference/comm/#async_kernel.comm.Comm.handle_msg","title":"handle_msg","text":"<pre><code>handle_msg(msg: MessageType) -&gt; None\n</code></pre> <p>Handle a comm_msg message</p> Source code in <code>src/async_kernel/comm.py</code> <pre><code>@override\ndef handle_msg(self, msg: comm.base_comm.MessageType) -&gt; None:\n    \"\"\"Handle a comm_msg message\"\"\"\n    if self._msg_callback:\n        self._msg_callback(msg)\n</code></pre>"},{"location":"reference/command/","title":"command","text":"<p>Functions:</p> <ul> <li> <code>command_line</code>             \u2013              <p>Parses command-line arguments to manage kernel specs and start kernels.</p> </li> </ul>"},{"location":"reference/command/#async_kernel.command.command_line","title":"async_kernel.command.command_line","text":"<pre><code>command_line(wait_exit_context: Callable[[], Awaitable] = sleep_forever) -&gt; None\n</code></pre> <p>Parses command-line arguments to manage kernel specs and start kernels.</p> <p>This function uses <code>argparse</code> to handle command-line arguments for various kernel operations, including:</p> <ul> <li>Starting a kernel with a specified connection file.</li> <li>Adding a new kernel specification.</li> <li>Removing an existing kernel specification.</li> <li>Print version.</li> </ul> <p>The function determines the appropriate action based on the provided arguments and either starts a kernel, adds a kernel spec, or removes a kernel spec.  If no connection file is provided and no other action is specified, it prints the help message.</p> <p>When starting a kernel, it imports the specified kernel factory (or uses the default <code>Kernel</code> class) and configures the kernel instance with the provided arguments. It then starts the kernel within an <code>anyio</code> context, handling keyboard interrupts and other exceptions.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>If an error occurs during kernel execution or if the program is interrupted.</p> </li> </ul> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> kernel <code></code>\u00a0Kernel </li> <li> kernelspec <code></code>\u00a0make_argv </li> <li> utils <code></code>\u00a0setattr_nested </li> </ul> </li> <li> Usage Command line Start a kernel </li> </ul> Source code in <code>src/async_kernel/command.py</code> <pre><code>def command_line(wait_exit_context: Callable[[], Awaitable] = anyio.sleep_forever) -&gt; None:\n    \"\"\"\n    Parses command-line arguments to manage kernel specs and start kernels.\n\n    This function uses `argparse` to handle command-line arguments for\n    various kernel operations, including:\n\n    - Starting a kernel with a specified connection file.\n    - Adding a new kernel specification.\n    - Removing an existing kernel specification.\n    - Print version.\n\n    The function determines the appropriate action based on the provided\n    arguments and either starts a kernel, adds a kernel spec, or removes\n    a kernel spec.  If no connection file is provided and no other action\n    is specified, it prints the help message.\n\n    When starting a kernel, it imports the specified kernel factory (or uses\n    the default `Kernel` class) and configures the kernel instance with\n    the provided arguments. It then starts the kernel within an `anyio`\n    context, handling keyboard interrupts and other exceptions.\n\n    Args:\n        wait_exit_context: An optional asynchronous function or context manager\n            that determines how long the kernel should run. Defaults to\n            `anyio.sleep_forever`, which keeps the kernel running indefinitely\n            until an external signal is received.\n\n    Raises:\n        SystemExit: If an error occurs during kernel execution or if the\n            program is interrupted.\n    \"\"\"\n    kernel_dir: Path = get_kernel_dir()\n    title = \"Async kernel\"\n    parser = argparse.ArgumentParser(\n        description=\"=\" * len(title)\n        + f\"\\n{title}\\n\"\n        + \"=\" * len(title)\n        + \"\\n\\n\"\n        + \"With the async-kernel command line tool you can:\\n\\n\"\n        + \"    - Add/remove kernel specs\\n\"\n        + \"    - start kernels\\n\\n\"\n        + \"Online help: https://fleming79.github.io/async-kernel/latest/commands/#command-line \\n\\n\"\n        + f\"Jupyter kernel directory: '{kernel_dir}'\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--connection_file\",\n        dest=\"connection_file\",\n        help=\"Start a kernel with a connection file. To start a kernel without a file use a period `.`.\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--add\",\n        dest=\"add\",\n        help=f\"Add a kernel spec. Default kernel names are: {list(map(str, KernelName))}.\\n\"\n        + \"To specify a 'trio' backend, include 'trio' in the name. Other options are also permitted. See: `write_kernel_spec` for detail.\",\n    )\n    kernels = [] if not kernel_dir.exists() else [item.name for item in kernel_dir.iterdir() if item.is_dir()]\n    parser.add_argument(\n        \"-r\",\n        \"--remove\",\n        dest=\"remove\",\n        help=f\"Remove existing kernel specs. Installed kernels: {kernels}.\",\n    )\n    parser.add_argument(\n        \"-V\",\n        \"--version\",\n        dest=\"version\",\n        help=\"Print version\",\n        action=\"store_true\",\n    )\n    args, unknownargs = parser.parse_known_args()\n    cl_names = set(vars(args))\n\n    # Convert unknownargs from flags to mappings\n    for v in (v.lstrip(\"-\") for v in unknownargs):\n        if \"=\" in v:\n            k, v_ = v.split(\"=\", maxsplit=1)\n            setattr(args, k, v_.strip(\"'\\\"\").strip())\n        else:\n            # https://docs.python.org/3/library/argparse.html#argparse.BooleanOptionalAction\n            setattr(args, v.removeprefix(\"no-\"), False) if v.startswith(\"no-\") else setattr(args, v, True)\n\n    # Add kernel spec\n    if args.add:\n        if not hasattr(args, \"kernel_name\"):\n            args.kernel_name = args.add\n        for name in cl_names:\n            delattr(args, name)\n        path = write_kernel_spec(**vars(args))\n        print(f\"Added kernel spec {path!s}\")\n\n    # Remove kernel spec\n    elif args.remove:\n        for name in args.remove.split(\",\"):\n            msg = \"removed\" if remove_kernel_spec(name) else \"not found!\"\n            print(f\"Kernel spec: '{name}' {msg}\")\n\n    # Version\n    elif args.version:\n        print(\"async-kernel\", async_kernel.__version__)\n\n    # Start kernel\n    elif args.connection_file:\n        settings = vars(args)\n        for k in cl_names.difference([\"connection_file\"]):\n            settings.pop(k, None)\n        if settings.get(\"connection_file\") in {None, \"\", \".\"}:\n            settings.pop(\"connection_file\", None)\n        factory: KernelFactoryType = import_kernel_factory(getattr(args, \"kernel_factory\", \"\"))\n        kernel: Kernel = factory(settings)\n        try:\n            kernel.run(wait_exit_context)\n        except KeyboardInterrupt:\n            pass\n        except BaseException as e:\n            if \"Stopping kernel\" not in str(e):\n                traceback.print_exception(e, file=sys.stderr)\n                if sys.__stderr__ is not sys.stderr:\n                    traceback.print_exception(e, file=sys.__stderr__)\n                sys.exit(1)\n        sys.exit(0)\n\n    # Print help\n    else:\n        parser.print_help()\n</code></pre>"},{"location":"reference/command/#async_kernel.command.command_line(wait_exit_context)","title":"<code>wait_exit_context</code>","text":"(<code>Callable[[], Awaitable]</code>, default:                   <code>sleep_forever</code> )           \u2013            <p>An optional asynchronous function or context manager that determines how long the kernel should run. Defaults to <code>anyio.sleep_forever</code>, which keeps the kernel running indefinitely until an external signal is received.</p>"},{"location":"reference/common/","title":"common","text":"<p>Classes:</p> <ul> <li> <code>Fixed</code>           \u2013            <p>A thread-safe descriptor factory for creating and caching an object.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>import_item</code>             \u2013              <p>Import an item from a module, given its dotted name.</p> </li> </ul>"},{"location":"reference/common/#async_kernel.common.Fixed","title":"async_kernel.common.Fixed","text":"<pre><code>Fixed(\n    obj: type[T] | Callable[[FixedCreate[S]], T] | str,\n    /,\n    *,\n    created: Callable[[FixedCreated[S, T]]] | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[S, T]</code></p> <p>A thread-safe descriptor factory for creating and caching an object.</p> <p>The <code>Fixed</code> descriptor provisions for each instance of the owner class to dynamically load or import the managed class.  The managed instance is created on first access and then cached for subsequent access.</p> Type Hints <ul> <li><code>S</code>: Type of the owner class.</li> <li><code>T</code>: Type of the managed class.</li> </ul> Example <pre><code>class MyClass:\n    a: Fixed[Self, dict] = Fixed(dict)\n    b: Fixed[Self, int] = Fixed(lambda c: id(c[\"owner\"].a))\n    c: Fixed[Any, list[str]] = Fixed(list, created=lambda c: c[\"obj\"].append(c[\"name\"]))\n</code></pre> Used by: <ul> <li> Reference caller <code></code>\u00a0Caller <code></code>\u00a0stopped </li> </ul> Source code in <code>src/async_kernel/common.py</code> <pre><code>def __init__(\n    self,\n    obj: type[T] | Callable[[FixedCreate[S]], T] | str,\n    /,\n    *,\n    created: Callable[[FixedCreated[S, T]]] | None = None,\n) -&gt; None:\n    if isinstance(obj, str):\n        self.create = lambda _: import_item(obj)()\n    elif inspect.isclass(obj):\n        self.create = lambda _: obj()\n    elif callable(obj):\n        self.create = obj\n    else:\n        msg = f\"{obj=} is invalid! Use a lambda instead eg: lambda _: {obj}\"  # pyright: ignore[reportUnreachable]\n        raise TypeError(msg)\n    self.created = created\n    self.instances = weakref.WeakKeyDictionary()\n    self.lock = Lock()\n</code></pre>"},{"location":"reference/common/#async_kernel.common.import_item","title":"async_kernel.common.import_item","text":"<pre><code>import_item(dottedname: str) -&gt; Any\n</code></pre> <p>Import an item from a module, given its dotted name.</p> Example <pre><code>import_item(\"os.path.join\")\n</code></pre> Source code in <code>src/async_kernel/common.py</code> <pre><code>def import_item(dottedname: str) -&gt; Any:\n    \"\"\"Import an item from a module, given its dotted name.\n\n    Example:\n        ```python\n        import_item(\"os.path.join\")\n        ```\n    \"\"\"\n    modulename, objname = dottedname.rsplit(\".\", maxsplit=1)\n    return getattr(importlib.import_module(modulename), objname)\n</code></pre>"},{"location":"reference/debugger/","title":"debugger","text":"<p>Classes:</p> <ul> <li> <code>VariableExplorer</code>           \u2013            <p>A variable explorer.</p> </li> <li> <code>DebugpyClient</code>           \u2013            <p>A client for debugpy. Origin: IPyKernel.</p> </li> <li> <code>Debugger</code>           \u2013            <p>The debugger class. Origin: IPyKernel.</p> </li> </ul>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer","title":"async_kernel.debugger.VariableExplorer","text":"<pre><code>VariableExplorer()\n</code></pre> <p>               Bases: <code>HasTraits</code></p> <p>A variable explorer.</p> <p>Origin: IPyKernel</p> <p>Methods:</p> <ul> <li> <code>track</code>             \u2013              <p>Start tracking.</p> </li> <li> <code>untrack_all</code>             \u2013              <p>Stop tracking.</p> </li> <li> <code>get_children_variables</code>             \u2013              <p>Get the child variables for a variable reference.</p> </li> </ul> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the explorer.\"\"\"\n    super().__init__()\n    # This import is apparently required to provide _pydevd_bundle imports\n    import debugpy.server.api  # noqa: F401, I001, PLC0415  # pyright: ignore[reportUnusedImport]\n    from _pydevd_bundle.pydevd_suspended_frames import SuspendedFramesManager, _FramesTracker  # type: ignore[attr-defined]  # noqa: PLC0415\n\n    self.suspended_frame_manager = SuspendedFramesManager()\n    self.py_db = _DummyPyDB()\n    self.tracker = _FramesTracker(self.suspended_frame_manager, self.py_db)\n    self.frame = None\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.track","title":"track","text":"<pre><code>track()\n</code></pre> <p>Start tracking.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def track(self):\n    \"\"\"Start tracking.\"\"\"\n    from _pydevd_bundle import pydevd_frame_utils  # type: ignore[attr-defined]  # noqa: PLC0415\n\n    shell = self.kernel.shell\n    var = shell.user_ns\n    self.frame = _FakeFrame(_FakeCode(\"&lt;module&gt;\", shell.compile.get_file_name(\"sys._getframe()\")), var, var)\n    self.tracker.track(\"thread1\", pydevd_frame_utils.create_frames_list_from_frame(self.frame))\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.untrack_all","title":"untrack_all","text":"<pre><code>untrack_all()\n</code></pre> <p>Stop tracking.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def untrack_all(self):\n    \"\"\"Stop tracking.\"\"\"\n    self.tracker.untrack_all()\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.VariableExplorer.get_children_variables","title":"get_children_variables","text":"<pre><code>get_children_variables(variable_ref=None)\n</code></pre> <p>Get the child variables for a variable reference.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def get_children_variables(self, variable_ref=None):\n    \"\"\"Get the child variables for a variable reference.\"\"\"\n    var_ref = variable_ref\n    if not var_ref:\n        var_ref = id(self.frame)\n    try:\n        variables = self.suspended_frame_manager.get_variable(var_ref)\n    except KeyError:\n        return []\n    return [x.get_var_data() for x in variables.get_children_variables()]\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient","title":"async_kernel.debugger.DebugpyClient","text":"<pre><code>DebugpyClient(log, event_callback)\n</code></pre> <p>               Bases: <code>HasTraits</code></p> <p>A client for debugpy. Origin: IPyKernel.</p> <p>Methods:</p> <ul> <li> <code>put_tcp_frame</code>             \u2013              <p>Buffer the frame and process the buffer.</p> </li> <li> <code>connect_tcp_socket</code>             \u2013              <p>Connect to the tcp socket.</p> </li> </ul> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def __init__(self, log, event_callback):\n    \"\"\"Initialize the client.\"\"\"\n    super().__init__()\n    self.log = log\n    self.event_callback = event_callback\n    self._pack = self.kernel.session.pack\n    self._unpack = self.kernel.session.unpack\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient.put_tcp_frame","title":"put_tcp_frame","text":"<pre><code>put_tcp_frame(frame: bytes)\n</code></pre> <p>Buffer the frame and process the buffer.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def put_tcp_frame(self, frame: bytes):\n    \"\"\"Buffer the frame and process the buffer.\"\"\"\n    self.tcp_buffer += frame\n    data = self.tcp_buffer.split(self.HEADER)\n    if len(data) &gt; 1:\n        for buf in data[1:]:\n            size, raw_msg = buf.split(self.SEPARATOR, maxsplit=1)\n            size = int(size)\n            msg: DebugMessage = self._unpack(raw_msg[:size])\n            self.log.debug(\"_put_message :%s %s\", msg[\"type\"], msg)\n            if msg[\"type\"] == \"event\":\n                self.event_callback(msg)\n            elif result := self._result_responses.pop(msg[\"request_seq\"], None):\n                result.set_result(msg)\n        self.tcp_buffer = b\"\"\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.DebugpyClient.connect_tcp_socket","title":"connect_tcp_socket  <code>async</code>","text":"<pre><code>connect_tcp_socket(ready: Event)\n</code></pre> <p>Connect to the tcp socket.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def connect_tcp_socket(self, ready: Event):\n    \"\"\"Connect to the tcp socket.\"\"\"\n    global _host_port  # noqa: PLW0603\n    if not _host_port:\n        import debugpy  # noqa: PLC0415\n\n        _host_port = debugpy.listen(0)\n    try:\n        self.log.debug(\"++ debugpy socketstream connecting ++\")\n        async with await anyio.connect_tcp(*_host_port) as socketstream:\n            self._socketstream = socketstream\n            self.log.debug(\"++ debugpy socketstream connected ++\")\n            ready.set()\n            while True:\n                data = await socketstream.receive()\n                self.put_tcp_frame(data)\n    except anyio.EndOfStream:\n        self.log.debug(\"++ debugpy socketstream disconnected ++\")\n        return\n    finally:\n        self._socketstream = None\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger","title":"async_kernel.debugger.Debugger","text":"<pre><code>Debugger()\n</code></pre> <p>               Bases: <code>HasTraits</code></p> <p>The debugger class. Origin: IPyKernel.</p> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0debugger </li> </ul> <p>Methods:</p> <ul> <li> <code>send_dap_request</code>             \u2013              <p>Sends a DAP request to the debug server, waits for and returns the corresponding response.</p> </li> <li> <code>next_seq</code>             \u2013              <p>A monotonically decreasing negative number so as not to clash with the frontend seq.</p> </li> <li> <code>process_request</code>             \u2013              <p>Process a request.</p> </li> <li> <code>do_initialize</code>             \u2013              <p>Initialize debugpy server starting as required.</p> </li> <li> <code>do_debug_info</code>             \u2013              <p>Handle a debug info message.</p> </li> <li> <code>do_inspect_variables</code>             \u2013              <p>Handle an inspect variables message.</p> </li> <li> <code>do_rich_inspect_variables</code>             \u2013              <p>Handle a rich inspect variables message.</p> </li> <li> <code>do_modules</code>             \u2013              <p>Handle a modules message.</p> </li> <li> <code>do_dump_cell</code>             \u2013              <p>Handle a dump cell message.</p> </li> <li> <code>do_set_breakpoints</code>             \u2013              <p>Handle a set breakpoints message.</p> </li> <li> <code>do_source</code>             \u2013              <p>Handle a source message.</p> </li> <li> <code>do_stack_trace</code>             \u2013              <p>Handle a stack trace message.</p> </li> <li> <code>do_variables</code>             \u2013              <p>Handle a variables message.</p> </li> <li> <code>do_attach</code>             \u2013              <p>Handle an attach message.</p> </li> <li> <code>do_configuration_done</code>             \u2013              <p>Handle a configuration done message.</p> </li> </ul> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the debugger.\"\"\"\n    super().__init__()\n    self.debugpy_client = DebugpyClient(log=self.log, event_callback=self._handle_event)\n    self.started_debug_handlers = {\n        \"setBreakpoints\": self.do_set_breakpoints,\n        \"stackTrace\": self.do_stack_trace,\n        \"variables\": self.do_variables,\n        \"attach\": self.do_attach,\n        \"configurationDone\": self.do_configuration_done,\n        \"copyToGlobals\": self.do_copy_to_globals,\n        \"disconnect\": self.do_disconnect,\n    }\n    self.static_debug_handlers = {\n        \"initialize\": self.do_initialize,\n        \"dumpCell\": self.do_dump_cell,\n        \"source\": self.do_source,\n        \"debugInfo\": self.do_debug_info,\n        \"inspectVariables\": self.do_inspect_variables,\n        \"richInspectVariables\": self.do_rich_inspect_variables,\n        \"modules\": self.do_modules,\n    }\n    self._forbidden_names = tuple(self.kernel.shell.user_ns_hidden)\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.send_dap_request","title":"send_dap_request  <code>async</code>","text":"<pre><code>send_dap_request(msg: DebugMessage)\n</code></pre> <p>Sends a DAP request to the debug server, waits for and returns the corresponding response.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def send_dap_request(self, msg: DebugMessage, /):\n    \"\"\"Sends a DAP request to the debug server, waits for and returns the corresponding response.\"\"\"\n    return await (await self.debugpy_client.send_request(msg))\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.next_seq","title":"next_seq","text":"<pre><code>next_seq()\n</code></pre> <p>A monotonically decreasing negative number so as not to clash with the frontend seq.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>def next_seq(self):\n    \"A monotonically decreasing negative number so as not to clash with the frontend seq.\"\n    self._seq = self._seq - 1\n    return self._seq\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.process_request","title":"process_request  <code>async</code>","text":"<pre><code>process_request(msg: DebugMessage)\n</code></pre> <p>Process a request.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def process_request(self, msg: DebugMessage, /):\n    \"\"\"Process a request.\"\"\"\n    command = msg[\"command\"]\n    if handler := self.static_debug_handlers.get(command):\n        return await handler(msg)\n    if not self.debugpy_client.connected:\n        msg_ = \"Debugy client not connected.\"\n        raise RuntimeError(msg_)\n    if handler := self.started_debug_handlers.get(command):\n        return await handler(msg)\n\n    return await self.send_dap_request(msg)\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_initialize","title":"do_initialize  <code>async</code>","text":"<pre><code>do_initialize(msg: DebugMessage)\n</code></pre> <p>Initialize debugpy server starting as required.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_initialize(self, msg: DebugMessage, /):\n    \"Initialize debugpy server starting as required.\"\n    utils.mark_thread_pydev_do_not_trace()\n    for thread in threading.enumerate():\n        if thread.name in self.NO_DEBUG:\n            utils.mark_thread_pydev_do_not_trace(thread)\n    if not self.debugpy_client.connected:\n        ready = Event()\n        Caller.get().call_soon(self.debugpy_client.connect_tcp_socket, ready)\n        await ready\n        # Don't remove leading empty lines when debugging so the breakpoints are correctly positioned\n        cleanup_transforms = self.kernel.shell.input_transformer_manager.cleanup_transforms\n        if leading_empty_lines in cleanup_transforms:\n            index = cleanup_transforms.index(leading_empty_lines)\n            self._removed_cleanup[index] = cleanup_transforms.pop(index)\n    reply = await self.send_dap_request(msg)\n    if capabilities := reply.get(\"body\"):\n        self.capabilities = capabilities\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_debug_info","title":"do_debug_info  <code>async</code>","text":"<pre><code>do_debug_info(msg: DebugMessage)\n</code></pre> <p>Handle a debug info message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_debug_info(self, msg: DebugMessage, /):\n    \"\"\"Handle a debug info message.\"\"\"\n    breakpoint_list = []\n    for key, value in self.breakpoint_list.items():\n        breakpoint_list.append({\"source\": key, \"breakpoints\": value})\n    compiler = self.kernel.shell.compile\n    return {\n        \"type\": \"response\",\n        \"request_seq\": msg[\"seq\"],\n        \"success\": True,\n        \"command\": msg[\"command\"],\n        \"body\": {\n            \"isStarted\": self.debugpy_client.connected and not utils.LAUNCHED_BY_DEBUGPY,\n            \"hashMethod\": compiler.hash_method,\n            \"hashSeed\": compiler.hash_seed,\n            \"tmpFilePrefix\": compiler.tmp_file_prefix,\n            \"tmpFileSuffix\": compiler.tmp_file_suffix,\n            \"breakpoints\": breakpoint_list,\n            \"stoppedThreads\": sorted(self.stopped_threads),\n            \"richRendering\": True,\n            \"exceptionPaths\": [\"Python Exceptions\"],\n            \"copyToGlobals\": True,\n        },\n    }\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_inspect_variables","title":"do_inspect_variables  <code>async</code>","text":"<pre><code>do_inspect_variables(msg: DebugMessage)\n</code></pre> <p>Handle an inspect variables message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_inspect_variables(self, msg: DebugMessage, /):\n    \"\"\"Handle an inspect variables message.\"\"\"\n    self.variable_explorer.untrack_all()\n    # looks like the implementation of untrack_all in ptvsd\n    # destroys objects we need in track. We have no choice but\n    # reinstantiate the object\n    self.variable_explorer = VariableExplorer()\n    self.variable_explorer.track()\n    variables = self.variable_explorer.get_children_variables()\n    return self._build_variables_response(msg, variables)\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_rich_inspect_variables","title":"do_rich_inspect_variables  <code>async</code>","text":"<pre><code>do_rich_inspect_variables(msg: DebugMessage)\n</code></pre> <p>Handle a rich inspect variables message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_rich_inspect_variables(self, msg: DebugMessage, /):\n    \"\"\"Handle a rich inspect variables message.\"\"\"\n    reply = {\n        \"type\": \"response\",\n        \"sequence_seq\": msg[\"seq\"],\n        \"success\": False,\n        \"command\": msg[\"command\"],\n    }\n    variable_name = msg[\"arguments\"].get(\"variableName\", \"\")\n    if not str.isidentifier(variable_name):\n        reply[\"body\"] = {\"data\": {}, \"metadata\": {}}\n        if variable_name in {\"special variables\", \"function variables\"}:\n            reply[\"success\"] = True\n        return reply\n    repr_data = {}\n    repr_metadata = {}\n    if not self.stopped_threads:\n        # The code did not hit a breakpoint, we use the interpreter\n        # to get the rich representation of the variable\n        result = self.kernel.shell.user_expressions({\"var\": variable_name})[\"var\"]\n        if result.get(\"status\", \"error\") == \"ok\":\n            repr_data = result.get(\"data\", {})\n            repr_metadata = result.get(\"metadata\", {})\n    else:\n        # The code has stopped on a breakpoint, we use the evaluate\n        # request to get the rich representation of the variable\n        code = f\"get_ipython().display_formatter.format({variable_name})\"\n        reply = await self.send_dap_request(\n            {\n                \"type\": \"request\",\n                \"command\": \"evaluate\",\n                \"seq\": self.next_seq(),\n                \"arguments\": {\"expression\": code, \"context\": \"clipboard\"} | msg[\"arguments\"],\n            }\n        )\n        if reply[\"success\"]:\n            repr_data, repr_metadata = eval(reply[\"body\"][\"result\"], {}, {})\n    body = {\n        \"data\": repr_data,\n        \"metadata\": {k: v for k, v in repr_metadata.items() if k in repr_data},\n    }\n    reply[\"body\"] = body\n    reply[\"success\"] = True\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_modules","title":"do_modules  <code>async</code>","text":"<pre><code>do_modules(msg: DebugMessage)\n</code></pre> <p>Handle a modules message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_modules(self, msg: DebugMessage, /):\n    \"\"\"Handle a modules message.\"\"\"\n    modules = list(sys.modules.values())\n    startModule = msg.get(\"startModule\", 0)\n    moduleCount = msg.get(\"moduleCount\", len(modules))\n    mods = []\n    for i in range(startModule, moduleCount):\n        module = modules[i]\n        filename = getattr(getattr(module, \"__spec__\", None), \"origin\", None)\n        if filename and filename.endswith(\".py\"):\n            mods.append({\"id\": i, \"name\": module.__name__, \"path\": filename})\n    return {\"body\": {\"modules\": mods, \"totalModules\": len(modules)}}\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_dump_cell","title":"do_dump_cell  <code>async</code>","text":"<pre><code>do_dump_cell(msg: DebugMessage)\n</code></pre> <p>Handle a dump cell message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_dump_cell(self, msg: DebugMessage, /):\n    \"\"\"Handle a dump cell message.\"\"\"\n    code = msg[\"arguments\"][\"code\"]\n    path = self.kernel.shell.compile.get_file_name(code)\n    path.parent.mkdir(exist_ok=True)\n    with path.open(\"w\") as f:\n        f.write(code)\n    return {\n        \"type\": \"response\",\n        \"request_seq\": msg[\"seq\"],\n        \"success\": True,\n        \"command\": msg[\"command\"],\n        \"body\": {\"sourcePath\": str(path)},\n    }\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_set_breakpoints","title":"do_set_breakpoints  <code>async</code>","text":"<pre><code>do_set_breakpoints(msg: DebugMessage)\n</code></pre> <p>Handle a set breakpoints message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_set_breakpoints(self, msg: DebugMessage, /):\n    \"\"\"Handle a set breakpoints message.\"\"\"\n    source = msg[\"arguments\"][\"source\"][\"path\"]\n    self.breakpoint_list[source] = msg[\"arguments\"][\"breakpoints\"]\n    message_response = await self.send_dap_request(msg)\n    # debugpy can set breakpoints on different lines than the ones requested,\n    # so we want to record the breakpoints that were actually added\n    if message_response.get(\"success\"):\n        self.breakpoint_list[source] = [\n            {\"line\": breakpoint[\"line\"]} for breakpoint in message_response[\"body\"][\"breakpoints\"]\n        ]\n    return message_response\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_source","title":"do_source  <code>async</code>","text":"<pre><code>do_source(msg: DebugMessage)\n</code></pre> <p>Handle a source message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_source(self, msg: DebugMessage, /):\n    \"\"\"Handle a source message.\"\"\"\n    reply = {\"type\": \"response\", \"request_seq\": msg[\"seq\"], \"command\": msg[\"command\"]}\n    if (path := Path(msg[\"arguments\"].get(\"source\", {}).get(\"path\", \"missing\"))).is_file():\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            reply[\"success\"] = True\n            reply[\"body\"] = {\"content\": f.read()}\n    else:\n        reply[\"success\"] = False\n        reply[\"message\"] = \"source unavailable\"\n        reply[\"body\"] = {}\n\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_stack_trace","title":"do_stack_trace  <code>async</code>","text":"<pre><code>do_stack_trace(msg: DebugMessage)\n</code></pre> <p>Handle a stack trace message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_stack_trace(self, msg: DebugMessage, /):\n    \"\"\"Handle a stack trace message.\"\"\"\n    reply = await self.send_dap_request(msg)\n    # The stackFrames array can have the following content:\n    # { frames from the notebook}\n    # ...\n    # { 'id': xxx, 'name': '&lt;module&gt;', ... } &lt;= this is the first frame of the code from the notebook\n    # { frames from async_kernel }\n    # ...\n    # {'id': yyy, 'name': '&lt;module&gt;', ... } &lt;= this is the first frame of async_kernel code\n    # or only the frames from the notebook.\n    # We want to remove all the frames from async_kernel when they are present.\n    try:\n        sf_list = reply[\"body\"][\"stackFrames\"]\n        module_idx = len(sf_list) - next(\n            i for i, v in enumerate(reversed(sf_list), 1) if v[\"name\"] == \"&lt;module&gt;\" and i != 1\n        )\n        reply[\"body\"][\"stackFrames\"] = reply[\"body\"][\"stackFrames\"][: module_idx + 1]\n    except StopIteration:\n        pass\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_variables","title":"do_variables  <code>async</code>","text":"<pre><code>do_variables(msg: DebugMessage)\n</code></pre> <p>Handle a variables message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_variables(self, msg: DebugMessage, /):\n    \"\"\"Handle a variables message.\"\"\"\n    reply = {}\n    if not self.stopped_threads:\n        variables = self.variable_explorer.get_children_variables(msg[\"arguments\"][\"variablesReference\"])\n        return self._build_variables_response(msg, variables)\n    reply = await self.send_dap_request(msg)\n    if \"body\" in reply:\n        variables = [var for var in reply[\"body\"][\"variables\"] if self._accept_variable(var[\"name\"])]\n        reply[\"body\"][\"variables\"] = variables\n    return reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_attach","title":"do_attach  <code>async</code>","text":"<pre><code>do_attach(msg: DebugMessage)\n</code></pre> <p>Handle an attach message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_attach(self, msg: DebugMessage, /):\n    \"\"\"Handle an attach message.\"\"\"\n    assert _host_port\n    msg[\"arguments\"][\"connect\"] = {\"host\": _host_port[0], \"port\": _host_port[1]}\n    if self.just_my_code:\n        msg[\"arguments\"][\"debugOptions\"] = [\"justMyCode\"]\n    reply = await self.debugpy_client.send_request(msg)\n    await self.init_event\n    await self.send_dap_request(\n        {\n            \"type\": \"request\",\n            \"seq\": self.next_seq(),\n            \"command\": \"configurationDone\",\n        }\n    )\n    return await reply\n</code></pre>"},{"location":"reference/debugger/#async_kernel.debugger.Debugger.do_configuration_done","title":"do_configuration_done  <code>async</code>","text":"<pre><code>do_configuration_done(msg: DebugMessage)\n</code></pre> <p>Handle a configuration done message.</p> Source code in <code>src/async_kernel/debugger.py</code> <pre><code>async def do_configuration_done(self, msg: DebugMessage, /):\n    \"\"\"Handle a configuration done message.\"\"\"\n    # This is only supposed to be called during initialize but can come at anytime. Ref: https://microsoft.github.io/debug-adapter-protocol/specification#Events_Initialized\n    # see : https://github.com/jupyterlab/jupyterlab/issues/17673\n    return {\n        \"seq\": msg[\"seq\"],\n        \"type\": \"response\",\n        \"request_seq\": msg[\"seq\"],\n        \"success\": True,\n        \"command\": msg[\"command\"],\n    }\n</code></pre>"},{"location":"reference/kernel/","title":"kernel","text":"<p>Classes:</p> <ul> <li> <code>KernelInterruptError</code>           \u2013            <p>Raised to interrupt the kernel.</p> </li> <li> <code>Kernel</code>           \u2013            <p>A Jupyter kernel that supports concurrent execution providing an IPython InteractiveShell.</p> </li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.KernelInterruptError","title":"async_kernel.kernel.KernelInterruptError","text":"<p>               Bases: <code>InterruptedError</code></p> <p>Raised to interrupt the kernel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel","title":"async_kernel.kernel.Kernel","text":"<pre><code>Kernel(settings: dict | None = None)\n</code></pre> <p>               Bases: <code>HasTraits</code></p> <p>A Jupyter kernel that supports concurrent execution providing an IPython InteractiveShell.</p> Info <p>Only one instance of a kernel is created at a time per subprocess. The instance can be obtained with <code>Kernel()</code> or [get_kernel].</p> Starting the kernel <p>The kernel should appear in the list of kernels just as other kernels are. Variants of the kernel can with custom configuration can be added at the command line.</p> From the shellBlockingInside a coroutine <pre><code>async-kernel -f .\n</code></pre> <pre><code>Kernel().run()\n</code></pre> <pre><code>async with Kernel():\n    await anyio.sleep_forever()\n</code></pre> Warning <p>Starting the kernel outside the main thread has the following implicatations:     - Execute requests won't be run in the main thread.     - Interrupts via signals won't work, so thread blocking calls in the shell cannot be interrupted.</p> Origins <ul> <li>IPyKernel Kernel</li> <li>IPyKernel IPKernelApp</li> <li>IPyKernel IPythonKernel</li> </ul> Referenced by: <ul> <li> Reference <ul> <li> Reference Highlights </li> <li> asyncshell <code></code>\u00a0AsyncInteractiveShell </li> </ul> </li> <li> Usage Usage Caller </li> </ul> Returned by: <ul> <li> Reference asyncshell <code></code>\u00a0AsyncInteractiveShell <code></code>\u00a0kernel </li> </ul> <p>Methods:</p> <ul> <li> <code>load_connection_info</code>             \u2013              <p>Load connection info from a dict containing connection info.</p> </li> <li> <code>__aenter__</code>             \u2013              <p>Start the kernel in the current asynchronous context.</p> </li> <li> <code>load_settings</code>             \u2013              <p>Load settings into the kernel.</p> </li> <li> <code>run</code>             \u2013              <p>Run the kernel (blocking).</p> </li> <li> <code>stop</code>             \u2013              <p>A staticmethod to stop the running kernel.</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send a message on the zmq iopub socket.</p> </li> <li> <code>topic</code>             \u2013              <p>prefixed topic for IOPub messages.</p> </li> <li> <code>receive_msg_loop</code>             \u2013              <p>Continuously receives and processes messages from a ZeroMQ ROUTER socket in a loop.</p> </li> <li> <code>get_run_mode</code>             \u2013              <p>Determine the run mode for a given channel, message type and job.</p> </li> <li> <code>run_handler</code>             \u2013              <p>Asynchronously run a message handler for a given job, managing reply sending and execution state.</p> </li> <li> <code>schedule_job</code>             \u2013              <p>Schedules a job to be executed by the handler using the specified run mode.</p> </li> <li> <code>all_concurrency_run_modes</code>             \u2013              <p>Generates a dictionary containing all combinations of SocketID, and MsgType, along with their</p> </li> <li> <code>kernel_info_request</code>             \u2013              <p>Handle a kernel info request.</p> </li> <li> <code>comm_info_request</code>             \u2013              <p>Handle a comm info request.</p> </li> <li> <code>execute_request</code>             \u2013              <p>Handle a execute request.</p> </li> <li> <code>complete_request</code>             \u2013              <p>Handle a completion request.</p> </li> <li> <code>is_complete_request</code>             \u2013              <p>Handle a is_complete request.</p> </li> <li> <code>inspect_request</code>             \u2013              <p>Handle a inspect request.</p> </li> <li> <code>history_request</code>             \u2013              <p>Handle a history request.</p> </li> <li> <code>comm_open</code>             \u2013              <p>Handle a comm open request.</p> </li> <li> <code>comm_msg</code>             \u2013              <p>Handle a comm msg request.</p> </li> <li> <code>comm_close</code>             \u2013              <p>Handle a comm close request.</p> </li> <li> <code>interrupt_request</code>             \u2013              <p>Handle a interrupt request (control only).</p> </li> <li> <code>shutdown_request</code>             \u2013              <p>Handle a shutdown request (control only).</p> </li> <li> <code>debug_request</code>             \u2013              <p>Handle a debug request (control only).</p> </li> <li> <code>excepthook</code>             \u2013              <p>Handle an exception.</p> </li> <li> <code>unraisablehook</code>             \u2013              <p>Handle unraisable exceptions (during gc for instance).</p> </li> <li> <code>raw_input</code>             \u2013              <p>Forward raw_input to frontends.</p> </li> <li> <code>getpass</code>             \u2013              <p>Forward getpass to frontends.</p> </li> <li> <code>get_connection_info</code>             \u2013              <p>Return the connection info as a dict.</p> </li> <li> <code>get_parent</code>             \u2013              <p>A convenience method to access the 'message' in the current context if there is one.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callers</code>               (<code>Dict[Literal[shell, control], Caller]</code>)           \u2013            <p>The caller associated with the kernel once it has started.</p> </li> <li> <code>anyio_backend</code>               (<code>Container[Backend]</code>)           \u2013            <p>The anyio configured backend used to run the event loops.</p> </li> <li> <code>anyio_backend_options</code>               (<code>Dict[Backend, dict[str, Any] | None]</code>)           \u2013            <p>Default options to use with anyio.run. See also: <code>Kernel.handle_message_request</code>.</p> </li> <li> <code>help_links</code>           \u2013            </li> <li> <code>quiet</code>           \u2013            <p>Only send stdout/stderr to output stream.</p> </li> <li> <code>print_kernel_messages</code>           \u2013            <p>When enabled the kernel will print startup, shutdown and terminal errors.</p> </li> <li> <code>connection_file</code>               (<code>TraitType[Path, Path | str]</code>)           \u2013            <p>JSON file in which to store connection info </p> </li> <li> <code>kernel_name</code>               (<code>str | Unicode</code>)           \u2013            <p>The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.</p> </li> <li> <code>ip</code>           \u2013            <p>The kernel's IP address [default localhost].</p> </li> <li> <code>log</code>           \u2013            <p>The logging adapter.</p> </li> <li> <code>shell</code>           \u2013            <p>The interactive shell.</p> </li> <li> <code>session</code>           \u2013            <p>Handles serialization and sending of messages.</p> </li> <li> <code>debugger</code>           \u2013            <p>Handles debug requests.</p> </li> <li> <code>comm_manager</code>               (<code>Instance[CommManager]</code>)           \u2013            <p>Creates async_kernel.comm.Comm instances and maintains a mapping to <code>comm_id</code> to <code>Comm</code> instances.</p> </li> <li> <code>event_started</code>           \u2013            <p>An event that occurs when the kernel is started.</p> </li> <li> <code>event_stopped</code>           \u2013            <p>An event that occurs when the kernel is stopped.</p> </li> <li> <code>settings</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Settings that have been set to customise the behaviour of the kernel.</p> </li> <li> <code>execution_count</code>               (<code>int</code>)           \u2013            <p>The execution count in context of the current coroutine, else the current value if there isn't one in context.</p> </li> <li> <code>kernel_info</code>               (<code>dict[str, str | dict[str, str | dict[str, str | int]] | Any | tuple[Any, ...] | bool]</code>)           \u2013            <p>A dict of detail sent in reply to for a 'kernel_info_request'.</p> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def __init__(self, settings: dict | None = None, /) -&gt; None:\n    if not self._initialised:\n        self._initialised = True\n        super().__init__()\n        if not os.environ.get(\"MPLBACKEND\"):\n            os.environ[\"MPLBACKEND\"] = \"module://matplotlib_inline.backend_inline\"\n    if settings:\n        self.load_settings(settings)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.callers","title":"callers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>callers: Dict[Literal[shell, control], Caller] = Dict()\n</code></pre> <p>The caller associated with the kernel once it has started.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.anyio_backend","title":"anyio_backend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anyio_backend: Container[Backend] = UseEnum(Backend)\n</code></pre> <p>The anyio configured backend used to run the event loops.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0CallerCreateOptions <code></code>\u00a0backend </li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.anyio_backend_options","title":"anyio_backend_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anyio_backend_options: Dict[Backend, dict[str, Any] | None] = Dict(allow_none=True)\n</code></pre> <p>Default options to use with anyio.run. See also: <code>Kernel.handle_message_request</code>.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0CallerCreateOptions <code></code>\u00a0backend_options </li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.help_links","title":"help_links  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help_links = Tuple()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.quiet","title":"quiet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quiet = Bool(True)\n</code></pre> <p>Only send stdout/stderr to output stream.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.print_kernel_messages","title":"print_kernel_messages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print_kernel_messages = Bool(True)\n</code></pre> <p>When enabled the kernel will print startup, shutdown and terminal errors.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.connection_file","title":"connection_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection_file: TraitType[Path, Path | str] = TraitType()\n</code></pre> <p>JSON file in which to store connection info </p> <p><code>\"kernel-&lt;pid&gt;.json\"</code></p> <p>This file will contain the IP, ports, and authentication key needed to connect clients to this kernel. By default, this file will be created in the security dir of the current profile, but can be specified by absolute path.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_name","title":"kernel_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_name: str | Unicode = Unicode()\n</code></pre> <p>The kernels name - if it contains 'trio' a trio backend will be used instead of an asyncio backend.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.ip","title":"ip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ip = Unicode()\n</code></pre> <p>The kernel's IP address [default localhost].</p> <p>If the IP address is something other than localhost, then Consoles on other machines  will be able to connect to the Kernel, so be careful!</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log = Instance(LoggerAdapter)\n</code></pre> <p>The logging adapter.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = Instance(AsyncInteractiveShell, ())\n</code></pre> <p>The interactive shell.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session = Instance(Session, ())\n</code></pre> <p>Handles serialization and sending of messages.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debugger","title":"debugger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debugger = Instance(Debugger, ())\n</code></pre> <p>Handles debug requests.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_manager","title":"comm_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_manager: Instance[CommManager] = Instance('async_kernel.comm.CommManager')\n</code></pre> <p>Creates async_kernel.comm.Comm instances and maintains a mapping to <code>comm_id</code> to <code>Comm</code> instances.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.event_started","title":"event_started  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_started = Instance(Event, (), read_only=True)\n</code></pre> <p>An event that occurs when the kernel is started.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.event_stopped","title":"event_stopped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event_stopped = Instance(Event, (), read_only=True)\n</code></pre> <p>An event that occurs when the kernel is stopped.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict[str, Any]\n</code></pre> <p>Settings that have been set to customise the behaviour of the kernel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execution_count","title":"execution_count  <code>property</code>","text":"<pre><code>execution_count: int\n</code></pre> <p>The execution count in context of the current coroutine, else the current value if there isn't one in context.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_info","title":"kernel_info  <code>property</code>","text":"<pre><code>kernel_info: dict[\n    str, str | dict[str, str | dict[str, str | int]] | Any | tuple[Any, ...] | bool\n]\n</code></pre> <p>A dict of detail sent in reply to for a 'kernel_info_request'.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_connection_info","title":"load_connection_info","text":"<pre><code>load_connection_info(info: dict[str, Any]) -&gt; None\n</code></pre> <p>Load connection info from a dict containing connection info.</p> <p>Typically this data comes from a connection file and is called by load_connection_file.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def load_connection_info(self, info: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Load connection info from a dict containing connection info.\n\n    Typically this data comes from a connection file\n    and is called by load_connection_file.\n\n    Args:\n        info: Dictionary containing connection_info. See the connection_file spec for details.\n    \"\"\"\n    if self._ports:\n        msg = \"Connection info is already loaded!\"\n        raise RuntimeError(msg)\n    self.transport = info.get(\"transport\", self.transport)\n    self.ip = info.get(\"ip\") or self.ip\n    for socket in SocketID:\n        name = f\"{socket}_port\"\n        if socket not in self._ports and name in info:\n            self._ports[socket] = info[name]\n    if \"key\" in info:\n        key = info[\"key\"]\n        if isinstance(key, str):\n            key = key.encode()\n        assert isinstance(key, bytes)\n\n        self.session.key = key\n    if \"signature_scheme\" in info:\n        self.session.signature_scheme = info[\"signature_scheme\"]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_connection_info(info)","title":"<code>info</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary containing connection_info. See the connection_file spec for details.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Start the kernel in the current asynchronous context.</p> <ul> <li>Only one instance can (should) run at a time.</li> <li>An instance can only be started once.</li> <li>A new instance can be started after a previous instance has stopped and the context exited.</li> </ul> Example <pre><code>async with Kernel() as kernel:\n    await anyio.sleep_forever()\n</code></pre> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"\n    Start the kernel in the current asynchronous context.\n\n    - Only one instance can (should) run at a time.\n    - An instance can only be started once.\n    - A new instance can be started after a previous instance has stopped and the context exited.\n\n    Example:\n        ```python\n        async with Kernel() as kernel:\n            await anyio.sleep_forever()\n        ```\n    \"\"\"\n    assert not self.event_stopped\n    async with contextlib.AsyncExitStack() as stack:\n        sys.excepthook = self.excepthook\n        sys.unraisablehook = self.unraisablehook\n        with contextlib.suppress(ValueError):\n            signal.signal(signal.SIGINT, self._signal_handler)\n        await stack.enter_async_context(self._start_in_context())\n        self.__stack = stack.pop_all()\n    return self\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_settings","title":"load_settings","text":"<pre><code>load_settings(settings: dict[str, Any]) -&gt; None\n</code></pre> <p>Load settings into the kernel.</p> <p>Permitted until the kernel async context has been entered.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def load_settings(self, settings: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Load settings into the kernel.\n\n    Permitted until the kernel async context has been entered.\n\n    Args:\n        settings:\n            key: dotted.path.of.attribute.\n            value: The value to set.\n    \"\"\"\n    if self._sockets:\n        msg = \"It is too late to load settings!\"\n        raise RuntimeError(msg)\n    settings_ = self._settings or {\"kernel_name\": self.kernel_name}\n    for k, v in settings.items():\n        settings_ |= utils.setattr_nested(self, k, v)\n    self._settings = settings_\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.load_settings(settings)","title":"<code>settings</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>key: dotted.path.of.attribute. value: The value to set.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run","title":"run","text":"<pre><code>run(wait_exit: Callable[[], Awaitable] = sleep_forever)\n</code></pre> <p>Run the kernel (blocking).</p> <p>Parameters:</p> Warning <p>Running the kernel in a thread other than the 'MainThread' is permitted, but discouraged.</p> <ul> <li>Blocking calls can only be interrupted in the 'MainThread' because 'threads cannot be destroyed, stopped, suspended, resumed, or interrupted'.</li> <li>Some libraries may assume the call is occurring in the 'MainThread'.</li> <li>If there is an asyncio or trio event loop already running in the 'MainThread. Simply use <code>async with kernel</code> instead.</li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def run(self, wait_exit: Callable[[], Awaitable] = anyio.sleep_forever, /):\n    \"\"\"\n    Run the kernel (blocking).\n\n    Args:\n        wait_exit: The kernel will stop when the awaitable is complete.\n\n    Warning:\n        Running the kernel in a thread other than the 'MainThread' is permitted, but discouraged.\n\n        - Blocking calls can only be interrupted in the 'MainThread' because [*'threads cannot be destroyed, stopped, suspended, resumed, or interrupted'*](https://docs.python.org/3/library/threading.html#module-threading).\n        - Some libraries may assume the call is occurring in the 'MainThread'.\n        - If there is an asyncio or trio event loop already running in the 'MainThread. Simply use `async with kernel` instead.\n    \"\"\"\n    if getattr(self, \"_started\", False):\n        raise RuntimeError\n    self._started = True\n\n    async def _run() -&gt; None:\n        async with self:\n            with contextlib.suppress(anyio.get_cancelled_exc_class()):\n                await wait_exit()\n\n    try:\n        if not self.trait_has_value(\"anyio_backend\") and \"trio\" in self.kernel_name.lower():\n            self.anyio_backend = Backend.trio\n        backend = self.anyio_backend\n        backend_options = self.anyio_backend_options.get(backend)\n        anyio.run(_run, backend=backend, backend_options=backend_options)\n    finally:\n        self.stop()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run(wait_exit)","title":"<code>wait_exit</code>","text":"(<code>Callable[[], Awaitable]</code>, default:                   <code>sleep_forever</code> )           \u2013            <p>The kernel will stop when the awaitable is complete.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.stop","title":"stop  <code>staticmethod</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>A staticmethod to stop the running kernel.</p> <p>Once an instance of a kernel is stopped the instance cannot be restarted. Instead a new instance should be started.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>@staticmethod\ndef stop() -&gt; None:\n    \"\"\"\n    A [staticmethod][] to stop the running kernel.\n\n    Once an instance of a kernel is stopped the instance cannot be restarted.\n    Instead a new instance should be started.\n    \"\"\"\n    if (instance := Kernel._instance) and (stop := getattr(instance, \"_stop\", None)):\n        stop()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: dict[str, Any] | str,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send a message on the zmq iopub socket.</p> Referenced by: <ul> <li> Reference <ul> <li> asyncshell <ul> <li> <code></code>\u00a0AsyncDisplayHook </li> <li> <code></code>\u00a0AsyncDisplayPublisher </li> <li> <code></code>\u00a0asyncshell </li> </ul> </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0get_parent </li> </ul> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def iopub_send(\n    self,\n    msg_or_type: dict[str, Any] | str,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"Send a message on the zmq iopub socket.\"\"\"\n    if socket := Caller.iopub_sockets.get(thread := threading.current_thread()):\n        msg = self.session.send(\n            stream=socket,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else utils.get_parent(),  # pyright: ignore[reportArgumentType]\n            ident=ident,\n            buffers=buffers,\n        )\n        if msg:\n            self.log.debug(\n                \"iopub_send: (thread=%s) msg_type:'%s', content: %s\", thread.name, msg[\"msg_type\"], msg[\"content\"]\n            )\n    elif (caller := self.callers.get(SocketID.control)) and caller.thread is not thread:\n        caller.call_direct(\n            self.iopub_send,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else None,\n            ident=ident,\n            buffers=buffers,\n        )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.topic","title":"topic","text":"<pre><code>topic(topic) -&gt; bytes\n</code></pre> <p>prefixed topic for IOPub messages.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def topic(self, topic) -&gt; bytes:\n    \"\"\"prefixed topic for IOPub messages.\"\"\"\n    return (f\"kernel.{topic}\").encode()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.receive_msg_loop","title":"receive_msg_loop","text":"<pre><code>receive_msg_loop(socket_id: Literal[control, shell], ready: Event, start: Event) -&gt; None\n</code></pre> <p>Continuously receives and processes messages from a ZeroMQ ROUTER socket in a loop.</p> <p>Parameters:</p> Behavior <ul> <li>Binds a ROUTER socket for the specified socket_id.</li> <li>Calls the <code>started</code> callback after binding and a short delay.</li> <li>Enters a loop to receive messages from the socket.</li> <li>For each received message:<ul> <li>Determines the message type and retrieves the appropriate handler.</li> <li>Constructs a job dictionary containing message and context information.</li> <li>Determines the run mode for the message and dispatches the handler accordingly (queue, thread, task, or direct).</li> </ul> </li> <li>Handles invalid messages and logs errors.</li> <li>Exits the loop gracefully if the ZeroMQ context is terminated.</li> </ul> Exception handling <ul> <li>Handles and logs exceptions during message processing.</li> <li>Breaks the loop on <code>zmq.ContextTerminated</code>.</li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def receive_msg_loop(\n    self, socket_id: Literal[SocketID.control, SocketID.shell], ready: Event, start: Event\n) -&gt; None:\n    \"\"\"\n    Continuously receives and processes messages from a ZeroMQ ROUTER socket in a loop.\n\n    Args:\n        socket_id: The identifier for the socket to listen on (either control or shell).\n        ready: An event for the message loop to indicate it is ready.\n        start: An event to wait for before the loop is entered.\n\n    Behavior:\n        - Binds a ROUTER socket for the specified socket_id.\n        - Calls the `started` callback after binding and a short delay.\n        - Enters a loop to receive messages from the socket.\n        - For each received message:\n            - Determines the message type and retrieves the appropriate handler.\n            - Constructs a job dictionary containing message and context information.\n            - Determines the run mode for the message and dispatches the handler accordingly (queue, thread, task, or direct).\n        - Handles invalid messages and logs errors.\n        - Exits the loop gracefully if the ZeroMQ context is terminated.\n\n    Exception handling:\n        - Handles and logs exceptions during message processing.\n        - Breaks the loop on `zmq.ContextTerminated`.\n    \"\"\"\n    if not utils.LAUNCHED_BY_DEBUGPY:\n        utils.mark_thread_pydev_do_not_trace()\n    msg: Message\n    ident: list[bytes]\n    caller = self.callers[socket_id]\n    lock = BinarySemaphore()\n    with self._bind_socket(socket_id) as socket:\n        ready.set()\n        start.wait()\n        while True:\n            try:\n                ident, msg = self.session.recv(socket, mode=zmq.BLOCKY, copy=False)  # pyright: ignore[reportAssignmentType]\n                msg_type = MsgType(msg[\"header\"][\"msg_type\"])\n                job: Job = {\n                    \"socket_id\": socket_id,\n                    \"socket\": socket,\n                    \"ident\": ident,\n                    \"msg\": msg,\n                    \"received_time\": time.monotonic(),\n                }\n                run_mode = self.get_run_mode(msg_type, socket_id=socket_id, job=job)\n                handler = wrap_handler(self.run_handler, lock, self.get_handler(msg_type))\n                self.schedule_job(caller, lock, handler, run_mode, job)\n                self.log.debug(\"%s %s %s %s %s\", socket_id, msg_type, run_mode, handler, msg)\n            except zmq.ContextTerminated:\n                break\n            except Exception as e:\n                self.log.debug(\"Bad message on %s: %s\", socket_id, e)\n                continue\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.receive_msg_loop(socket_id)","title":"<code>socket_id</code>","text":"(<code>Literal[control, shell]</code>)           \u2013            <p>The identifier for the socket to listen on (either control or shell).</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.receive_msg_loop(ready)","title":"<code>ready</code>","text":"(<code>Event</code>)           \u2013            <p>An event for the message loop to indicate it is ready.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.receive_msg_loop(start)","title":"<code>start</code>","text":"(<code>Event</code>)           \u2013            <p>An event to wait for before the loop is entered.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode","title":"get_run_mode","text":"<pre><code>get_run_mode(\n    msg_type: MsgType,\n    *,\n    socket_id: Literal[shell, control] = shell,\n    job: Job | None = None,\n) -&gt; RunMode\n</code></pre> <p>Determine the run mode for a given channel, message type and job.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RunMode</code>           \u2013            <p>The run mode for the message.</p> </li> </ul> Referenced by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel </li> <li> typing <code></code>\u00a0RunMode </li> </ul> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_run_mode(\n    self,\n    msg_type: MsgType,\n    *,\n    socket_id: Literal[SocketID.shell, SocketID.control] = SocketID.shell,\n    job: Job | None = None,\n) -&gt; RunMode:\n    \"\"\"\n    Determine the run mode for a given channel, message type and job.\n\n    Args:\n        socket_id: The socket ID the message was received on.\n        msg_type: The type of the message.\n        job: The job associated with the message, if any.\n\n    Returns:\n        The run mode for the message.\n    \"\"\"\n\n    # TODO: Are any of these options worth including?\n    # if mode_from_metadata := job[\"msg\"][\"metadata\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_metadata)\n    # if mode_from_header := job[\"msg\"][\"header\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_header)\n    match (socket_id, msg_type):\n        case SocketID.shell, MsgType.shutdown_request | MsgType.debug_request:\n            msg = f\"{msg_type=} not allowed on shell!\"\n            raise ValueError(msg)\n        case SocketID.control, MsgType.execute_request:\n            return RunMode.task\n        case _, MsgType.execute_request:\n            if job:\n                if content := job[\"msg\"].get(\"content\", {}):\n                    if (code := content.get(\"code\")) and (mode_ := RunMode.get_mode(code)):\n                        return mode_\n                    if content.get(\"silent\"):\n                        return RunMode.task\n                if mode_ := set(utils.get_tags(job)).intersection(RunMode):\n                    return RunMode(next(iter(mode_)))\n        case _, MsgType.inspect_request | MsgType.history_request:\n            return RunMode.thread\n        case _:\n            pass\n    return RunMode.queue\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(socket_id)","title":"<code>socket_id</code>","text":"(<code>Literal[shell, control]</code>, default:                   <code>shell</code> )           \u2013            <p>The socket ID the message was received on.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(msg_type)","title":"<code>msg_type</code>","text":"(<code>MsgType</code>)           \u2013            <p>The type of the message.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(job)","title":"<code>job</code>","text":"(<code>Job | None</code>, default:                   <code>None</code> )           \u2013            <p>The job associated with the message, if any.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler","title":"run_handler  <code>async</code>","text":"<pre><code>run_handler(handler: HandlerType, lock: BinarySemaphore, job: Job[dict]) -&gt; None\n</code></pre> <p>Asynchronously run a message handler for a given job, managing reply sending and execution state.</p> <p>Parameters:</p> Workflow <ul> <li>Sets the current job context variable.</li> <li>Sends a \"busy\" status message on the IOPub channel.</li> <li>Awaits the handler; if it returns content, sends a reply using the provided lock.</li> <li>On exception, sends an error reply and logs the exception.</li> <li>Resets the job context variable.</li> <li>Sends an \"idle\" status message on the IOPub channel.</li> </ul> Notes <ul> <li>Replies are sent even if exceptions occur in the handler.</li> <li>The reply message type is derived from the original request type.</li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def run_handler(self, handler: HandlerType, lock: BinarySemaphore, job: Job[dict]) -&gt; None:\n    \"\"\"\n    Asynchronously run a message handler for a given job, managing reply sending and execution state.\n\n    Args:\n        handler: A coroutine function to handle the job / message.\n\n            - It is a method on the kernel whose name corresponds to the [message type that it handles][async_kernel.typing.MsgType].\n            - The handler should return a dict to use as 'content'in a reply.\n            - If status is not included in the dict it gets added automatically as `{'status': 'ok'}`.\n            - If a reply is not expected the handler should return `None`.\n\n        lock: An async semaphore used to synchronize reply sending.\n        job: The job dictionary containing message, socket, and identification information.\n\n    Workflow:\n        - Sets the current job context variable.\n        - Sends a \"busy\" status message on the IOPub channel.\n        - Awaits the handler; if it returns content, sends a reply using the provided lock.\n        - On exception, sends an error reply and logs the exception.\n        - Resets the job context variable.\n        - Sends an \"idle\" status message on the IOPub channel.\n\n    Notes:\n        - Replies are sent even if exceptions occur in the handler.\n        - The reply message type is derived from the original request type.\n    \"\"\"\n\n    async def send_reply(job: Job[dict], content: dict, /) -&gt; None:\n        if \"status\" not in content:\n            content[\"status\"] = \"ok\"\n        # Although we aren't sending from the thread where the socket belongs this still appears to be reliable.\n        async with lock:\n            msg = self.session.send(\n                stream=job[\"socket\"],\n                msg_or_type=job[\"msg\"][\"header\"][\"msg_type\"].replace(\"request\", \"reply\"),\n                content=content,\n                parent=job[\"msg\"][\"header\"],  # pyright: ignore[reportArgumentType]\n                ident=job[\"ident\"],\n            )\n            if msg:\n                self.log.debug(\"*** _send_reply %s*** %s\", job[\"socket_id\"], msg)\n\n    token = utils._job_var.set(job)  # pyright: ignore[reportPrivateUsage]\n    try:\n        self.iopub_send(msg_or_type=\"status\", content={\"execution_state\": \"busy\"}, ident=self.topic(\"status\"))\n        if (content := await handler(job)) is not None:\n            await send_reply(job, content)\n    except Exception as e:\n        await send_reply(job, error_to_content(e))\n        self.log.exception(\"Exception in message handler:\", exc_info=e)\n    finally:\n        utils._job_var.reset(token)  # pyright: ignore[reportPrivateUsage]\n        self.iopub_send(\n            msg_or_type=\"status\", parent=job[\"msg\"], content={\"execution_state\": \"idle\"}, ident=self.topic(\"status\")\n        )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(handler)","title":"<code>handler</code>","text":"(<code>HandlerType</code>)           \u2013            <p>A coroutine function to handle the job / message.</p> <ul> <li>It is a method on the kernel whose name corresponds to the message type that it handles.</li> <li>The handler should return a dict to use as 'content'in a reply.</li> <li>If status is not included in the dict it gets added automatically as <code>{'status': 'ok'}</code>.</li> <li>If a reply is not expected the handler should return <code>None</code>.</li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(lock)","title":"<code>lock</code>","text":"(<code>BinarySemaphore</code>)           \u2013            <p>An async semaphore used to synchronize reply sending.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler(job)","title":"<code>job</code>","text":"(<code>Job[dict]</code>)           \u2013            <p>The job dictionary containing message, socket, and identification information.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.schedule_job","title":"schedule_job","text":"<pre><code>schedule_job(\n    caller: Caller,\n    lock: BinarySemaphore,\n    handler: HandlerType,\n    run_mode: RunMode,\n    job: Job,\n)\n</code></pre> <p>Schedules a job to be executed by the handler using the specified run mode.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def schedule_job(self, caller: Caller, lock: BinarySemaphore, handler: HandlerType, run_mode: RunMode, job: Job, /):\n    \"\"\"\n    Schedules a job to be executed by the handler using the specified run mode.\n\n    Args:\n        caller: The caller instance responsible for scheduling.\n        lock: A binary semaphore for synchronization (not used in this method).\n        handler: The function or callable to execute for the job.\n        run_mode: The mode in which to run the job.\n        job: The job instance or data to be passed to the handler.\n    \"\"\"\n    match run_mode:\n        case RunMode.direct:\n            caller.call_direct(handler, job)\n        case RunMode.queue:\n            caller.queue_call(handler, job)\n        case RunMode.task:\n            caller.call_soon(handler, job)\n        case RunMode.thread:\n            caller.to_thread(handler, job)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.schedule_job(caller)","title":"<code>caller</code>","text":"(<code>Caller</code>)           \u2013            <p>The caller instance responsible for scheduling.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.schedule_job(lock)","title":"<code>lock</code>","text":"(<code>BinarySemaphore</code>)           \u2013            <p>A binary semaphore for synchronization (not used in this method).</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.schedule_job(handler)","title":"<code>handler</code>","text":"(<code>HandlerType</code>)           \u2013            <p>The function or callable to execute for the job.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.schedule_job(run_mode)","title":"<code>run_mode</code>","text":"(<code>RunMode</code>)           \u2013            <p>The mode in which to run the job.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.schedule_job(job)","title":"<code>job</code>","text":"(<code>Job</code>)           \u2013            <p>The job instance or data to be passed to the handler.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.all_concurrency_run_modes","title":"all_concurrency_run_modes","text":"<pre><code>all_concurrency_run_modes(\n    socket_ids: Iterable[Literal[shell, control]] = (shell, control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"MsgType\", \"RunMode\"], tuple[SocketID, MsgType, RunMode | None]\n]\n</code></pre> <p>Generates a dictionary containing all combinations of SocketID, and MsgType, along with their corresponding RunMode (if available).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def all_concurrency_run_modes(\n    self,\n    socket_ids: Iterable[Literal[SocketID.shell, SocketID.control]] = (SocketID.shell, SocketID.control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"MsgType\", \"RunMode\"],\n    tuple[SocketID, MsgType, RunMode | None],\n]:\n    \"\"\"\n    Generates a dictionary containing all combinations of SocketID, and MsgType, along with their\n    corresponding RunMode (if available).\n    \"\"\"\n    data: list[Any] = []\n    for socket_id in socket_ids:\n        for msg_type in msg_types:\n            try:\n                mode = self.get_run_mode(msg_type, socket_id=socket_id)\n            except ValueError:\n                mode = None\n            data.append((socket_id, msg_type, mode))\n    data_ = zip(*data, strict=True)\n    return dict(zip([\"SocketID\", \"MsgType\", \"RunMode\"], data_, strict=True))\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_info_request","title":"kernel_info_request  <code>async</code>","text":"<pre><code>kernel_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a kernel info request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0kernel_info_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def kernel_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [kernel info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-info).\"\"\"\n    return self.kernel_info\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_info_request","title":"comm_info_request  <code>async</code>","text":"<pre><code>comm_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a comm info request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0comm_info_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [comm info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-info).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    target_name = c.get(\"target_name\", None)\n    comms = {\n        k: {\"target_name\": v.target_name}\n        for (k, v) in tuple(self.comm_manager.comms.items())\n        if v.target_name == target_name or target_name is None\n    }\n    return {\"comms\": comms}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execute_request","title":"execute_request  <code>async</code>","text":"<pre><code>execute_request(job: Job[ExecuteContent]) -&gt; Content\n</code></pre> <p>Handle a execute request.</p> Referenced by: <ul> <li> Reference <ul> <li> asyncshell <code></code>\u00a0AsyncInteractiveShell <ul> <li> <code></code>\u00a0execute_request_timeout </li> <li> <code></code>\u00a0run_cell_async </li> </ul> </li> <li> typing <code></code>\u00a0MsgType <code></code>\u00a0execute_request </li> </ul> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def execute_request(self, job: Job[ExecuteContent], /) -&gt; Content:\n    \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    if (job[\"received_time\"] &lt; self._stop_on_error_time) and not c.get(\"silent\", False):\n        self.log.info(\"Aborting execute_request: %s\", job)\n        return error_to_content(RuntimeError(\"Aborting due to prior exception\")) | {\n            \"execution_count\": self.execution_count\n        }\n    metadata = job[\"msg\"].get(\"metadata\") or {}\n    if not (silent := c[\"silent\"]):\n        self._execution_count += 1\n        utils._execution_count_var.set(self._execution_count)  # pyright: ignore[reportPrivateUsage]\n        self.iopub_send(\n            msg_or_type=\"execute_input\",\n            content={\"code\": c[\"code\"], \"execution_count\": self.execution_count},\n            parent=job[\"msg\"],\n            ident=self.topic(\"execute_input\"),\n        )\n    caller = Caller.get()\n    err = None\n    with anyio.CancelScope() as scope:\n\n        def cancel():\n            if not silent:\n                caller.call_direct(scope.cancel, \"Interrupted\")\n\n        try:\n            self._interrupts.add(cancel)\n            result = await self.shell.run_cell_async(\n                raw_cell=c[\"code\"],\n                store_history=c.get(\"store_history\", False),\n                silent=silent,\n                transformed_cell=self.shell.transform_cell(c[\"code\"]),\n                shell_futures=True,\n            )\n        except (Exception, anyio.get_cancelled_exc_class()) as e:\n            # A safeguard to catch exceptions not caught by the shell.\n            err = KernelInterruptError() if self._last_interrupt_frame else e\n        else:\n            err = result.error_before_exec or result.error_in_exec if result else KernelInterruptError()\n        self._interrupts.discard(cancel)\n    if (err) and (\n        (Tags.suppress_error in metadata.get(\"tags\", ()))\n        or (isinstance(err, anyio.get_cancelled_exc_class()) and (utils.get_execute_request_timeout() is not None))\n    ):\n        # Suppress the error due to either:\n        # 1. tag\n        # 2. timeout\n        err = None\n    content = {\n        \"status\": \"error\" if err else \"ok\",\n        \"execution_count\": self.execution_count,\n        \"user_expressions\": self.shell.user_expressions(c.get(\"user_expressions\", {})),\n    }\n    if err:\n        content |= error_to_content(err)\n        if (not silent) and c.get(\"stop_on_error\"):\n            try:\n                self._stop_on_error_time = math.inf\n                self.log.info(\"An error occurred in a non-silent execution request\")\n                await anyio.sleep(0)\n            finally:\n                self._stop_on_error_time = time.monotonic()\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.complete_request","title":"complete_request  <code>async</code>","text":"<pre><code>complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a completion request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0complete_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    code: str = c[\"code\"]\n    cursor_pos = c.get(\"cursor_pos\") or len(code)\n    with IPython.core.completer.provisionalcompleter():\n        completions = self.shell.Completer.completions(code, cursor_pos)\n        completions = list(IPython.core.completer.rectify_completions(code, completions))\n    comps = [\n        {\n            \"start\": comp.start,\n            \"end\": comp.end,\n            \"text\": comp.text,\n            \"type\": comp.type,\n            \"signature\": comp.signature,\n        }\n        for comp in completions\n    ]\n    s, e = completions[0].start, completions[0].end if completions else (cursor_pos, cursor_pos)\n    matches = [c.text for c in completions]\n    return {\n        \"matches\": matches,\n        \"cursor_end\": e,\n        \"cursor_start\": s,\n        \"metadata\": {\"_jupyter_types_experimental\": comps},\n    }\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.is_complete_request","title":"is_complete_request  <code>async</code>","text":"<pre><code>is_complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a is_complete request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0is_complete_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def is_complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n    status, indent_spaces = self.shell.input_transformer_manager.check_complete(job[\"msg\"][\"content\"][\"code\"])\n    content = {\"status\": status}\n    if status == \"incomplete\":\n        content[\"indent\"] = \" \" * indent_spaces\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.inspect_request","title":"inspect_request  <code>async</code>","text":"<pre><code>inspect_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a inspect request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0inspect_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def inspect_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    detail_level = int(c.get(\"detail_level\", 0))\n    omit_sections = set(c.get(\"omit_sections\", []))\n    name = token_at_cursor(c[\"code\"], c[\"cursor_pos\"])\n    content = {\"data\": {}, \"metadata\": {}, \"found\": True}\n    try:\n        bundle = self.shell.object_inspect_mime(name, detail_level=detail_level, omit_sections=omit_sections)\n        content[\"data\"] = bundle\n        if not self.shell.enable_html_pager:\n            content[\"data\"].pop(\"text/html\")\n    except KeyError:\n        content[\"found\"] = False\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.history_request","title":"history_request  <code>async</code>","text":"<pre><code>history_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a history request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0history_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def history_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    history_manager = self.shell.history_manager\n    assert history_manager\n    if c.get(\"hist_access_type\") == \"tail\":\n        hist = history_manager.get_tail(c[\"n\"], raw=c.get(\"raw\"), output=c.get(\"output\"), include_latest=True)\n    elif c.get(\"hist_access_type\") == \"range\":\n        hist = history_manager.get_range(\n            c.get(\"session\", 0),\n            c.get(\"start\", 1),\n            c.get(\"stop\", None),\n            raw=c.get(\"raw\", True),\n            output=c.get(\"output\", False),\n        )\n    elif c.get(\"hist_access_type\") == \"search\":\n        hist = history_manager.search(\n            c.get(\"pattern\"), raw=c.get(\"raw\"), output=c.get(\"output\"), n=c.get(\"n\"), unique=c.get(\"unique\")\n        )\n    else:\n        hist = []\n    return {\"history\": list(hist)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_open","title":"comm_open  <code>async</code>","text":"<pre><code>comm_open(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm open request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0comm_open </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_open(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm open request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#opening-a-comm).\"\"\"\n    self.comm_manager.comm_open(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_msg","title":"comm_msg  <code>async</code>","text":"<pre><code>comm_msg(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm msg request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0comm_msg </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_msg(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm msg request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-messages).\"\"\"\n    self.comm_manager.comm_msg(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_close","title":"comm_close  <code>async</code>","text":"<pre><code>comm_close(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm close request.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0comm_close </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_close(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm close request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#tearing-down-comms).\"\"\"\n    self.comm_manager.comm_close(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.interrupt_request","title":"interrupt_request  <code>async</code>","text":"<pre><code>interrupt_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a interrupt request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0interrupt_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def interrupt_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [interrupt request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-interrupt) (control only).\"\"\"\n    self._interrupt_requested = True\n    if self.callers[SocketID.shell].thread is threading.main_thread():\n        if sys.platform == \"win32\":\n            signal.raise_signal(signal.SIGINT)\n            time.sleep(0)\n        else:\n            os.kill(os.getpid(), signal.SIGINT)\n    for interrupter in tuple(self._interrupts):\n        interrupter()\n    return {}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shutdown_request","title":"shutdown_request  <code>async</code>","text":"<pre><code>shutdown_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a shutdown request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0shutdown_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def shutdown_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [shutdown request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-shutdown) (control only).\"\"\"\n    self.stop()\n    return {\"restart\": job[\"msg\"][\"content\"].get(\"restart\", False)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debug_request","title":"debug_request  <code>async</code>","text":"<pre><code>debug_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a debug request (control only).</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MsgType <code></code>\u00a0debug_request </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def debug_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [debug request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#debug-request) (control only).\"\"\"\n    return await self.debugger.process_request(job[\"msg\"][\"content\"])\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.excepthook","title":"excepthook","text":"<pre><code>excepthook(etype, evalue, tb) -&gt; None\n</code></pre> <p>Handle an exception.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def excepthook(self, etype, evalue, tb) -&gt; None:\n    \"\"\"Handle an exception.\"\"\"\n    # write uncaught traceback to 'real' stderr, not zmq-forwarder\n    if self.print_kernel_messages:\n        traceback.print_exception(etype, evalue, tb, file=sys.__stderr__)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.unraisablehook","title":"unraisablehook","text":"<pre><code>unraisablehook(unraisable: UnraisableHookArgs) -&gt; None\n</code></pre> <p>Handle unraisable exceptions (during gc for instance).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def unraisablehook(self, unraisable: sys.UnraisableHookArgs, /) -&gt; None:\n    \"Handle unraisable exceptions (during gc for instance).\"\n    exc_info = (\n        unraisable.exc_type,\n        unraisable.exc_value or unraisable.exc_type(unraisable.err_msg),\n        unraisable.exc_traceback,\n    )\n    self.log.exception(unraisable.err_msg, exc_info=exc_info, extra={\"object\": unraisable.object})\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.raw_input","title":"raw_input","text":"<pre><code>raw_input(prompt='') -&gt; Any\n</code></pre> <p>Forward raw_input to frontends.</p> <p>Raises:</p> <ul> <li> <code>StdinNotImplementedError</code>             \u2013            <p>if active frontend doesn't support stdin.</p> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def raw_input(self, prompt=\"\") -&gt; Any:\n    \"\"\"\n    Forward raw_input to frontends.\n\n    Raises:\n       IPython.core.error.StdinNotImplementedError: if active frontend doesn't support stdin.\n    \"\"\"\n    return self._input_request(str(prompt), password=False)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.getpass","title":"getpass","text":"<pre><code>getpass(prompt='') -&gt; Any\n</code></pre> <p>Forward getpass to frontends.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def getpass(self, prompt=\"\") -&gt; Any:\n    \"\"\"Forward getpass to frontends.\"\"\"\n    return self._input_request(prompt, password=True)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_connection_info","title":"get_connection_info","text":"<pre><code>get_connection_info() -&gt; dict[str, Any]\n</code></pre> <p>Return the connection info as a dict.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_connection_info(self) -&gt; dict[str, Any]:\n    \"\"\"Return the connection info as a dict.\"\"\"\n    with self.connection_file.open(\"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_parent","title":"get_parent","text":"<pre><code>get_parent() -&gt; Message[dict[str, Any]] | None\n</code></pre> <p>A convenience method to access the 'message' in the current context if there is one.</p> <p>'parent' is the parameter name used by Session.send to provide context when sending a reply.</p> See also <ul> <li>Kernel.iopub_send</li> <li>ipywidgets.Output:     Uses <code>get_ipython().kernel.get_parent()</code> to obtain the <code>msg_id</code> which     is used to 'capture' output when its context has been acquired.</li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_parent(self) -&gt; Message[dict[str, Any]] | None:\n    \"\"\"\n    A convenience method to access the 'message' in the current context if there is one.\n\n    'parent' is the parameter name used by [Session.send][jupyter_client.session.Session.send] to provide context when sending a reply.\n\n    See also:\n        - [Kernel.iopub_send][Kernel.iopub_send]\n        - [ipywidgets.Output][ipywidgets.widgets.widget_output.Output]:\n            Uses `get_ipython().kernel.get_parent()` to obtain the `msg_id` which\n            is used to 'capture' output when its context has been acquired.\n    \"\"\"\n    return utils.get_parent()\n</code></pre>"},{"location":"reference/kernelspec/","title":"kernelspec","text":"<p>Add and remove kernel specifications for Jupyter.</p> <p>Functions:</p> <ul> <li> <code>make_argv</code>             \u2013              <p>Returns an argument vector (argv) that can be used to start a <code>Kernel</code>.</p> </li> <li> <code>write_kernel_spec</code>             \u2013              <p>Write a kernel spec for launching a kernel.</p> </li> <li> <code>get_kernel_dir</code>             \u2013              <p>The path to where kernel specs are stored for Jupyter.</p> </li> </ul>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv","title":"async_kernel.kernelspec.make_argv","text":"<pre><code>make_argv(\n    *,\n    connection_file: str = \"{connection_file}\",\n    kernel_name: KernelName | str = asyncio,\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    fullpath: bool = True,\n    **kwargs: dict[str, Any],\n) -&gt; list[str]\n</code></pre> <p>Returns an argument vector (argv) that can be used to start a <code>Kernel</code>.</p> <p>This function returns a list of arguments can be used directly start a kernel with subprocess.Popen. It will always call command.command_line as a python module.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[str]</code> )          \u2013            <p>A list of command-line arguments to launch the kernel module.</p> </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def make_argv(\n    *,\n    connection_file: str = \"{connection_file}\",\n    kernel_name: KernelName | str = KernelName.asyncio,\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    fullpath: bool = True,\n    **kwargs: dict[str, Any],\n) -&gt; list[str]:\n    \"\"\"Returns an argument vector (argv) that can be used to start a `Kernel`.\n\n    This function returns a list of arguments can be used directly start a kernel with [subprocess.Popen][].\n    It will always call [command.command_line][] as a python module.\n\n    Args:\n        connection_file: The path to the connection file.\n        kernel_factory: Either the kernel factory object itself, or the string import path to a\n            callable that returns a non-started kernel.\n        kernel_name: The name of the kernel to use.\n        fullpath: If True the full path to the executable is used, otherwise 'python' is used.\n        **kwargs: Additional settings to pass when creating the kernel passed to `kernel_factory`.\n\n    Returns:\n        list: A list of command-line arguments to launch the kernel module.\n    \"\"\"\n    argv = [(sys.executable if fullpath else \"python\"), \"-m\", \"async_kernel\", \"-f\", connection_file]\n    for k, v in ({\"kernel_factory\": kernel_factory, \"kernel_name\": kernel_name} | kwargs).items():\n        argv.append(f\"--{k}={v}\")\n    return argv\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(connection_file)","title":"<code>connection_file</code>","text":"(<code>str</code>, default:                   <code>'{connection_file}'</code> )           \u2013            <p>The path to the connection file.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(kernel_factory)","title":"<code>kernel_factory</code>","text":"(<code>str | KernelFactoryType</code>, default:                   <code>'async_kernel.Kernel'</code> )           \u2013            <p>Either the kernel factory object itself, or the string import path to a callable that returns a non-started kernel.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(kernel_name)","title":"<code>kernel_name</code>","text":"(<code>KernelName | str</code>, default:                   <code>asyncio</code> )           \u2013            <p>The name of the kernel to use.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(fullpath)","title":"<code>fullpath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True the full path to the executable is used, otherwise 'python' is used.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.make_argv(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional settings to pass when creating the kernel passed to <code>kernel_factory</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec","title":"async_kernel.kernelspec.write_kernel_spec","text":"<pre><code>write_kernel_spec(\n    path: Path | str | None = None,\n    *,\n    kernel_name: KernelName | str,\n    display_name: str = \"\",\n    fullpath: bool = False,\n    prefix: str = \"\",\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    connection_file: str = \"{connection_file}\",\n    **kwargs: dict[str, Any],\n) -&gt; Path\n</code></pre> <p>Write a kernel spec for launching a kernel.</p> <p>Parameters:</p> <p>Example passing a callable kernel_factory:</p> <pre><code>When `kernel_factory` is passed as a callable, the callable is stored in the file\n'kernel_spec.py' inside the kernelspec folder.\n\n```python\nimport async_kernel.kernelspec\n\n\ndef kernel_factory(settings):\n    from async_kernel import Kernel\n\n    class MyKernel(Kernel):\n        async def execute_request(self, job):\n            print(job)\n            return await super().execute_request(job)\n\n    return MyKernel(settings)\n\n\nasync_kernel.kernelspec.write_kernel_spec(\n    kernel_name=\"async-print-job\", kernel_factory=kernel_factory\n)\n```\n\nWarning:\n    Moving the spec folder will break the import which is stored as an absolute path.\n</code></pre> Referenced by: <ul> <li> Usage Command line Add a kernel spec Custom arguments </li> </ul> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def write_kernel_spec(\n    path: Path | str | None = None,\n    *,\n    kernel_name: KernelName | str,\n    display_name: str = \"\",\n    fullpath: bool = False,\n    prefix: str = \"\",\n    kernel_factory: str | KernelFactoryType = \"async_kernel.Kernel\",\n    connection_file: str = \"{connection_file}\",\n    **kwargs: dict[str, Any],\n) -&gt; Path:\n    \"\"\"\n    Write a kernel spec for launching a kernel.\n\n    Args:\n        path: The path where to write the spec.\n        kernel_name: The name of the kernel to use.\n        fullpath: If True the full path to the executable is used, otherwise 'python' is used.\n        display_name: The display name for Jupyter to use for the kernel. The default is `\"Python ({kernel_name})\"`.\n        kernel_factory: The string import path to a callable that creates the Kernel or,\n            a *self-contained* function that returns an instance of a `Kernel`.\n        connection_file: The path to the connection file.\n        prefix: given, the kernelspec will be installed to PREFIX/share/jupyter/kernels/KERNEL_NAME.\n            This can be sys.prefix for installation inside virtual or conda envs.\n        **kwargs: Pass additional settings to set on the instance of the `Kernel` when it is instantiated.\n            Each setting should correspond to the dotted path to the attribute relative to the kernel.\n            For example `..., **{'shell.execute_request_timeout'=0.1})`.\n\n    Example passing a callable kernel_factory:\n\n        When `kernel_factory` is passed as a callable, the callable is stored in the file\n        'kernel_spec.py' inside the kernelspec folder.\n\n        ```python\n        import async_kernel.kernelspec\n\n\n        def kernel_factory(settings):\n            from async_kernel import Kernel\n\n            class MyKernel(Kernel):\n                async def execute_request(self, job):\n                    print(job)\n                    return await super().execute_request(job)\n\n            return MyKernel(settings)\n\n\n        async_kernel.kernelspec.write_kernel_spec(\n            kernel_name=\"async-print-job\", kernel_factory=kernel_factory\n        )\n        ```\n\n        Warning:\n            Moving the spec folder will break the import which is stored as an absolute path.\n    \"\"\"\n    assert re.match(re.compile(r\"^[a-z0-9._\\-]+$\", re.IGNORECASE), kernel_name)\n    path = Path(path) if path else (get_kernel_dir(prefix) / kernel_name)\n    # stage resources\n    try:\n        path.mkdir(parents=True, exist_ok=True)\n        if callable(kernel_factory):\n            with path.joinpath(\"kernel_factory.py\").open(\"w\") as f:\n                f.write(textwrap.dedent(inspect.getsource(kernel_factory)))\n            kernel_factory = f\"{path}{CUSTOM_KERNEL_MARKER}{kernel_factory.__name__}\"\n        # validate\n        if kernel_factory != \"async_kernel.Kernel\":\n            import_kernel_factory(kernel_factory)\n        shutil.copytree(src=RESOURCES, dst=path, dirs_exist_ok=True)\n        spec = KernelSpec()\n        spec.argv = make_argv(\n            kernel_factory=kernel_factory,\n            connection_file=connection_file,\n            kernel_name=kernel_name,\n            fullpath=fullpath,\n            **kwargs,\n        )\n        spec.name = kernel_name\n        spec.display_name = display_name or f\"Python ({kernel_name})\"\n        spec.language = \"python\"\n        spec.interrupt_mode = \"message\"\n        spec.metadata = {\"debugger\": True}\n        # write kernel.json\n        with path.joinpath(\"kernel.json\").open(\"w\") as f:\n            json.dump(spec.to_dict(), f, indent=1)\n    except Exception:\n        shutil.rmtree(path, ignore_errors=True)\n        raise\n    else:\n        return path\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(path)","title":"<code>path</code>","text":"(<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path where to write the spec.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(kernel_name)","title":"<code>kernel_name</code>","text":"(<code>KernelName | str</code>)           \u2013            <p>The name of the kernel to use.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(fullpath)","title":"<code>fullpath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True the full path to the executable is used, otherwise 'python' is used.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(display_name)","title":"<code>display_name</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The display name for Jupyter to use for the kernel. The default is <code>\"Python ({kernel_name})\"</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(kernel_factory)","title":"<code>kernel_factory</code>","text":"(<code>str | KernelFactoryType</code>, default:                   <code>'async_kernel.Kernel'</code> )           \u2013            <p>The string import path to a callable that creates the Kernel or, a self-contained function that returns an instance of a <code>Kernel</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(connection_file)","title":"<code>connection_file</code>","text":"(<code>str</code>, default:                   <code>'{connection_file}'</code> )           \u2013            <p>The path to the connection file.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>given, the kernelspec will be installed to PREFIX/share/jupyter/kernels/KERNEL_NAME. This can be sys.prefix for installation inside virtual or conda envs.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.write_kernel_spec(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Pass additional settings to set on the instance of the <code>Kernel</code> when it is instantiated. Each setting should correspond to the dotted path to the attribute relative to the kernel. For example <code>..., **{'shell.execute_request_timeout'=0.1})</code>.</p>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.get_kernel_dir","title":"async_kernel.kernelspec.get_kernel_dir","text":"<pre><code>get_kernel_dir(prefix: str = '') -&gt; Path\n</code></pre> <p>The path to where kernel specs are stored for Jupyter.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernelspec.py</code> <pre><code>def get_kernel_dir(prefix: str = \"\") -&gt; Path:\n    \"\"\"\n    The path to where kernel specs are stored for Jupyter.\n\n    Args:\n        prefix: Defaults to sys.prefix (installable for a particular environment).\n    \"\"\"\n    return Path(prefix or sys.prefix) / \"share/jupyter/kernels\"\n</code></pre>"},{"location":"reference/kernelspec/#async_kernel.kernelspec.get_kernel_dir(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Defaults to sys.prefix (installable for a particular environment).</p>"},{"location":"reference/pending/","title":"pending","text":"<p>Classes:</p> <ul> <li> <code>PendingCancelled</code>           \u2013            <p>Used to indicate the pending is cancelled.</p> </li> <li> <code>InvalidStateError</code>           \u2013            <p>An invalid state of the pending.</p> </li> <li> <code>Pending</code>           \u2013            <p>A thread-safe, awaitable object representing a pending asynchronous result.</p> </li> </ul>"},{"location":"reference/pending/#async_kernel.pending.PendingCancelled","title":"async_kernel.pending.PendingCancelled","text":"<p>               Bases: <code>ClosedResourceError</code></p> <p>Used to indicate the pending is cancelled.</p> Raised by: <ul> <li> Reference pending <code></code>\u00a0Pending <ul> <li> <code></code>\u00a0exception </li> <li> <code></code>\u00a0result </li> <li> <code></code>\u00a0wait </li> <li> <code></code>\u00a0wait_sync </li> </ul> </li> </ul>"},{"location":"reference/pending/#async_kernel.pending.InvalidStateError","title":"async_kernel.pending.InvalidStateError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An invalid state of the pending.</p> Raised by: <ul> <li> Reference pending <code></code>\u00a0Pending <ul> <li> <code></code>\u00a0exception </li> <li> <code></code>\u00a0result </li> </ul> </li> </ul>"},{"location":"reference/pending/#async_kernel.pending.Pending","title":"async_kernel.pending.Pending","text":"<pre><code>Pending(**metadata)\n</code></pre> <p>               Bases: <code>Awaitable[T]</code></p> <p>A thread-safe, awaitable object representing a pending asynchronous result.</p> <p>The <code>Pending</code> class provides a mechanism for waiting on a result or exception to be set, either asynchronously or synchronously. It supports cancellation, metadata storage, and callback registration for completion events.</p> <p>Attributes:</p> <ul> <li> <code>**metadata</code>           \u2013            <p>Arbitrary keyword arguments to associate as metadata with the instance.</p> </li> </ul> Properties <p>metadata (dict[str, Any]): Metadata passed during creation.</p> Referenced by: <ul> <li> Reference Reference Highlights </li> </ul> Returned by: <ul> <li> Reference caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0as_completed </li> <li> <code></code>\u00a0call_later </li> <li> <code></code>\u00a0call_soon </li> <li> <code></code>\u00a0current_pending </li> <li> <code></code>\u00a0queue_get </li> <li> <code></code>\u00a0schedule_call </li> <li> <code></code>\u00a0to_thread </li> <li> <code></code>\u00a0to_thread_advanced </li> <li> <code></code>\u00a0wait </li> </ul> </li> </ul> Used by: <ul> <li> Reference caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0as_completed </li> <li> <code></code>\u00a0wait </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>wait</code>             \u2013              <p>Wait for a result or exception to be set (thread-safe) returning the pending if specified.</p> </li> <li> <code>wait_sync</code>             \u2013              <p>Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.</p> </li> <li> <code>set_result</code>             \u2013              <p>Set the result (thread-safe).</p> </li> <li> <code>set_exception</code>             \u2013              <p>Set the exception (thread-safe).</p> </li> <li> <code>cancel</code>             \u2013              <p>Cancel the instance.</p> </li> <li> <code>cancelled</code>             \u2013              <p>Return True if the pending is cancelled.</p> </li> <li> <code>set_canceller</code>             \u2013              <p>Set a callback to handle cancellation.</p> </li> <li> <code>done</code>             \u2013              <p>Returns True if a result or exception has been set.</p> </li> <li> <code>add_done_callback</code>             \u2013              <p>Add a callback for when the pending is done (not thread-safe).</p> </li> <li> <code>remove_done_callback</code>             \u2013              <p>Remove all instances of a callback from the callbacks list.</p> </li> <li> <code>result</code>             \u2013              <p>Return the result.</p> </li> <li> <code>exception</code>             \u2013              <p>Return the exception.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def __init__(self, **metadata) -&gt; None:\n    self._done_callbacks: deque[Callable[[Self], Any]] = deque()\n    self._metadata_mappings[id(self)] = metadata\n    self._done = False\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.REPR_OMIT","title":"REPR_OMIT  <code>class-attribute</code>","text":"<pre><code>REPR_OMIT: set[str] = {'func', 'args', 'kwargs'}\n</code></pre> <p>Keys of metadata to omit when creating a repr of the instance.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre> <p>The metadata passed as keyword arguments to the instance during creation.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    *,\n    timeout: float | None = ...,\n    shield: bool = False | ...,\n    result: Literal[True] = True,\n) -&gt; T\n</code></pre><pre><code>wait(*, timeout: float | None = ..., shield: bool = ..., result: Literal[False]) -&gt; None\n</code></pre> <pre><code>wait(\n    *, timeout: float | None = None, shield: bool = False, result: bool = True\n) -&gt; T | None\n</code></pre> <p>Wait for a result or exception to be set (thread-safe) returning the pending if specified.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>When the timeout expires and a result or exception has not been set.</p> </li> <li> <code>PendingCancelled</code>             \u2013            <p>If <code>result=True</code> and the pending has been cancelled.</p> </li> <li> <code>Exception</code>             \u2013            <p>If <code>result=True</code> and an exception was set on the pending.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>async def wait(self, *, timeout: float | None = None, shield: bool = False, result: bool = True) -&gt; T | None:\n    \"\"\"\n    Wait for a result or exception to be set (thread-safe) returning the pending if specified.\n\n    Args:\n        timeout: Timeout in seconds.\n        shield: Shield the instance from external cancellation.\n        result: Whether the result should be returned (use `result=False` to avoid exceptions raised by [Pending.result][]).\n\n    Raises:\n        TimeoutError: When the timeout expires and a result or exception has not been set.\n        PendingCancelled: If `result=True` and the pending has been cancelled.\n        Exception: If `result=True` and an exception was set on the pending.\n    \"\"\"\n    try:\n        if not self._done or self._done_callbacks:\n            event = create_async_event()\n            self._done_callbacks.appendleft(lambda _: event.set())\n            with anyio.fail_after(timeout):\n                if not self._done or self._done_callbacks:\n                    await event\n        return self.result() if result else None\n    finally:\n        if not self._done and not shield:\n            self.cancel(\"Cancelled with waiter cancellation.\")\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait(shield)","title":"<code>shield</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shield the instance from external cancellation.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait(result)","title":"<code>result</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the result should be returned (use <code>result=False</code> to avoid exceptions raised by Pending.result).</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait_sync","title":"wait_sync","text":"<pre><code>wait_sync(*, timeout: float | None = ..., result: Literal[True] = True) -&gt; T\n</code></pre><pre><code>wait_sync(*, timeout: float | None = ..., result: Literal[False]) -&gt; None\n</code></pre> <pre><code>wait_sync(*, timeout: float | None = None, result: bool = True) -&gt; T | None\n</code></pre> <p>Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>When the timeout expires and a result or exception has not been set.</p> </li> <li> <code>PendingCancelled</code>             \u2013            <p>If <code>result=True</code> and the pending has been cancelled.</p> </li> <li> <code>Exception</code>             \u2013            <p>If <code>result=True</code> and an exception was set on the pending.</p> </li> </ul> Warning <p>Blocking the thread in which the result or exception is set will cause in deadlock.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def wait_sync(self, *, timeout: float | None = None, result: bool = True) -&gt; T | None:\n    \"\"\"\n    Wait synchronously for the a result or exception to be set (thread-safe) blocking the current thread.\n\n    Args:\n        timeout: Timeout in seconds.\n        result: Whether the result should be returned (use `result=False` to avoid exceptions raised by [Pending.result][]).\n\n    Raises:\n        TimeoutError: When the timeout expires and a result or exception has not been set.\n        PendingCancelled: If `result=True` and the pending has been cancelled.\n        Exception: If `result=True` and an exception was set on the pending.\n\n    Warning:\n        **Blocking the thread in which the result or exception is set will cause in deadlock.**\n    \"\"\"\n    if not self._done:\n        done = Event()\n        self.add_done_callback(lambda _: done.set())\n        if not self._done:\n            done.wait(timeout)\n        if not self._done:\n            msg = f\"Timeout waiting for {self}\"\n            raise TimeoutError(msg)\n\n    return self.result() if result else None\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait_sync(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.wait_sync(result)","title":"<code>result</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the result should be returned (use <code>result=False</code> to avoid exceptions raised by Pending.result).</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_result","title":"set_result","text":"<pre><code>set_result(value: T) -&gt; None\n</code></pre> <p>Set the result (thread-safe).</p> Referenced by: <ul> <li> Reference pending <code></code>\u00a0Pending <code></code>\u00a0cancel </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def set_result(self, value: T) -&gt; None:\n    \"Set the result (thread-safe).\"\n    self._set_done(\"result\", value)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_exception","title":"set_exception","text":"<pre><code>set_exception(exception: BaseException) -&gt; None\n</code></pre> <p>Set the exception (thread-safe).</p> Referenced by: <ul> <li> Reference pending <code></code>\u00a0Pending <code></code>\u00a0cancel </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def set_exception(self, exception: BaseException) -&gt; None:\n    \"Set the exception (thread-safe).\"\n    self._set_done(\"exception\", exception)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; bool\n</code></pre> <p>Cancel the instance.</p> <p>Parameters:</p> Notes <ul> <li>Cancellation cannot be undone.</li> <li>The result will not be done until either Pending.set_result or Pending.set_exception is called.</li> </ul> <p>Returns: If it has been cancelled.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; bool:\n    \"\"\"\n    Cancel the instance.\n\n    Args:\n        msg: The message to use when cancelling.\n\n    Notes:\n        - Cancellation cannot be undone.\n        - The result will not be *done* until either [Pending.set_result][] or [Pending.set_exception][] is called.\n\n    Returns: If it has been cancelled.\n    \"\"\"\n    if not self._done:\n        cancelled = getattr(self, \"_cancelled\", \"\")\n        if msg and isinstance(cancelled, str):\n            msg = f\"{cancelled}\\n{msg}\"\n        self._cancelled = msg or cancelled\n        if canceller := getattr(self, \"_canceller\", None):\n            canceller(msg)\n    return self.cancelled()\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.cancel(msg)","title":"<code>msg</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The message to use when cancelling.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Return True if the pending is cancelled.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Return True if the pending is cancelled.\"\"\"\n    return isinstance(getattr(self, \"_cancelled\", None), str)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_canceller","title":"set_canceller","text":"<pre><code>set_canceller(canceller: Callable[[str | None], Any]) -&gt; None\n</code></pre> <p>Set a callback to handle cancellation.</p> <p>Parameters:</p> Notes <ul> <li><code>set_result</code> must be called to mark the pending as completed.</li> </ul> Example <pre><code>pen = Pending()\npen.cancel()\nassert not pen.done()\npen.set_canceller(lambda msg: pen.set_result(None))\nassert pen.done()\n</code></pre> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def set_canceller(self, canceller: Callable[[str | None], Any]) -&gt; None:\n    \"\"\"\n    Set a callback to handle cancellation.\n\n    Args:\n        canceller: A callback that performs the cancellation of the pending.\n            - It must accept the cancellation message as the first argument.\n            - The cancellation call is not thread-safe.\n\n    Notes:\n        - `set_result` must be called to mark the pending as completed.\n\n    Example:\n        ```python\n        pen = Pending()\n        pen.cancel()\n        assert not pen.done()\n        pen.set_canceller(lambda msg: pen.set_result(None))\n        assert pen.done()\n        ```\n    \"\"\"\n    if self._done or hasattr(self, \"_canceller\"):\n        raise InvalidStateError\n    self._canceller = canceller\n    if self.cancelled():\n        self.cancel()\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.set_canceller(canceller)","title":"<code>canceller</code>","text":"(<code>Callable[[str | None], Any]</code>)           \u2013            <p>A callback that performs the cancellation of the pending. - It must accept the cancellation message as the first argument. - The cancellation call is not thread-safe.</p>"},{"location":"reference/pending/#async_kernel.pending.Pending.done","title":"done","text":"<pre><code>done() -&gt; bool\n</code></pre> <p>Returns True if a result or exception has been set.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Returns True if a result or exception has been set.\n    \"\"\"\n    return self._done\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.add_done_callback","title":"add_done_callback","text":"<pre><code>add_done_callback(fn: Callable[[Self], Any]) -&gt; None\n</code></pre> <p>Add a callback for when the pending is done (not thread-safe).</p> <p>If the pending is already done it will called immediately.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def add_done_callback(self, fn: Callable[[Self], Any]) -&gt; None:\n    \"\"\"\n    Add a callback for when the pending is done (not thread-safe).\n\n    If the pending is already done it will called immediately.\n    \"\"\"\n    if not self._done:\n        self._done_callbacks.append(fn)\n    else:\n        fn(self)\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.remove_done_callback","title":"remove_done_callback","text":"<pre><code>remove_done_callback(fn: Callable[[Self], object]) -&gt; int\n</code></pre> <p>Remove all instances of a callback from the callbacks list.</p> <p>Returns the number of callbacks removed.</p> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def remove_done_callback(self, fn: Callable[[Self], object], /) -&gt; int:\n    \"\"\"\n    Remove all instances of a callback from the callbacks list.\n\n    Returns the number of callbacks removed.\n    \"\"\"\n    n = 0\n    while fn in self._done_callbacks:\n        n += 1\n        self._done_callbacks.remove(fn)\n    return n\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.result","title":"result","text":"<pre><code>result() -&gt; T\n</code></pre> <p>Return the result.</p> <p>Raises:</p> <ul> <li> <code>PendingCancelled</code>             \u2013            <p>If the pending has been cancelled.</p> </li> <li> <code>InvalidStateError</code>             \u2013            <p>If the pending isn't done yet.</p> </li> </ul> Referenced by: <ul> <li> Reference pending <code></code>\u00a0Pending <ul> <li> <code></code>\u00a0wait </li> <li> <code></code>\u00a0wait_sync </li> </ul> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def result(self) -&gt; T:\n    \"\"\"\n    Return the result.\n\n    Raises:\n        PendingCancelled: If the pending has been cancelled.\n        InvalidStateError: If the pending isn't done yet.\n    \"\"\"\n    if not self._done and not self.cancelled():\n        raise InvalidStateError\n    if e := self.exception():\n        raise e\n    return self._result\n</code></pre>"},{"location":"reference/pending/#async_kernel.pending.Pending.exception","title":"exception","text":"<pre><code>exception() -&gt; BaseException | None\n</code></pre> <p>Return the exception.</p> <p>Raises:</p> <ul> <li> <code>PendingCancelled</code>             \u2013            <p>If the instance has been cancelled.</p> </li> <li> <code>InvalidStateError</code>             \u2013            <p>If the instance isn't done yet.</p> </li> </ul> Source code in <code>src/async_kernel/pending.py</code> <pre><code>def exception(self) -&gt; BaseException | None:\n    \"\"\"\n    Return the exception.\n\n    Raises:\n        PendingCancelled: If the instance has been cancelled.\n        InvalidStateError: If the instance isn't done yet.\n    \"\"\"\n    if hasattr(self, \"_cancelled\"):\n        raise PendingCancelled(self._cancelled)\n    if not self._done:\n        raise InvalidStateError\n    return getattr(self, \"_exception\", None)\n</code></pre>"},{"location":"reference/typing/","title":"typing","text":"<p>Classes:</p> <ul> <li> <code>SocketID</code>           \u2013            <p>Mapping of <code>Kernel.port_&lt;id&gt;</code> for sockets. Ref.</p> </li> <li> <code>RunMode</code>           \u2013            <p>An Enum of the run modes available for handling Messages.</p> </li> <li> <code>MsgType</code>           \u2013            <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> </li> <li> <code>MetadataKeys</code>           \u2013            <p>This is an enum of keys for metadata in kernel messages</p> </li> <li> <code>Tags</code>           \u2013            <p>Tags recognised by the kernel.</p> </li> <li> <code>MsgHeader</code>           \u2013            <p>A message header.</p> </li> <li> <code>Message</code>           \u2013            <p>A message.</p> </li> <li> <code>Job</code>           \u2013            <p>A <code>Message</code> bundle.</p> </li> <li> <code>ExecuteContent</code>           \u2013            <p>Ref.</p> </li> <li> <code>FixedCreate</code>           \u2013            <p>A TypedDict relevant to Fixed.</p> </li> <li> <code>FixedCreated</code>           \u2013            <p>A TypedDict relevant to Fixed.</p> </li> <li> <code>CallerCreateOptions</code>           \u2013            <p>Options for creating a new Caller.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>NoValue</code>           \u2013            <p>A sentinel to indicate a value has not been provided.</p> </li> <li> <code>DebugMessage</code>           \u2013            <p>A TypeAlias for a debug message.</p> </li> <li> <code>Content</code>           \u2013            <p>A TypeAlias for the content in <code>Message</code>.</p> </li> <li> <code>HandlerType</code>           \u2013            <p>A TypeAlias for the handler of message requests.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.NoValue","title":"async_kernel.typing.NoValue  <code>module-attribute</code>","text":"<pre><code>NoValue = Sentinel('NoValue')\n</code></pre> <p>A sentinel to indicate a value has not been provided.</p> Used by: <ul> <li> Reference <ul> <li> caller <code></code>\u00a0Caller <code></code>\u00a0as_completed </li> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0iopub_send </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.DebugMessage","title":"async_kernel.typing.DebugMessage  <code>module-attribute</code>","text":"<pre><code>DebugMessage = dict[str, Any]\n</code></pre> <p>A TypeAlias for a debug message.</p> Used by: <ul> <li> Reference debugger <code></code>\u00a0Debugger <ul> <li> <code></code>\u00a0do_attach </li> <li> <code></code>\u00a0do_configuration_done </li> <li> <code></code>\u00a0do_debug_info </li> <li> <code></code>\u00a0do_dump_cell </li> <li> <code></code>\u00a0do_initialize </li> <li> <code></code>\u00a0do_inspect_variables </li> <li> <code></code>\u00a0do_modules </li> <li> <code></code>\u00a0do_rich_inspect_variables </li> <li> <code></code>\u00a0do_set_breakpoints </li> <li> <code></code>\u00a0do_source </li> <li> <code></code>\u00a0do_stack_trace </li> <li> <code></code>\u00a0do_variables </li> <li> <code></code>\u00a0process_request </li> <li> <code></code>\u00a0send_dap_request </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Content","title":"async_kernel.typing.Content  <code>module-attribute</code>","text":"<pre><code>Content = dict[str, Any]\n</code></pre> <p>A TypeAlias for the content in <code>Message</code>.</p> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0comm_info_request </li> <li> <code></code>\u00a0complete_request </li> <li> <code></code>\u00a0debug_request </li> <li> <code></code>\u00a0execute_request </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0interrupt_request </li> <li> <code></code>\u00a0is_complete_request </li> <li> <code></code>\u00a0kernel_info_request </li> <li> <code></code>\u00a0shutdown_request </li> </ul> </li> <li> typing <code></code>\u00a0Message <code></code>\u00a0content </li> </ul> </li> </ul> Used by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0comm_close </li> <li> <code></code>\u00a0comm_info_request </li> <li> <code></code>\u00a0comm_msg </li> <li> <code></code>\u00a0comm_open </li> <li> <code></code>\u00a0complete_request </li> <li> <code></code>\u00a0debug_request </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0interrupt_request </li> <li> <code></code>\u00a0iopub_send </li> <li> <code></code>\u00a0is_complete_request </li> <li> <code></code>\u00a0kernel_info_request </li> <li> <code></code>\u00a0shutdown_request </li> </ul> </li> <li> typing <code></code>\u00a0HandlerType </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.HandlerType","title":"async_kernel.typing.HandlerType  <code>module-attribute</code>","text":"<pre><code>HandlerType = Callable[[Job], Awaitable[Content | None]]\n</code></pre> <p>A TypeAlias for the handler of message requests.</p> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0run_handler </li> <li> <code></code>\u00a0schedule_job </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID","title":"async_kernel.typing.SocketID","text":"<p>               Bases: <code>StrEnum</code></p> <p>Mapping of <code>Kernel.port_&lt;id&gt;</code> for sockets. Ref.</p> Returned by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0all_concurrency_run_modes </li> </ul> <p>Attributes:</p> <ul> <li> <code>heartbeat</code>           \u2013            </li> <li> <code>shell</code>           \u2013            </li> <li> <code>stdin</code>           \u2013            </li> <li> <code>control</code>           \u2013            </li> <li> <code>iopub</code>           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID.heartbeat","title":"heartbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>heartbeat = 'hb'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = 'shell'\n</code></pre> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0callers </li> <li> typing <code></code>\u00a0Job <code></code>\u00a0socket_id </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0receive_msg_loop </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID.stdin","title":"stdin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stdin = 'stdin'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.control","title":"control  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>control = 'control'\n</code></pre> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0callers </li> <li> typing <code></code>\u00a0Job <code></code>\u00a0socket_id </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0receive_msg_loop </li> </ul> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID.iopub","title":"iopub  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub = 'iopub'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.RunMode","title":"async_kernel.typing.RunMode","text":"<p>               Bases: <code>StrEnum</code></p> <p>An Enum of the run modes available for handling Messages.</p> <p>receive_msg_loop uses get_run_mode to map the message type and channel (<code>shell</code> or <code>control</code>) to the <code>RunMode</code>.</p> Cell overrides <p>The user can also specify an execution mode in execute requests.</p> <p>Top line comment:     <pre><code>##task\n</code></pre> Tag:     see: async_kernel.typing.MetadataKeys.</p> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> </ul> </li> <li> typing <code></code>\u00a0RunMode <code></code>\u00a0get_mode </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0schedule_job </li> </ul> <p>Methods:</p> <ul> <li> <code>get_mode</code>             \u2013              <p>Get a RunMode from the code if it is found.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>queue</code>           \u2013            <p>Run the message handler using async_kernel.Caller.queue_call.</p> </li> <li> <code>task</code>           \u2013            <p>Run the message handler using async_kernel.Caller.call_soon.</p> </li> <li> <code>thread</code>           \u2013            <p>Run the message handler using async_kernel.Caller.to_thread to start use a 'worker'.</p> </li> <li> <code>direct</code>           \u2013            <p>Run the message handler using async_kernel.Caller.call_direct.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.RunMode.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue = 'queue'\n</code></pre> <p>Run the message handler using async_kernel.Caller.queue_call.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task = 'task'\n</code></pre> <p>Run the message handler using async_kernel.Caller.call_soon.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.thread","title":"thread  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>thread = 'thread'\n</code></pre> <p>Run the message handler using async_kernel.Caller.to_thread to start use a 'worker'.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.direct","title":"direct  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direct = 'direct'\n</code></pre> <p>Run the message handler using async_kernel.Caller.call_direct.</p> Warning <ul> <li>This mode runs directly in the caller scheduler as soon as it is received.</li> <li>Use this only for fast running high priority code.</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.RunMode.get_mode","title":"get_mode  <code>classmethod</code>","text":"<pre><code>get_mode(code: str) -&gt; RunMode | None\n</code></pre> <p>Get a RunMode from the code if it is found.</p> Source code in <code>src/async_kernel/typing.py</code> <pre><code>@classmethod\ndef get_mode(cls, code: str) -&gt; RunMode | None:\n    \"Get a RunMode from the code if it is found.\"\n    try:\n        if (code := code.strip().split(\"\\n\")[0].strip()).startswith(\"##\"):\n            return RunMode(code.removeprefix(\"##\"))\n        if code.startswith(\"RunMode.\"):\n            return RunMode(code.removeprefix(\"RunMode.\"))\n    except ValueError:\n        return None\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgType","title":"async_kernel.typing.MsgType","text":"<p>               Bases: <code>StrEnum</code></p> <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> <p>Some message types are on the control channel only.</p> Referenced by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0run_handler </li> </ul> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0all_concurrency_run_modes </li> <li> typing <code></code>\u00a0MsgHeader <code></code>\u00a0msg_type </li> </ul> </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0all_concurrency_run_modes </li> <li> <code></code>\u00a0get_run_mode </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>kernel_info_request</code>           \u2013            <p>async_kernel.Kernel.kernel_info_request</p> </li> <li> <code>comm_info_request</code>           \u2013            <p>async_kernel.Kernel.comm_info_request</p> </li> <li> <code>execute_request</code>           \u2013            <p>async_kernel.Kernel.execute_request</p> </li> <li> <code>complete_request</code>           \u2013            <p>async_kernel.Kernel.complete_request</p> </li> <li> <code>is_complete_request</code>           \u2013            <p>async_kernel.Kernel.is_complete_request</p> </li> <li> <code>inspect_request</code>           \u2013            <p>async_kernel.Kernel.inspect_request</p> </li> <li> <code>history_request</code>           \u2013            <p>async_kernel.Kernel.history_request</p> </li> <li> <code>comm_open</code>           \u2013            <p>async_kernel.Kernel.comm_open</p> </li> <li> <code>comm_msg</code>           \u2013            <p>async_kernel.Kernel.comm_msg</p> </li> <li> <code>comm_close</code>           \u2013            <p>async_kernel.Kernel.comm_close</p> </li> <li> <code>interrupt_request</code>           \u2013            <p>async_kernel.Kernel.interrupt_request (control channel only)</p> </li> <li> <code>shutdown_request</code>           \u2013            <p>async_kernel.Kernel.shutdown_request (control channel only)</p> </li> <li> <code>debug_request</code>           \u2013            <p>async_kernel.Kernel.debug_request (control channel only)</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgType.kernel_info_request","title":"kernel_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_info_request = 'kernel_info_request'\n</code></pre> <p>async_kernel.Kernel.kernel_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_info_request","title":"comm_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_info_request = 'comm_info_request'\n</code></pre> <p>async_kernel.Kernel.comm_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.execute_request","title":"execute_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request = 'execute_request'\n</code></pre> <p>async_kernel.Kernel.execute_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.complete_request","title":"complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>complete_request = 'complete_request'\n</code></pre> <p>async_kernel.Kernel.complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.is_complete_request","title":"is_complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_complete_request = 'is_complete_request'\n</code></pre> <p>async_kernel.Kernel.is_complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.inspect_request","title":"inspect_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_request = 'inspect_request'\n</code></pre> <p>async_kernel.Kernel.inspect_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.history_request","title":"history_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_request = 'history_request'\n</code></pre> <p>async_kernel.Kernel.history_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_open","title":"comm_open  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_open = 'comm_open'\n</code></pre> <p>async_kernel.Kernel.comm_open</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_msg","title":"comm_msg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_msg = 'comm_msg'\n</code></pre> <p>async_kernel.Kernel.comm_msg</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_close","title":"comm_close  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_close = 'comm_close'\n</code></pre> <p>async_kernel.Kernel.comm_close</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.interrupt_request","title":"interrupt_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupt_request = 'interrupt_request'\n</code></pre> <p>async_kernel.Kernel.interrupt_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.shutdown_request","title":"shutdown_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shutdown_request = 'shutdown_request'\n</code></pre> <p>async_kernel.Kernel.shutdown_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.debug_request","title":"debug_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_request = 'debug_request'\n</code></pre> <p>async_kernel.Kernel.debug_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys","title":"async_kernel.typing.MetadataKeys","text":"<p>               Bases: <code>StrEnum</code></p> <p>This is an enum of keys for metadata in kernel messages that are used in async_kernel.</p> Notes <p>Metadata can be edited in Jupyter lab \"Advanced tools\" and Tags can be added using \"common tools\" in the right side bar.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0RunMode </li> </ul> Returned by: <ul> <li> Reference typing <code></code>\u00a0Message <code></code>\u00a0metadata </li> </ul> <p>Attributes:</p> <ul> <li> <code>tags</code>           \u2013            <p>The <code>tags</code> metadata key corresponds to is a list of strings. </p> </li> <li> <code>timeout</code>           \u2013            <p>The <code>timeout</code> metadata key is used to specify a timeout for execution of the code.</p> </li> <li> <code>suppress_error_message</code>           \u2013            <p>A message to print when the error has been suppressed using async_kernel.typing.Tags.suppress_error. </p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags = 'tags'\n</code></pre> <p>The <code>tags</code> metadata key corresponds to is a list of strings. </p> <p>The list can be edited by the user in a notebook. see also: Tags.</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout = 'timeout'\n</code></pre> <p>The <code>timeout</code> metadata key is used to specify a timeout for execution of the code.</p> <p>The value should be a floating point value of the timeout in seconds.</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.suppress_error_message","title":"suppress_error_message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error_message = 'suppress-error-message'\n</code></pre> <p>A message to print when the error has been suppressed using async_kernel.typing.Tags.suppress_error. </p> Notes <ul> <li>The default message is '\u26a0'.</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Tags","title":"async_kernel.typing.Tags","text":"<p>               Bases: <code>StrEnum</code></p> <p>Tags recognised by the kernel.</p> Info <p>Tags are can be added per cell.</p> <ul> <li>Jupyter: via the right side bar.</li> <li>VScode: via Jupyter variables explorer</li> </ul> Referenced by: <ul> <li> Reference typing <code></code>\u00a0MetadataKeys <code></code>\u00a0tags </li> </ul> <p>Attributes:</p> <ul> <li> <code>suppress_error</code>           \u2013            <p>Suppress exceptions that occur during execution of the code cell.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Tags.suppress_error","title":"suppress_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error = 'suppress-error'\n</code></pre> <p>Suppress exceptions that occur during execution of the code cell.</p> Warning <p>The code block will return as 'ok' and there will be no message recorded.</p> Referenced by: <ul> <li> About Contributing Development Notebooks </li> <li> Reference typing <code></code>\u00a0MetadataKeys <code></code>\u00a0suppress_error_message </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader","title":"async_kernel.typing.MsgHeader","text":"<p>               Bases: <code>TypedDict</code></p> <p>A message header.</p> Returned by: <ul> <li> Reference typing <code></code>\u00a0Message <ul> <li> <code></code>\u00a0header </li> <li> <code></code>\u00a0parent_header </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>msg_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>session</code>               (<code>str</code>)           \u2013            </li> <li> <code>username</code>               (<code>str</code>)           \u2013            </li> <li> <code>date</code>               (<code>str</code>)           \u2013            </li> <li> <code>msg_type</code>               (<code>MsgType</code>)           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_id","title":"msg_id  <code>instance-attribute</code>","text":"<pre><code>msg_id: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_type","title":"msg_type  <code>instance-attribute</code>","text":"<pre><code>msg_type: MsgType\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Message","title":"async_kernel.typing.Message","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[T]</code></p> <p>A message.</p> Referenced by: <ul> <li> Reference typing <ul> <li> <code></code>\u00a0RunMode </li> <li> <code></code>\u00a0typing </li> </ul> </li> </ul> Returned by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <code></code>\u00a0get_parent </li> <li> typing <code></code>\u00a0Job <code></code>\u00a0msg </li> <li> utils <code></code>\u00a0get_parent </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> <li> <code>parent_header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> <li> <code>metadata</code>               (<code>Mapping[MetadataKeys | str, Any]</code>)           \u2013            <p>ref</p> </li> <li> <code>content</code>               (<code>T | Content</code>)           \u2013            <p>ref</p> </li> <li> <code>buffers</code>               (<code>list[bytearray | bytes]</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.header","title":"header  <code>instance-attribute</code>","text":"<pre><code>header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.parent_header","title":"parent_header  <code>instance-attribute</code>","text":"<pre><code>parent_header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: Mapping[MetadataKeys | str, Any]\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: T | Content\n</code></pre> <p>ref</p> See also <ul> <li>ExecuteContent</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.buffers","title":"buffers  <code>instance-attribute</code>","text":"<pre><code>buffers: list[bytearray | bytes]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job","title":"async_kernel.typing.Job","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[T]</code></p> <p>A <code>Message</code> bundle.</p> Returned by: <ul> <li> Reference utils <code></code>\u00a0get_job </li> </ul> Used by: <ul> <li> Reference <ul> <li> kernel <code></code>\u00a0Kernel <ul> <li> <code></code>\u00a0comm_close </li> <li> <code></code>\u00a0comm_info_request </li> <li> <code></code>\u00a0comm_msg </li> <li> <code></code>\u00a0comm_open </li> <li> <code></code>\u00a0complete_request </li> <li> <code></code>\u00a0debug_request </li> <li> <code></code>\u00a0execute_request </li> <li> <code></code>\u00a0get_run_mode </li> <li> <code></code>\u00a0history_request </li> <li> <code></code>\u00a0inspect_request </li> <li> <code></code>\u00a0interrupt_request </li> <li> <code></code>\u00a0is_complete_request </li> <li> <code></code>\u00a0kernel_info_request </li> <li> <code></code>\u00a0run_handler </li> <li> <code></code>\u00a0schedule_job </li> <li> <code></code>\u00a0shutdown_request </li> </ul> </li> <li> typing <code></code>\u00a0HandlerType </li> <li> utils <ul> <li> <code></code>\u00a0get_execute_request_timeout </li> <li> <code></code>\u00a0get_metadata </li> <li> <code></code>\u00a0get_parent </li> <li> <code></code>\u00a0get_tags </li> </ul> </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>msg</code>               (<code>Message[T]</code>)           \u2013            <p>The message received over the socket.</p> </li> <li> <code>socket_id</code>               (<code>Literal[control, shell]</code>)           \u2013            <p>The channel over which the socket was received.</p> </li> <li> <code>socket</code>               (<code>Socket</code>)           \u2013            <p>The actual socket.</p> </li> <li> <code>ident</code>               (<code>bytes | list[bytes]</code>)           \u2013            <p>The ident associated with the message and its origin.</p> </li> <li> <code>received_time</code>               (<code>float</code>)           \u2013            <p>The time the message was received.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Job.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: Message[T]\n</code></pre> <p>The message received over the socket.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.socket_id","title":"socket_id  <code>instance-attribute</code>","text":"<pre><code>socket_id: Literal[control, shell]\n</code></pre> <p>The channel over which the socket was received.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.socket","title":"socket  <code>instance-attribute</code>","text":"<pre><code>socket: Socket\n</code></pre> <p>The actual socket.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.ident","title":"ident  <code>instance-attribute</code>","text":"<pre><code>ident: bytes | list[bytes]\n</code></pre> <p>The ident associated with the message and its origin.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.received_time","title":"received_time  <code>instance-attribute</code>","text":"<pre><code>received_time: float\n</code></pre> <p>The time the message was received.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent","title":"async_kernel.typing.ExecuteContent","text":"<p>               Bases: <code>TypedDict</code></p> <p>Ref.</p> Referenced by: <ul> <li> Reference typing <code></code>\u00a0Message <code></code>\u00a0content </li> </ul> Used by: <ul> <li> Reference kernel <code></code>\u00a0Kernel <code></code>\u00a0execute_request </li> </ul> <p>Attributes:</p> <ul> <li> <code>code</code>               (<code>str</code>)           \u2013            <p>The code to execute.</p> </li> <li> <code>silent</code>               (<code>bool</code>)           \u2013            </li> <li> <code>store_history</code>               (<code>bool</code>)           \u2013            </li> <li> <code>user_expressions</code>               (<code>dict[str, str]</code>)           \u2013            </li> <li> <code>allow_stdin</code>               (<code>bool</code>)           \u2013            </li> <li> <code>stop_on_error</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>The code to execute.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.silent","title":"silent  <code>instance-attribute</code>","text":"<pre><code>silent: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.store_history","title":"store_history  <code>instance-attribute</code>","text":"<pre><code>store_history: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.user_expressions","title":"user_expressions  <code>instance-attribute</code>","text":"<pre><code>user_expressions: dict[str, str]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.allow_stdin","title":"allow_stdin  <code>instance-attribute</code>","text":"<pre><code>allow_stdin: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.stop_on_error","title":"stop_on_error  <code>instance-attribute</code>","text":"<pre><code>stop_on_error: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.FixedCreate","title":"async_kernel.typing.FixedCreate","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[S]</code></p> <p>A TypedDict relevant to Fixed.</p> Used by: <ul> <li> Reference common <code></code>\u00a0Fixed </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.FixedCreated","title":"async_kernel.typing.FixedCreated","text":"<p>               Bases: <code>TypedDict</code>, <code>Generic[S, T]</code></p> <p>A TypedDict relevant to Fixed.</p> Used by: <ul> <li> Reference common <code></code>\u00a0Fixed </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions","title":"async_kernel.typing.CallerCreateOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options for creating a new Caller.</p> Used by: <ul> <li> Reference caller <code></code>\u00a0Caller <ul> <li> <code></code>\u00a0__new__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0to_thread_advanced </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>NotRequired[str | None]</code>)           \u2013            <p>The name to use for the caller.</p> </li> <li> <code>thread</code>               (<code>NotRequired[Thread | None]</code>)           \u2013            <p>The thread of the caller. (current thread)</p> </li> <li> <code>log</code>               (<code>NotRequired[LoggerAdapter]</code>)           \u2013            <p>A logging adapter to use to log exceptions.</p> </li> <li> <code>backend</code>               (<code>NotRequired[Backend | Literal['trio', 'asyncio']]</code>)           \u2013            <p>The anyio backend to use (1. Inherited. 2. current_async_library 3. From  async_kernel.kernel.Kernel.anyio_backend).</p> </li> <li> <code>backend_options</code>               (<code>NotRequired[dict | None]</code>)           \u2013            <p>Options to use when calling anyio.run inside the new thread (1. Inherited. 2. From async_kernel.kernel.Kernel.anyio_backend_options).</p> </li> <li> <code>protected</code>               (<code>NotRequired[bool]</code>)           \u2013            <p>The caller should be protected against accidental closure (False).</p> </li> <li> <code>zmq_context</code>               (<code>NotRequired[Context[Any]]</code>)           \u2013            <p>A zmq Context to use</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>The name to use for the caller.</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.thread","title":"thread  <code>instance-attribute</code>","text":"<pre><code>thread: NotRequired[Thread | None]\n</code></pre> <p>The thread of the caller. (current thread)</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: NotRequired[LoggerAdapter]\n</code></pre> <p>A logging adapter to use to log exceptions.</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend: NotRequired[Backend | Literal['trio', 'asyncio']]\n</code></pre> <p>The anyio backend to use (1. Inherited. 2. current_async_library 3. From  async_kernel.kernel.Kernel.anyio_backend).</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.backend_options","title":"backend_options  <code>instance-attribute</code>","text":"<pre><code>backend_options: NotRequired[dict | None]\n</code></pre> <p>Options to use when calling anyio.run inside the new thread (1. Inherited. 2. From async_kernel.kernel.Kernel.anyio_backend_options).</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.protected","title":"protected  <code>instance-attribute</code>","text":"<pre><code>protected: NotRequired[bool]\n</code></pre> <p>The caller should be protected against accidental closure (False).</p>"},{"location":"reference/typing/#async_kernel.typing.CallerCreateOptions.zmq_context","title":"zmq_context  <code>instance-attribute</code>","text":"<pre><code>zmq_context: NotRequired[Context[Any]]\n</code></pre> <p>A zmq Context to use</p>"},{"location":"reference/utils/","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>mark_thread_pydev_do_not_trace</code>             \u2013              <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> </li> <li> <code>get_job</code>             \u2013              <p>Get the job for the current context.</p> </li> <li> <code>get_parent</code>             \u2013              <p>Get the parent message for the current context.</p> </li> <li> <code>get_metadata</code>             \u2013              <p>Gets metadata for the current context.</p> </li> <li> <code>get_tags</code>             \u2013              <p>Gets the tags for the current context.</p> </li> <li> <code>get_execute_request_timeout</code>             \u2013              <p>Gets the execute_request_timeout for the current context.</p> </li> <li> <code>get_execution_count</code>             \u2013              <p>Gets the execution count for the current context, defaults to the current kernel count.</p> </li> <li> <code>setattr_nested</code>             \u2013              <p>Set a nested attribute of an object.</p> </li> </ul>"},{"location":"reference/utils/#async_kernel.utils.mark_thread_pydev_do_not_trace","title":"async_kernel.utils.mark_thread_pydev_do_not_trace","text":"<pre><code>mark_thread_pydev_do_not_trace(thread: Thread | None = None, *, remove=False) -&gt; None\n</code></pre> <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def mark_thread_pydev_do_not_trace(thread: threading.Thread | None = None, *, remove=False) -&gt; None:\n    \"\"\"Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).\"\"\"\n    thread = thread or threading.current_thread()\n    thread.pydev_do_not_trace = not remove  # pyright: ignore[reportAttributeAccessIssue]\n    thread.is_pydev_daemon_thread = not remove  # pyright: ignore[reportAttributeAccessIssue]\n    return\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_job","title":"async_kernel.utils.get_job","text":"<pre><code>get_job() -&gt; Job[dict] | dict\n</code></pre> <p>Get the job for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_job() -&gt; Job[dict] | dict:\n    \"Get the job for the current context.\"\n    try:\n        return _job_var.get()\n    except Exception:\n        return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_parent","title":"async_kernel.utils.get_parent","text":"<pre><code>get_parent(job: Job | None = None) -&gt; Message[dict[str, Any]] | None\n</code></pre> <p>Get the parent message for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_parent(job: Job | None = None, /) -&gt; Message[dict[str, Any]] | None:\n    \"Get the [parent message]() for the current context.\"\n    return (job or get_job()).get(\"msg\")\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_metadata","title":"async_kernel.utils.get_metadata","text":"<pre><code>get_metadata(job: Job | None = None) -&gt; Mapping[str, Any]\n</code></pre> <p>Gets metadata for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_metadata(job: Job | None = None, /) -&gt; Mapping[str, Any]:\n    \"Gets [metadata]() for the current context.\"\n    return (job or get_job()).get(\"msg\", {}).get(\"metadata\", {})\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_tags","title":"async_kernel.utils.get_tags","text":"<pre><code>get_tags(job: Job | None = None) -&gt; list[str]\n</code></pre> <p>Gets the tags for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_tags(job: Job | None = None, /) -&gt; list[str]:\n    \"Gets the [tags]() for the current context.\"\n    return get_metadata(job).get(\"tags\", [])\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execute_request_timeout","title":"async_kernel.utils.get_execute_request_timeout","text":"<pre><code>get_execute_request_timeout(job: Job | None = None) -&gt; float | None\n</code></pre> <p>Gets the execute_request_timeout for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execute_request_timeout(job: Job | None = None, /) -&gt; float | None:\n    \"Gets the execute_request_timeout for the current context.\"\n    try:\n        if timeout := get_metadata(job).get(MetadataKeys.timeout):\n            return float(timeout)\n        return get_kernel().shell.execute_request_timeout\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execution_count","title":"async_kernel.utils.get_execution_count","text":"<pre><code>get_execution_count() -&gt; int\n</code></pre> <p>Gets the execution count for the current context, defaults to the current kernel count.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execution_count() -&gt; int:\n    \"Gets the execution count for the current context, defaults to the current kernel count.\"\n\n    return _execution_count_var.get(None) or async_kernel.Kernel()._execution_count  # pyright: ignore[reportPrivateUsage]\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested","title":"async_kernel.utils.setattr_nested","text":"<pre><code>setattr_nested(obj: object, name: str, value: str | Any) -&gt; dict[str, Any]\n</code></pre> <p>Set a nested attribute of an object.</p> <p>If the attribute name contains dots, it is interpreted as a nested attribute. For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.</p> <p>This is primarily intended for use with command.command_line to set the nesteded attributes on on kernels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The mapping of the name to the set value if the value has been set.</p> </li> <li> <code>dict[str, Any]</code>           \u2013            <p>An empty dict indicates the value was not set.</p> </li> </ul> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def setattr_nested(obj: object, name: str, value: str | Any) -&gt; dict[str, Any]:\n    \"\"\"\n    Set a nested attribute of an object.\n\n    If the attribute name contains dots, it is interpreted as a nested attribute.\n    For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.\n\n    This is primarily intended for use with [command.command_line][]\n    to set the nesteded attributes on on kernels.\n\n    Args:\n        obj: The object to set the attribute on.\n        name: The name of the attribute to set.\n        value: The value to set the attribute to.\n\n    Returns:\n        The mapping of the name to the set value if the value has been set.\n        An empty dict indicates the value was not set.\n\n    \"\"\"\n    if len(bits := name.split(\".\")) &gt; 1:\n        try:\n            obj = getattr(obj, bits[0])\n        except Exception:\n            return {}\n        setattr_nested(obj, \".\".join(bits[1:]), value)\n    if (isinstance(obj, traitlets.HasTraits) and obj.has_trait(name)) or hasattr(obj, name):\n        try:\n            setattr(obj, name, value)\n        except Exception:\n            setattr(obj, name, eval(value))\n        return {name: getattr(obj, name)}\n    return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(obj)","title":"<code>obj</code>","text":"(<code>object</code>)           \u2013            <p>The object to set the attribute on.</p>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The name of the attribute to set.</p>"},{"location":"reference/utils/#async_kernel.utils.setattr_nested(value)","title":"<code>value</code>","text":"(<code>str | Any</code>)           \u2013            <p>The value to set the attribute to.</p>"},{"location":"usage/","title":"Usage","text":"<p>Async kernel provides a Jupyter kernel that can be used in:</p> <ul> <li>Jupyter</li> <li>VS code</li> <li>Other places that can us a python kernel without a gui event loop</li> </ul> <p>Normal Execute requests are queued for execution and will be run sequentially. Awaiting in cells is fully supported and will not block shell messaging.</p> <p>Please refer to the notebooks which demonstrate some usage examples.</p>"},{"location":"usage/#blocking-code","title":"Blocking code","text":"<p>Blocking code should be run in outside the shell thread using one of the following:</p> <ol> <li>anyio</li> <li>async_kernel.Caller.to_thread</li> <li>Using the backend's library<ul> <li>asyncio.to_thread</li> <li>trio.to_thread.run_sync</li> </ul> </li> </ol>"},{"location":"usage/#caller","title":"Caller","text":"<p>Caller was originally developed to simplify message handling the the Kernel. It is now a capable tool with a convenient interface for executing synchronous and asynchronous code in a given thread's event loop.</p> <p>It has a few unique features worth mentioning:</p> <ul> <li>async_kernel.Caller.get<ul> <li>Retrieves existing or creates a caller instance according the 'thread' or 'name'.</li> <li>Is both a classmethod and <code>method</code> depending of if it is called on the 'Class' or 'instance'.</li> </ul> </li> <li>async_kernel.Caller.to_thread<ul> <li>runs an event loop matching the backend of the originator.</li> <li>maintains a pool of worker threads per caller, which in turn can have its own pool of workers.</li> </ul> </li> <li>async_kernel.Caller.queue_call<ul> <li>A dedicated queue is created specific to the hash of the function.</li> <li>Only one call will run at a time.</li> <li>The context of the original call is retained until the queue is stopped with async_kernel.caller.Caller.queue_close.</li> </ul> </li> </ul> <p>There is caller instance exists per thread (assuming there is only one event-loop-per-thread).</p>"},{"location":"usage/#callerget","title":"<code>Caller.get</code>","text":"<p>Caller.get is the primary method to obtain a running kernel.</p> <p>When using <code>get</code> via a caller instance rather than as a class method, any newly created instances are considered children and will be stopped if the caller is stopped.</p> To get a caller from inside an event loop useNew thread specify the backend <pre><code>caller = Caller.get()\n</code></pre> <pre><code>asyncio_caller = Caller.get(name=\"asyncio backend\", backend=\"asyncio\")\ntrio_caller = asyncio_caller.get(name=\"trio backend\", backend=\"trio\")\nassert trio_caller in asyncio_caller.children\n\nasyncio_caller.stop()\nawait asyncio_caller.stopped\nassert trio_caller.stopped\n</code></pre>"}]}