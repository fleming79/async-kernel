{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Async kernel","text":"<p>Async kernel is a Python Jupyter kernel that runs in an anyio event loop.</p> <p>Documentation</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Concurrent message handling</li> <li>Debugger client</li> <li>Configurable backend<ul> <li>Asyncio (default)<ul> <li>uvloop enabled by default</li> </ul> </li> <li>trio backend</li> </ul> </li> <li>IPython shell provides:<ul> <li>code execution</li> <li>magic</li> <li>code completions</li> <li>history</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install async-kernel\n</code></pre>"},{"location":"#trio","title":"Trio","text":"<p>To add a kernel spec for <code>trio</code>.</p> <pre><code>pip install trio\n</code></pre> <pre><code>async-kernel -a async-trio\n</code></pre>"},{"location":"#origin","title":"Origin","text":"<p>Async kernel started as a fork of IPyKernel. Thank you to the original contributors of IPyKernel that made Async kernel possible.</p>"},{"location":"caller/","title":"Caller","text":"<p>To get the caller for the main thread.</p> <p>Ensure you're running an async kernel.</p> In\u00a0[1]: Copied! <pre>%callers\n</pre> %callers <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> In\u00a0[2]: do-not-publish-error Copied! <pre>import random\nimport time\n\nimport ipywidgets as ipw\n\nfrom async_kernel import Caller\n\noutputs = {}\n\n\ndef my_func(n):\n    caller = Caller()\n    if not (out := outputs.get(caller)):\n        outputs[caller] = out = ipw.HTML(description=str(caller))\n        out.style.description_width = \"220px\"\n        display(out)\n    sleep_time = random.random() / 4\n    out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"\n    time.sleep(sleep_time)\n    return n\n\n\nasync def run_forever():\n    n = 0\n    while True:\n        n += 1\n        yield Caller.to_thread(my_func, n)\n\n\nasync for fut in Caller.as_completed(run_forever()):\n    result = await fut\n    print(f\"Finished: {result}\", end=\"\\r\")\n</pre> import random import time  import ipywidgets as ipw  from async_kernel import Caller  outputs = {}   def my_func(n):     caller = Caller()     if not (out := outputs.get(caller)):         outputs[caller] = out = ipw.HTML(description=str(caller))         out.style.description_width = \"220px\"         display(out)     sleep_time = random.random() / 4     out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"     time.sleep(sleep_time)     return n   async def run_forever():     n = 0     while True:         n += 1         yield Caller.to_thread(my_func, n)   async for fut in Caller.as_completed(run_forever()):     result = await fut     print(f\"Finished: {result}\", end=\"\\r\") <pre>HTML(value='', description='Caller&lt;Thread-3 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-4 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-5 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-6 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-7 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-9 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-8 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-10 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-11 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-12 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre></pre> In\u00a0[3]: Copied! <pre>%callers\n</pre> %callers <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-3 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-4 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-5 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-6 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-7 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-8 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-9 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-10 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-11 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-12 (anyio_run_caller)\t</pre> <pre>\n</pre>"},{"location":"caller/#caller","title":"Caller\u00b6","text":"<p><code>Caller</code> is a class that makes it easy to call code in different threads/tasks.</p> <p>One caller instance is created per thread, and each of those instances can be retrieved by name using the <code>Caller.get_instance</code> class method or in the thread in which it is running simply by <code>Caller()</code>.</p> <p><code>Caller</code> is used by the kernel internally for running code, but can also be used directly by the user. Each caller starts its own iopub zmq socket.</p>"},{"location":"caller/#threads","title":"Threads\u00b6","text":"<p>The caller manages a pool of worker threads (not related to anyio worker threads) or you can specify the name of a new thread which you can manage yourself. Each thread has its own anyio event loop in which the code will be called.</p> <p>Most methods that perform execution return an <code>async_kernel.Future</code>.</p>"},{"location":"caller/#usage-by-the-kernel","title":"Usage by the kernel\u00b6","text":"<p>The Kernel runs two threads; one each for the shell and control. The thread names are 'MainThread' and 'ControlThread' respectively. You can easily get the main thread caller by using the classmethod <code>Caller.get_instance()</code>.</p> <p>Kernel uses one of <code>Caller().call_soon</code> <code>Caller.to_thread</code> depending on the header directive</p>"},{"location":"caller/#caller-of-the-current-thread","title":"Caller of the current thread\u00b6","text":"<p>To get the caller for the current thread use Caller(). It will raise a Runtime error if the thread doesn't have a running instance.</p>"},{"location":"caller/#example","title":"Example\u00b6","text":"<p>This example requires ipywidgets!</p>"},{"location":"commands/","title":"Command line","text":"<p><code>async-kernel</code> (and alias <code>async_kernel</code>) is provided as a system executable.</p> <p>Options:</p> <ul> <li>Start a kernel</li> <li>Add kernel spec</li> <li>Remove</li> </ul>"},{"location":"commands/#add-a-kernel-spec","title":"Add a kernel spec","text":"<p>Use the argument <code>-a</code> followed by the kernel name to add a new kernel spec. Include 'trio' in the kernel name to use a 'trio' backend. Any valid kernel name is allowed. Do not include whitespace in the kernel name.</p> <p>Recommended kernel names are:</p> <ul> <li>'async': Default kernel that is installed that provides a the default 'asyncio' backend.</li> <li>'async-trio': A trio backend. Note: trio must be installed separately.</li> </ul> <p>Add a trio kernel spec.</p> <pre><code>async-kernel -a async-trio\n</code></pre> <p>Note</p> <p>To modify how the kernel start see the section on starting a kernel for configuration options.</p>"},{"location":"commands/#configuration","title":"Configuration","text":"<p>Additional configuration of the kernel spec is supported by passing the each parameter prefixed with '--' followed by the value.</p> <p>The parameters are first used with creating the kernel spec.</p>"},{"location":"commands/#remove-a-kernel-spec","title":"Remove a kernel spec","text":"<p>You can remove any kernel spec that is listed. Call <code>async-kernel</code> with no arguments to see a list of the installed kernels.</p> <pre><code>async-kernel\n</code></pre> <p>If you added the custom kernel spec above, you can remove it with:</p> <pre><code>async-kernel -r async-trio-custom\n</code></pre>"},{"location":"commands/#start-a-kernel","title":"Start a kernel","text":"<p>To start a kernel from the command prompt, use the argument <code>-f</code>.</p> <p>This will start the default kernel (async).</p> <pre><code>async-kernel -f .\n</code></pre> <p>Additional settings can be passed as arguments.</p> <pre><code>async-kernel -f . --kernel_name async-trio-custom --display_name 'My custom kernel' --quiet False\n</code></pre> <p>The call above will start a new kernel with a 'trio' backend. The quiet setting is a parameter that gets set on kernel. Parameters of this type are converted using [eval] prior to setting.</p> <p>For further detail, see the API for the command line handler command_line.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>This project is under active development. Feel free to create an issue to provide feedback.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>uv is used for development. By default it will install all relevant versions of the required packages when it is synchronised.</p>"},{"location":"contributing/#installation-from-source","title":"Installation from source","text":"<p>If you are working on a pull request, [make a fork] of the project and install from your fork.</p> <pre><code>git clone &lt;repository&gt;\ncd async-kernel\nuv venv -p python@311 # or whichever environment you are targeting.\nuv sync\n# Activate the environment\n</code></pre>"},{"location":"contributing/#update-packages","title":"Update packages","text":"<pre><code>uv lock --upgrade\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"contributing/#running-tests-with-coverage","title":"Running tests with coverage","text":"<p>We are aiming for 100% code coverage on CI (Linux). Any new code should also update tests to maintain coverage.</p> <pre><code>uv run pytest -vv --cov\n</code></pre> <p>Note</p> <p>We are only targeting 100% on linux for &gt;= 3.12 for the following reasons:</p> <ol> <li><code>transport</code> type <code>ipc</code> is only supported linux which has special handling.</li> <li>Coverage on Python 3.11 doesn't correctly gather data for subprocesses giving invalid coverage reports.</li> </ol> <p></p>"},{"location":"contributing/#code-styling","title":"Code Styling","text":"<p><code>Async kernel</code> uses ruff for code formatting. The pre-commit hook should take care of how it should look.</p> <p>To install <code>pre-commit</code> to run prior commits with the following:</p> <pre><code>pre-commit install\n</code></pre> <p>If you prefer not to install the hook, you can invoke the pre-commit hook by hand at any time with:</p> <pre><code>pre-commit run # append -a to run against all files.\n</code></pre>"},{"location":"contributing/#type-checking","title":"Type checking","text":"<p>Type checking is performed using basedpyright.</p> <pre><code>basedpyright\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is provided my Material for MkDocs . To start up a server for editing locally:</p>"},{"location":"contributing/#install","title":"Install","text":"<pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --shell.execute_request_timeout 0.1\n</code></pre>"},{"location":"contributing/#serve-locally","title":"Serve locally","text":"<pre><code>mkdocs serve \n</code></pre>"},{"location":"contributing/#api-docstrings","title":"API / Docstrings","text":"<p>API documentation is included using mkdocstrings.</p> <p>Docstrings are written in docstring format google-notypes. Typing information is included automatically by griff.</p>"},{"location":"contributing/#see-also","title":"See also","text":"<ul> <li>cross-referencing</li> </ul>"},{"location":"contributing/#notebooks","title":"Notebooks","text":"<p>Notebooks are included in the documentation with the plugin mkdocs-jupyter.</p>"},{"location":"contributing/#useful-links","title":"Useful links","text":"<p>These links are not relevant for docstrings.</p> <ul> <li>footnotes</li> <li>tooltips</li> </ul>"},{"location":"contributing/#deploy-manually","title":"Deploy manually","text":"<pre><code>mkdocs gh-deploy --force\n</code></pre>"},{"location":"contributing/#releasing-async-kernel","title":"Releasing Async kernel","text":"<p>To start a new release manually trigger the Github action new_release.yml.</p> <p>The action does the following:</p> <ol> <li>Creates a new branch using the version number.</li> <li>Updates the changelog for the new version using git-cliff.</li> <li>Commits the revised changelog.</li> <li>Adds a tag against the commit with the version.</li> <li>Starts a new PR assigning the actor who triggered the workflow.</li> </ol> <p>Once the new PR is available merge the PR into the main branch. Normally this will also trigger publication of the new release.</p>"},{"location":"contributing/#publish","title":"Publish","text":"<p>publish-to-pypi.yml is the workflow that publishes the release. It starts on a push to the main branch but can also be manually triggered. It will always publish to TestPyPI on a push. If the git head has a tag starting with 'v' it will also publish to PyPi. If it is published to PyPI successfully, it will also create a Github release.</p>"},{"location":"contributing/#manual","title":"Manual","text":"<p>To manually publish create a tag on the head of the main branch and push the tags.</p> <pre><code>git checkout\ngit tag v0.1.0 -m \"v0.1.0\"\ngit push --tags\n</code></pre> <p>If the publish workflow doesn't start automatically. Run the publish-to-pypi workflow manually.</p> <p>Note</p> <p>Where possible use the workflows to publish releases.</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Alan Fleming.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished \nto do so, subject to the following conditions:\n\nThe above copyright notice, shall be included in all copies or substantial \nportions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#011-2025-08-28","title":"0.1.1 - 2025-08-28","text":""},{"location":"about/changelog/#miscellaneous","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Bugfixes - fix installing without trio and installing a kernelspec #73</li> </ul>"},{"location":"about/changelog/#010-2025-08-28","title":"0.1.0 - 2025-08-28","text":""},{"location":"about/changelog/#breaking-changes","title":"\ud83c\udfd7\ufe0f Breaking changes","text":"<ul> <li>Caller.queue_call add argument send_nowait  and convert to sync that optionally returns an awaitable. #71</li> </ul>"},{"location":"about/changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Add anyio_backend_options and use uvloop by default #70</li> </ul>"},{"location":"about/changelog/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Use mike for documentation versioning. #67</p> </li> <li> <p>Update docs, readme and project description. #66</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_1","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0 #72</p> </li> <li> <p>Drop matplotlib dependency. #69</p> </li> </ul>"},{"location":"about/changelog/#010-rc3-2025-08-26","title":"0.1.0-rc3 - 2025-08-26","text":""},{"location":"about/changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>Add more classifers and code coverage #64</li> </ul>"},{"location":"about/changelog/#miscellaneous_2","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc3 #65</p> </li> <li> <p>Add workflow_run event because the release is not triggered if  the release is created by another workflow. #62</p> </li> </ul>"},{"location":"about/changelog/#010-rc2-2025-08-26","title":"0.1.0-rc2 - 2025-08-26","text":""},{"location":"about/changelog/#miscellaneous_3","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li>Prepare for release v0.1.0-rc2 #61</li> </ul>"},{"location":"about/changelog/#010-rc1-2025-08-26","title":"0.1.0-rc1 - 2025-08-26","text":""},{"location":"about/changelog/#documentation_1","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Update licensing and contribution notes #27</li> </ul>"},{"location":"about/changelog/#miscellaneous_4","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Prepare for release v0.1.0-rc1 #60</p> </li> <li> <p>Merge pull request #56 from fleming79/release/v0.1.0-rc1 #56</p> </li> <li> <p>Revise new release #55</p> </li> <li> <p>New release workflow in one step with publish option. #51</p> </li> <li> <p>Improve release workflow, update documentation and license info. #29</p> </li> <li> <p>Maintenance #26</p> </li> </ul>"},{"location":"about/changelog/#010-rc0-2025-08-24","title":"[0.1.0-rc0] - 2025-08-24","text":""},{"location":"about/changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>First release #18</p> </li> <li> <p>Switch to vcs for versioning. #2</p> </li> </ul>"},{"location":"about/changelog/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li> <p>Use no-local-version in pyproject.toml instead. #5</p> </li> <li> <p>Use no-local-version on ci. #4</p> </li> </ul>"},{"location":"about/changelog/#documentation_2","title":"\ud83d\udcdd Documentation","text":"<ul> <li> <p>Revise workflow to work with tags that start with 'v'. No longer sets the tag when writing the changelog. #16</p> </li> <li> <p>Switch to python installer to run git cliff. #14</p> </li> <li> <p>Revise changelog template. #12</p> </li> <li> <p>Do changelog as PR instead of push to main. #8</p> </li> <li> <p>Git cliff #7</p> </li> <li> <p>Fix mkdocs publishing #6</p> </li> </ul>"},{"location":"about/changelog/#miscellaneous_5","title":"\ud83c\udf00 Miscellaneous","text":"<ul> <li> <p>Bugfix #25</p> </li> <li> <p>Update changelog #24</p> </li> <li> <p>Update changelog #22</p> </li> <li> <p>Release workflow changes #21</p> </li> <li> <p>Update release workflow to use a template that appends output from git-cliff #17</p> </li> <li> <p>Bump the actions group across 1 directory with 2 updates #3</p> </li> </ul>"},{"location":"about/contributing/","title":"Contributing","text":"<p>This project is under active development. Feel free to create an issue to provide feedback.</p>"},{"location":"about/contributing/#development","title":"Development","text":"<p>uv is used for development. By default it will install all relevant versions of the required packages when it is synchronised.</p>"},{"location":"about/contributing/#installation-from-source","title":"Installation from source","text":"<p>If you are working on a pull request, [make a fork] of the project and install from your fork.</p> <pre><code>git clone &lt;repository&gt;\ncd async-kernel\nuv venv -p python@311 # or whichever environment you are targeting.\nuv sync\n# Activate the environment\n</code></pre>"},{"location":"about/contributing/#update-packages","title":"Update packages","text":"<pre><code>uv lock --upgrade\n</code></pre>"},{"location":"about/contributing/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"about/contributing/#running-tests-with-coverage","title":"Running tests with coverage","text":"<p>We are aiming for 100% code coverage on CI (Linux). Any new code should also update tests to maintain coverage.</p> <pre><code>uv run pytest -vv --cov\n</code></pre> <p>Note</p> <p>We are only targeting 100% on linux for &gt;= 3.12 for the following reasons:</p> <ol> <li><code>transport</code> type <code>ipc</code> is only supported linux which has special handling.</li> <li>Coverage on Python 3.11 doesn't correctly gather data for subprocesses giving invalid coverage reports.</li> </ol> <p></p>"},{"location":"about/contributing/#code-styling","title":"Code Styling","text":"<p><code>Async kernel</code> uses ruff for code formatting. The pre-commit hook should take care of how it should look.</p> <p>To install <code>pre-commit</code> to run prior commits with the following:</p> <pre><code>pre-commit install\n</code></pre> <p>If you prefer not to install the hook, you can invoke the pre-commit hook by hand at any time with:</p> <pre><code>pre-commit run # append -a to run against all files.\n</code></pre>"},{"location":"about/contributing/#type-checking","title":"Type checking","text":"<p>Type checking is performed using basedpyright.</p> <pre><code>basedpyright\n</code></pre>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is provided my Material for MkDocs . To start up a server for editing locally:</p>"},{"location":"about/contributing/#install","title":"Install","text":"<pre><code>uv sync --group docs\nuv run async-kernel -a async-docs --shell.execute_request_timeout 0.1\n</code></pre>"},{"location":"about/contributing/#serve-locally","title":"Serve locally","text":"<pre><code>mkdocs serve \n</code></pre>"},{"location":"about/contributing/#api-docstrings","title":"API / Docstrings","text":"<p>API documentation is included using mkdocstrings.</p> <p>Docstrings are written in docstring format google-notypes. Typing information is included automatically by griff.</p>"},{"location":"about/contributing/#see-also","title":"See also","text":"<ul> <li>cross-referencing</li> </ul>"},{"location":"about/contributing/#notebooks","title":"Notebooks","text":"<p>Notebooks are included in the documentation with the plugin mkdocs-jupyter.</p>"},{"location":"about/contributing/#useful-links","title":"Useful links","text":"<p>These links are not relevant for docstrings.</p> <ul> <li>footnotes</li> <li>tooltips</li> </ul>"},{"location":"about/contributing/#deploy-manually","title":"Deploy manually","text":"<pre><code>mkdocs gh-deploy --force\n</code></pre>"},{"location":"about/contributing/#releasing-async-kernel","title":"Releasing Async kernel","text":"<p>To start a new release manually trigger the Github action new_release.yml.</p> <p>The action does the following:</p> <ol> <li>Creates a new branch using the version number.</li> <li>Updates the changelog for the new version using git-cliff.</li> <li>Commits the revised changelog.</li> <li>Adds a tag against the commit with the version.</li> <li>Starts a new PR assigning the actor who triggered the workflow.</li> </ol> <p>Once the new PR is available merge the PR into the main branch. Normally this will also trigger publication of the new release.</p>"},{"location":"about/contributing/#publish","title":"Publish","text":"<p>publish-to-pypi.yml is the workflow that publishes the release. It starts on a push to the main branch but can also be manually triggered. It will always publish to TestPyPI on a push. If the git head has a tag starting with 'v' it will also publish to PyPi. If it is published to PyPI successfully, it will also create a Github release.</p>"},{"location":"about/contributing/#manual","title":"Manual","text":"<p>To manually publish create a tag on the head of the main branch and push the tags.</p> <pre><code>git checkout\ngit tag v0.1.0 -m \"v0.1.0\"\ngit push --tags\n</code></pre> <p>If the publish workflow doesn't start automatically. Run the publish-to-pypi workflow manually.</p> <p>Note</p> <p>Where possible use the workflows to publish releases.</p>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Notebooks in this documentation show the result of each cell after executing for a short duration (~100ms).</p> <p>You can download the notebook with the button at the top right of the page for the notebook.</p> <p>Note</p> <p>The suppress-error tag is inserted in code cells to enable with generating documentation. The symbol '\u26a0' is an indicator that the error was suppressed. Normally this is due to the timeout but there is no distinction on the type of error.</p>"},{"location":"notebooks/caller/","title":"Caller","text":"<p>To get the caller for the main thread.</p> <p>Ensure you're running an async kernel.</p> In\u00a0[1]: Copied! <pre>%callers\n</pre> %callers <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> In\u00a0[2]: suppress-error Copied! <pre>import random\nimport time\n\nimport ipywidgets as ipw\n\nfrom async_kernel import Caller\n\noutputs = {}\n\n\ndef my_func(n):\n    caller = Caller()\n    if not (out := outputs.get(caller)):\n        outputs[caller] = out = ipw.HTML(description=str(caller))\n        out.style.description_width = \"220px\"\n        display(out)\n    sleep_time = random.random() / 4\n    out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"\n    time.sleep(sleep_time)\n    return n\n\n\nasync def run_forever():\n    n = 0\n    while True:\n        n += 1\n        yield Caller.to_thread(my_func, n)\n\n\nasync for fut in Caller.as_completed(run_forever()):\n    result = await fut\n    print(f\"Finished: {result}\", end=\"\\r\")\n</pre> import random import time  import ipywidgets as ipw  from async_kernel import Caller  outputs = {}   def my_func(n):     caller = Caller()     if not (out := outputs.get(caller)):         outputs[caller] = out = ipw.HTML(description=str(caller))         out.style.description_width = \"220px\"         display(out)     sleep_time = random.random() / 4     out.value = f\"{n=:04d} sleeping {sleep_time * 1000:03.0f} ms\"     time.sleep(sleep_time)     return n   async def run_forever():     n = 0     while True:         n += 1         yield Caller.to_thread(my_func, n)   async for fut in Caller.as_completed(run_forever()):     result = await fut     print(f\"Finished: {result}\", end=\"\\r\") <pre>HTML(value='', description='Caller&lt;Thread-3 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-4 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-5 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-6 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-7 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-9 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-8 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>Finished: 3</pre> <pre>\r</pre> <pre>HTML(value='', description='Caller&lt;Thread-10 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-11 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>HTML(value='', description='Caller&lt;Thread-12 (anyio_run_caller)&gt;', style=HTMLStyle(description_width='220px'))</pre> <pre>Finished: 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[3]: Copied! <pre>%callers\n</pre> %callers <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-3 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-4 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-5 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-6 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-7 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-8 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-9 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-10 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-11 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-12 (anyio_run_caller)\t</pre> <pre>\n</pre>"},{"location":"notebooks/caller/#caller","title":"Caller\u00b6","text":"<p><code>Caller</code> is a class that makes it easy to call code in different threads/tasks.</p> <p>One caller instance is created per thread, and each of those instances can be retrieved by name using the <code>Caller.get_instance</code> class method or in the thread in which it is running simply by <code>Caller()</code>.</p> <p><code>Caller</code> is used by the kernel internally for running code, but can also be used directly by the user. Each caller starts its own iopub zmq socket.</p>"},{"location":"notebooks/caller/#threads","title":"Threads\u00b6","text":"<p>The caller manages a pool of worker threads (not related to anyio worker threads) or you can specify the name of a new thread which you can manage yourself. Each thread has its own anyio event loop in which the code will be called.</p> <p>Most methods that perform execution return an <code>async_kernel.Future</code>.</p>"},{"location":"notebooks/caller/#usage-by-the-kernel","title":"Usage by the kernel\u00b6","text":"<p>The Kernel runs two threads; one each for the shell and control. The thread names are 'MainThread' and 'ControlThread' respectively. You can easily get the main thread caller by using the classmethod <code>Caller.get_instance()</code>.</p> <p>Kernel uses one of <code>Caller().call_soon</code> <code>Caller.to_thread</code> depending on the header directive</p>"},{"location":"notebooks/caller/#caller-of-the-current-thread","title":"Caller of the current thread\u00b6","text":"<p>To get the caller for the current thread use Caller(). It will raise a Runtime error if the thread doesn't have a running instance.</p>"},{"location":"notebooks/caller/#example","title":"Example\u00b6","text":"<p>This example requires ipywidgets!</p>"},{"location":"notebooks/concurrency/","title":"Concurrency","text":"In\u00a0[1]: Copied! <pre>from async_kernel import utils\nfrom async_kernel.typing import KernelConcurrencyMode, MsgType, RunMode\n\nkernel = utils.get_kernel()\n\nkernel.get_run_mode(MsgType.comm_msg)\n</pre> from async_kernel import utils from async_kernel.typing import KernelConcurrencyMode, MsgType, RunMode  kernel = utils.get_kernel()  kernel.get_run_mode(MsgType.comm_msg) <pre>&lt;RunMode.task: 'task'&gt;</pre> <p>The <code>kernel.concurrency_mode</code> will also change the <code>RunMode</code> that is returned by <code>kernel.get_run_mode</code>.</p> In\u00a0[2]: Copied! <pre>kernel.concurrency_mode = KernelConcurrencyMode.blocking\nprint(f\"\"\"\nkernel.concurrency_mode: {kernel.concurrency_mode!s}    \nkernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\")\n\nkernel.concurrency_mode = KernelConcurrencyMode.default\nprint(f\"\"\"\nkernel.concurrency_mode: {kernel.concurrency_mode!s}    \nkernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\")\n</pre> kernel.concurrency_mode = KernelConcurrencyMode.blocking print(f\"\"\" kernel.concurrency_mode: {kernel.concurrency_mode!s}     kernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\")  kernel.concurrency_mode = KernelConcurrencyMode.default print(f\"\"\" kernel.concurrency_mode: {kernel.concurrency_mode!s}     kernel.get_run_mode:     {kernel.get_run_mode(MsgType.comm_msg).name}\"\"\") <pre>\nkernel.concurrency_mode: blocking    \nkernel.get_run_mode:     blocking</pre> <pre>\n</pre> <pre>\nkernel.concurrency_mode: default    \nkernel.get_run_mode:     task</pre> <pre>\n</pre> <p>Below is a list of the run modes for the currently available concurrency modes.</p> <p>Note</p> <p>     `blocking` mode is roughly equivalent to how IpyKernel &lt; 7.0 operates.      </p> In\u00a0[3]: Copied! <pre>data = kernel.all_concurrency_run_modes()\ntry:\n    import pandas as pd\nexcept ImportError:\n    print(data)\nelse:\n    data = pd.DataFrame(data)\n    data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")\n    data = data.pivot(index=\"MsgType\", columns=[\"KernelConcurrencyMode\", \"SocketID\"], values=\"RunMode\")  # noqa: PD010\n    display(data)\n</pre> data = kernel.all_concurrency_run_modes() try:     import pandas as pd except ImportError:     print(data) else:     data = pd.DataFrame(data)     data[\"RunMode\"] = data.RunMode.str.replace(\"##\", \"\")     data = data.pivot(index=\"MsgType\", columns=[\"KernelConcurrencyMode\", \"SocketID\"], values=\"RunMode\")  # noqa: PD010     display(data) KernelConcurrencyMode default blocking default blocking SocketID shell shell control control MsgType comm_close blocking blocking blocking blocking comm_info_request blocking blocking blocking blocking comm_msg task blocking task blocking comm_open blocking blocking blocking blocking complete_request thread blocking thread blocking debug_request None blocking task blocking execute_request queue blocking task blocking history_request thread blocking thread blocking inspect_request thread blocking thread blocking interrupt_request task blocking task blocking is_complete_request thread blocking thread blocking kernel_info_request blocking blocking blocking blocking shutdown_request None blocking task blocking In\u00a0[4]: Copied! <pre>async def demo():\n    import threading\n\n    import anyio\n    from ipywidgets import Button\n\n    from async_kernel import Caller, utils\n\n    print(\"Run mode:\", utils.get_job()[\"run_mode\"])\n\n    print(f\"Thread name: '{threading.current_thread().name}'\")\n    button = Button(description=\"Finish\")\n    event = anyio.Event()\n    caller = Caller()  # Use caller so the `##thread` example works.\n    # This is because widget messages are received by the shell in the main thread. The event is being waited in this thread.\n    button.on_click(lambda _: caller.call_no_context(event.set))\n    display(button)\n    await event.wait()\n    button.close()\n    print(f\"Finished ... thread name: '{threading.current_thread().name}'\")\n    return \"Finished\"\n</pre> async def demo():     import threading      import anyio     from ipywidgets import Button      from async_kernel import Caller, utils      print(\"Run mode:\", utils.get_job()[\"run_mode\"])      print(f\"Thread name: '{threading.current_thread().name}'\")     button = Button(description=\"Finish\")     event = anyio.Event()     caller = Caller()  # Use caller so the `##thread` example works.     # This is because widget messages are received by the shell in the main thread. The event is being waited in this thread.     button.on_click(lambda _: caller.call_no_context(event.set))     display(button)     await event.wait()     button.close()     print(f\"Finished ... thread name: '{threading.current_thread().name}'\")     return \"Finished\" <p>Lets run it normally (queue)</p> In\u00a0[5]: suppress-error Copied! <pre>await demo()\n</pre> await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[6]: suppress-error Copied! <pre>##queue\n# Tip: try running this cell while the previous cell is still busy.\nawait demo()\n</pre> ##queue # Tip: try running this cell while the previous cell is still busy. await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[7]: suppress-error Copied! <pre>RunMode.task  # noqa: B018  # Using the literal `RunMode` values directly is also possible. Though it may show up as a [Flake8 B018 issue](https://docs.astral.sh/ruff/rules/useless-expression/)\nawait demo()\n</pre> RunMode.task  # noqa: B018  # Using the literal `RunMode` values directly is also possible. Though it may show up as a [Flake8 B018 issue](https://docs.astral.sh/ruff/rules/useless-expression/) await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[8]: thread suppress-error Copied! <pre># This time we'll use the tag to run the cell in a Thread\nawait demo()\n</pre> # This time we'll use the tag to run the cell in a Thread await demo() <pre>Run mode:</pre> <pre> </pre> <pre>##queue</pre> <pre>\n</pre> <pre>Thread name: 'MainThread'</pre> <pre>\n</pre> <pre>Button(description='Finish', style=ButtonStyle())</pre> <pre></pre> In\u00a0[9]: Copied! <pre>##thread\n%callers # magic provided by async kernel\n</pre> ##thread %callers # magic provided by async kernel <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-3 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-4 (anyio_run_caller)\t\u2190 current thread</pre> <pre>\n</pre>"},{"location":"notebooks/concurrency/#concurrency","title":"Concurrency\u00b6","text":"<p>Async kernel runs message request with one of the following <code>RunModes</code>.</p> <ul> <li>blocking: Run the handler directly blocking the message loop</li> <li>queue: Run in a queue</li> <li>task: Run in a task</li> <li>thread: Run in a Caller thread</li> </ul> <p>The kernel decides the run mode dynamically with the method [get_run_mode][async_kernel.kernel.Kernel.get_run_mode].</p>"},{"location":"notebooks/concurrency/#execute-request-run-mode","title":"Execute request run mode\u00b6","text":"<p>There are a few options to modify how code cells are run.</p> <ul> <li>Metadata</li> <li>Directly in code</li> <li>tags</li> <li>Message header (in custom messages)</li> </ul> <p>Warning</p> <p>Only Jupyter lab is known to allow concurrent execution of cells.</p>"},{"location":"notebooks/concurrency/#code-for-example","title":"Code for example\u00b6","text":"<ul> <li>This example requires ipywidgets</li> <li>Ensure you are running an async kernel</li> </ul> <p>Lets define a function that we'll reuse for the remainder of the notebook.</p>"},{"location":"notebooks/concurrency/#run-mode-task","title":"Run mode: task\u00b6","text":"<p>The <code>task</code> mode instructs the kernel to execute the code in a task separate to the queue, Both <code>task</code> and <code>thread</code> execute modes can be started when the kernel is busy executing. There is no imposed limitation on the number of tasks (or threads) that can be run concurrently.</p> <p>See also the Caller example on how to call directly.</p>"},{"location":"notebooks/concurrency/#run-mode-thread","title":"Run mode: thread\u00b6","text":""},{"location":"notebooks/simple_example/","title":"Simple example","text":"In\u00a0[1]: Copied! <pre>import anyio\nimport ipywidgets as ipw\n\nfrom async_kernel import Caller, utils\n\n\nasync def demo():\n    %callers\n    caller = Caller()  # Use caller set the event in the waiting thread\n    b = ipw.Button(description=\"Continue\")\n    display(b)\n    for i in range(1, 3):\n        b.description = f\"Continue {i}\"\n        event = anyio.Event()\n        b.on_click(lambda _: caller.call_soon(event.set))  # noqa: B023  # pyright: ignore[reportUnknownLambdaType]\n        print(f\"Waiting {i}\", end=\"\\r\")\n        await event.wait()\n    b.close()\n    print(\"\\nDone!\")\n</pre> import anyio import ipywidgets as ipw  from async_kernel import Caller, utils   async def demo():     %callers     caller = Caller()  # Use caller set the event in the waiting thread     b = ipw.Button(description=\"Continue\")     display(b)     for i in range(1, 3):         b.description = f\"Continue {i}\"         event = anyio.Event()         b.on_click(lambda _: caller.call_soon(event.set))  # noqa: B023  # pyright: ignore[reportUnknownLambdaType]         print(f\"Waiting {i}\", end=\"\\r\")         await event.wait()     b.close()     print(\"\\nDone!\") In\u00a0[2]: suppress-error Copied! <pre>print(utils.get_tags())\nawait demo()\n</pre> print(utils.get_tags()) await demo() <pre>[]</pre> <pre>\n</pre> <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[3]: suppress-error Copied! <pre>##task\nawait demo()\n</pre> ##task await demo() <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[4]: suppress-error Copied! <pre>##thread\nawait demo()\n</pre> ##thread await demo() <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-3 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-4 (anyio_run_caller)\t\u2190 current thread</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre> In\u00a0[5]: suppress-error Copied! <pre>async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):\n    pass\n</pre> async for _ in Caller.as_completed(Caller().call_soon(demo) for _ in range(2)):     pass <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-3 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-4 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre>Running\tProtected\t\t\tName</pre> <pre>\n</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tMainThread\t\u2190 current thread</pre> <pre>\n</pre> <pre>   \u2713\t   \ud83d\udd10\t\tControlThread\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-3 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>   \u2713\t\t\tThread-4 (anyio_run_caller)\t</pre> <pre>\n</pre> <pre>Button(description='Continue', style=ButtonStyle())</pre> <pre>Waiting 1</pre> <pre>\r</pre> <pre></pre>"},{"location":"notebooks/simple_example/#overview","title":"Overview\u00b6","text":"<p>This example demonstrates different ways that the same code can be executed. This is an overview of the four cells shown in the animation below.</p> <ol> <li>Define the coroutine function.<ol> <li>Cell 'magic' <code>%callers</code> prints a list of Caller instances and the thread in which it is executing.</li> <li>A button is created and and it runs a loop twice:<ol> <li>Creates any anyio event.</li> <li>Prints a statement.</li> <li>Waits for the button click to set the event.</li> </ol> </li> </ol> </li> <li>Execute <code>demo</code> normally.</li> <li>Execute <code>demo</code> concurrently in a task.</li> <li>Execute <code>demo</code> in a thread.</li> </ol> <p></p>"},{"location":"notebooks/simple_example/#calleras_completed","title":"Caller.as_completed\u00b6","text":"<p>See also: the caller notebook.</p>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides documentation for each module in async kernel.</p>"},{"location":"reference/#highlights","title":"Highlights","text":"<ul> <li>Caller</li> </ul>"},{"location":"reference/asyncshell/","title":"Asyncshell","text":""},{"location":"reference/asyncshell/#async_kernel.asyncshell","title":"async_kernel.asyncshell","text":"<p>Classes:</p> <ul> <li> <code>AsyncDisplayHook</code>           \u2013            <p>A displayhook subclass that publishes data using ZeroMQ.</p> </li> <li> <code>AsyncDisplayPublisher</code>           \u2013            <p>A display publisher that publishes data using a ZeroMQ PUB socket.</p> </li> <li> <code>AsyncInteractiveShell</code>           \u2013            <p>An IPython InteractiveShell modified to work with Async kernel.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook","title":"AsyncDisplayHook","text":"<p>A displayhook subclass that publishes data using ZeroMQ.</p> <p>This is intended to work with an InteractiveShell instance. It sends a dict of different representations of the object.</p> <p>Methods:</p> <ul> <li> <code>finish_displayhook</code>             \u2013              <p>Finish up all displayhook activities.</p> </li> <li> <code>start_displayhook</code>             \u2013              <p>Start the display hook.</p> </li> <li> <code>write_format_data</code>             \u2013              <p>Write format data to the message.</p> </li> <li> <code>write_output_prompt</code>             \u2013              <p>Write the output prompt.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.finish_displayhook","title":"finish_displayhook","text":"<pre><code>finish_displayhook() -&gt; None\n</code></pre> <p>Finish up all displayhook activities.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef finish_displayhook(self) -&gt; None:\n    \"\"\"Finish up all displayhook activities.\"\"\"\n    if self.content:\n        self.kernel.iopub_send(\"display_data\", content=self.content)\n        self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.start_displayhook","title":"start_displayhook","text":"<pre><code>start_displayhook() -&gt; None\n</code></pre> <p>Start the display hook.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef start_displayhook(self) -&gt; None:\n    \"\"\"Start the display hook.\"\"\"\n    self.content = {}\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_format_data","title":"write_format_data","text":"<pre><code>write_format_data(format_dict, md_dict=None) -&gt; None\n</code></pre> <p>Write format data to the message.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_format_data(self, format_dict, md_dict=None) -&gt; None:\n    \"\"\"Write format data to the message.\"\"\"\n    self.content[\"data\"] = format_dict\n    self.content[\"metadata\"] = md_dict\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayHook.write_output_prompt","title":"write_output_prompt","text":"<pre><code>write_output_prompt() -&gt; None\n</code></pre> <p>Write the output prompt.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef write_output_prompt(self) -&gt; None:\n    \"\"\"Write the output prompt.\"\"\"\n    self.content[\"execution_count\"] = self.prompt_count\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher","title":"AsyncDisplayPublisher","text":"<p>A display publisher that publishes data using a ZeroMQ PUB socket.</p> <p>Methods:</p> <ul> <li> <code>clear_output</code>             \u2013              <p>Clear output associated with the current execution (cell).</p> </li> <li> <code>publish</code>             \u2013              <p>Publish a display-data message.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output","title":"clear_output","text":"<pre><code>clear_output(wait: bool = False) -&gt; None\n</code></pre> <p>Clear output associated with the current execution (cell).</p> <p>Parameters:</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef clear_output(self, wait: bool = False) -&gt; None:\n    \"\"\"Clear output associated with the current execution (cell).\n\n    Args:\n        wait: If True, the output will not be cleared immediately,\n            instead waiting for the next display before clearing.\n            This reduces bounce during repeated clear &amp; display loops.\n    \"\"\"\n    utils.get_kernel().iopub_send(msg_or_type=\"clear_output\", content={\"wait\": wait}, ident=self.topic)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.clear_output(wait)","title":"<code>wait</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the output will not be cleared immediately, instead waiting for the next display before clearing. This reduces bounce during repeated clear &amp; display loops.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish","title":"publish","text":"<pre><code>publish(\n    data: Content,\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None\n</code></pre> <p>Publish a display-data message.</p> <p>Parameters:</p> <p>Reference</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef publish(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self,\n    data: Content,\n    metadata: dict | None = None,\n    *,\n    transient: dict | None = None,\n    update: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Publish a display-data message.\n\n    Args:\n        data: A mime-bundle dict, keyed by mime-type.\n        metadata: Metadata associated with the data.\n        transient: Transient data that may only be relevant during a live display, such as display_id.\n            Transient data should not be persisted to documents.\n        update: If True, send an update_display_data message instead of display_data.\n\n    [Reference](https://jupyter-client.readthedocs.io/en/stable/messaging.html#update-display-data)\n    \"\"\"\n    utils.get_kernel().iopub_send(\n        msg_or_type=\"update_display_data\" if update else \"display_data\",\n        content={\"data\": data, \"metadata\": metadata or {}, \"transient\": transient or {}} | kwargs,\n        ident=self.topic,\n    )\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(data)","title":"<code>data</code>","text":"(<code>Content</code>)           \u2013            <p>A mime-bundle dict, keyed by mime-type.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(metadata)","title":"<code>metadata</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata associated with the data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(transient)","title":"<code>transient</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Transient data that may only be relevant during a live display, such as display_id. Transient data should not be persisted to documents.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncDisplayPublisher.publish(update)","title":"<code>update</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, send an update_display_data message instead of display_data.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell","title":"AsyncInteractiveShell","text":"<p>An IPython InteractiveShell modified to work with Async kernel.</p> <p>Notable differences</p> <ul> <li>All execute requests are run asynchronously.</li> <li> <p>Supports a soft timeout with the metadata {\"timeout\":}<sup>1</sup>. <li> <p>Not all features are support (see \"not-supported\" features listed below).</p> </li> <ol> <li> <p>When the execution time exceeds the timeout value, the code execution will \"move on\".\u00a0\u21a9</p> </li> </ol> <p>Methods:</p> <ul> <li> <code>init_magics</code>             \u2013              <p>Initialize magics.</p> </li> <li> <code>run_cell_async</code>             \u2013              <p>Run a complete IPython cell asynchronously.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>autoindent</code>           \u2013            <p>not-supported</p> </li> <li> <code>debug</code>           \u2013            <p>not-supported</p> </li> <li> <code>execute_request_timeout</code>           \u2013            <p>A timeout in seconds to complete execute requests.</p> </li> <li> <code>kernel</code>               (<code>Kernel</code>)           \u2013            <p>The current kernel.</p> </li> <li> <code>loop_runner</code>           \u2013            <p>not-supported</p> </li> <li> <code>loop_runner_map</code>           \u2013            <p>not-supported</p> </li> <li> <code>readline_use</code>           \u2013            <p>not-supported</p> </li> <li> <code>run_cell</code>           \u2013            <p>not-supported</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.autoindent","title":"autoindent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autoindent = False\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.execute_request_timeout","title":"execute_request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request_timeout = CFloat(default_value=None, allow_none=True)\n</code></pre> <p>A timeout in seconds to complete execute requests.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.kernel","title":"kernel  <code>property</code>","text":"<pre><code>kernel: Kernel\n</code></pre> <p>The current kernel.</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.loop_runner","title":"loop_runner  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loop_runner = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.loop_runner_map","title":"loop_runner_map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loop_runner_map = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.readline_use","title":"readline_use  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>readline_use = False\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.run_cell","title":"run_cell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_cell = None\n</code></pre> <p>not-supported</p>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.init_magics","title":"init_magics","text":"<pre><code>init_magics() -&gt; None\n</code></pre> <p>Initialize magics.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\ndef init_magics(self) -&gt; None:\n    \"\"\"Initialize magics.\"\"\"\n    super().init_magics()\n    self.register_magics(KernelMagics)\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.AsyncInteractiveShell.run_cell_async","title":"run_cell_async  <code>async</code>","text":"<pre><code>run_cell_async(\n    raw_cell: str,\n    store_history=False,\n    silent=False,\n    shell_futures=True,\n    *,\n    transformed_cell: str | None = None,\n    preprocessing_exc_tuple: tuple | None = None,\n    cell_id: str | None = None,\n) -&gt; ExecutionResult\n</code></pre> <p>Run a complete IPython cell asynchronously.</p> <p>This function runs execute requests for the kernel wrapping InteractiveShell.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@override\nasync def run_cell_async(\n    self,\n    raw_cell: str,\n    store_history=False,\n    silent=False,\n    shell_futures=True,\n    *,\n    transformed_cell: str | None = None,\n    preprocessing_exc_tuple: tuple | None = None,\n    cell_id: str | None = None,\n) -&gt; ExecutionResult:\n    \"\"\"Run a complete IPython cell asynchronously.\n\n    This function runs [execute requests][async_kernel.Kernel.execute_request] for the kernel\n    wrapping [InteractiveShell][IPython.core.interactiveshell.InteractiveShell.run_cell_async].\n    \"\"\"\n    with anyio.fail_after(delay=utils.get_execute_request_timeout()):\n        result: ExecutionResult = await super().run_cell_async(\n            raw_cell=raw_cell,\n            store_history=store_history,\n            silent=silent,\n            shell_futures=shell_futures,\n            transformed_cell=transformed_cell,\n            preprocessing_exc_tuple=preprocessing_exc_tuple,\n            cell_id=cell_id,\n        )\n    self.events.trigger(\"post_execute\")\n    if not silent:\n        self.events.trigger(\"post_run_cell\", result)\n    return result\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics","title":"KernelMagics","text":"<p>Extra magics for async kernel.</p> <p>Methods:</p> <ul> <li> <code>callers</code>             \u2013              <p>Print a table of Callers, indicating its status including:  -running - protected - on the current thread.</p> </li> <li> <code>connect_info</code>             \u2013              <p>Print information for connecting other clients to this kernel.</p> </li> </ul>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.callers","title":"callers","text":"<pre><code>callers(_) -&gt; None\n</code></pre> <p>Print a table of Callers, indicating its status including:  -running - protected - on the current thread.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef callers(self, _) -&gt; None:\n    \"Print a table of [Callers][async_kernel.Caller], indicating its status including:  -running - protected - on the current thread.\"\n    lines = [\"\\t\".join([\"Running\", \"Protected\", \"\\t\", \"Name\"]), \"\u2500\" * 70]\n    for caller in Caller.all_callers(running_only=False):\n        symbol = \"   \u2713\" if caller.running else \"   \u2717\"\n        current_thread: Literal[\"\u2190 current thread\", \"\"] = \"\u2190 current thread\" if caller is Caller() else \"\"\n        protected = \"   \ud83d\udd10\" if caller.protected else \"\"\n        lines.append(\"\\t\".join([symbol, protected, \"\", caller.thread.name, current_thread]))\n    print(*lines, sep=\"\\n\")\n</code></pre>"},{"location":"reference/asyncshell/#async_kernel.asyncshell.KernelMagics.connect_info","title":"connect_info","text":"<pre><code>connect_info(_) -&gt; None\n</code></pre> <p>Print information for connecting other clients to this kernel.</p> Source code in <code>src/async_kernel/asyncshell.py</code> <pre><code>@line_magic\ndef connect_info(self, _) -&gt; None:\n    \"\"\"Print information for connecting other clients to this kernel.\"\"\"\n    kernel = utils.get_kernel()\n    connection_file = pathlib.Path(kernel.connection_file)\n    # if it's in the default dir, truncate to basename\n    if jupyter_runtime_dir() == str(connection_file.parent):\n        connection_file = connection_file.name\n    info = kernel.get_connection_info()\n    print(\n        json.dumps(info, indent=2, default=json_default),\n        \"Paste the above JSON into a file, and connect with:\\n\"\n        + \"    $&gt; jupyter &lt;app&gt; --existing &lt;file&gt;\\n\"\n        + \"or, if you are local, you can connect with just:\\n\"\n        + f\"    $&gt; jupyter &lt;app&gt; --existing {connection_file}\\n\"\n        + \"or even just:\\n\"\n        + \"    $&gt; jupyter &lt;app&gt; --existing\\n\"\n        + \"if this is the most recent Jupyter kernel you have started.\",\n    )\n</code></pre>"},{"location":"reference/caller/","title":"Caller","text":""},{"location":"reference/caller/#async_kernel.caller","title":"async_kernel.caller","text":"<p>Classes:</p> <ul> <li> <code>Caller</code>           \u2013            <p>A class to enable calling functions and coroutines between anyio event loops.</p> </li> <li> <code>Future</code>           \u2013            <p>A class representing a future result modelled on Asyncio's <code>Future</code>.</p> </li> <li> <code>FutureCancelledError</code>           \u2013            <p>Used to indicate a <code>Future</code> is cancelled.</p> </li> <li> <code>InvalidStateError</code>           \u2013            <p>An invalid state of a Future.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller","title":"Caller","text":"<p>A class to enable calling functions and coroutines between anyio event loops.</p> <p>The <code>Caller</code> class provides a mechanism to execute functions and coroutines in a dedicated thread, leveraging AnyIO for asynchronous task management. It supports scheduling calls with delays, executing them immediately, and running them without a context.  It also provides a means to manage a pool of threads for general purpose offloading of tasks.</p> <p>The class maintains a registry of instances, associating each with a specific thread. It uses a task group to manage the execution of scheduled tasks and provides methods to start, stop, and query the status of the caller.</p> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>Create the <code>Caller</code> instance for the current thread or retrieve an existing instance</p> </li> <li> <code>all_callers</code>             \u2013              <p>A classmethod to get a list of the callers.</p> </li> <li> <code>as_completed</code>             \u2013              <p>An iterator to get Futures as they complete.</p> </li> <li> <code>call_later</code>             \u2013              <p>Schedule func to be called in this instances event loop using the current contextvars context.</p> </li> <li> <code>call_no_context</code>             \u2013              <p>Call func in the thread event loop.</p> </li> <li> <code>call_soon</code>             \u2013              <p>Schedule func to be called in this instances event loop using the current contextvars context.</p> </li> <li> <code>get_instance</code>             \u2013              <p>A classmethod that gets an instance by name, possibly starting a new instance.</p> </li> <li> <code>has_execution_queue</code>             \u2013              <p>Returns True if an execution queue exists for <code>func</code>.</p> </li> <li> <code>queue_call</code>             \u2013              <p>Queue the execution of func in queue specific to the function (not thread-safe).</p> </li> <li> <code>queue_close</code>             \u2013              <p>Close the execution queue associated with func (not thread-safe).</p> </li> <li> <code>start_new</code>             \u2013              <p>Start a new thread with a new Caller open in the context of anyio event loop.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the caller, cancelling all pending tasks and close the thread.</p> </li> <li> <code>stop_all</code>             \u2013              <p>A classmethod to stop all un-protected callers.</p> </li> <li> <code>to_thread</code>             \u2013              <p>A classmethod to call func in a separate thread see also to_thread_by_name.</p> </li> <li> <code>to_thread_by_name</code>             \u2013              <p>A classmethod to call func in the thread specified by name.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>MAX_BUFFER_SIZE</code>           \u2013            <p>The default  maximum_buffer_size used in queue_call.</p> </li> <li> <code>MAX_IDLE_POOL_INSTANCES</code>           \u2013            <p>The number of <code>pool</code> instances to leave idle (See alsoto_thread).</p> </li> <li> <code>backend</code>               (<code>Backend</code>)           \u2013            <p>The <code>anyio</code> backend the caller is running in.</p> </li> <li> <code>log</code>               (<code>LoggerAdapter[Any]</code>)           \u2013            </li> <li> <code>protected</code>               (<code>bool</code>)           \u2013            <p>Returns <code>True</code> if the caller is protected from stopping.</p> </li> <li> <code>running</code>           \u2013            <p>Returns <code>True</code> when the caller is available to run requests.</p> </li> <li> <code>stopped</code>               (<code>bool</code>)           \u2013            <p>Returns  <code>True</code> if the caller is stopped.</p> </li> <li> <code>thread</code>               (<code>Thread</code>)           \u2013            <p>The thread in which the caller will run.</p> </li> </ul>"},{"location":"reference/caller/#async_kernel.caller.Caller.MAX_BUFFER_SIZE","title":"MAX_BUFFER_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_BUFFER_SIZE = 1000\n</code></pre> <p>The default  maximum_buffer_size used in queue_call.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.MAX_IDLE_POOL_INSTANCES","title":"MAX_IDLE_POOL_INSTANCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_IDLE_POOL_INSTANCES = 10\n</code></pre> <p>The number of <code>pool</code> instances to leave idle (See alsoto_thread).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend: Backend\n</code></pre> <p>The <code>anyio</code> backend the caller is running in.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log: LoggerAdapter[Any]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.protected","title":"protected  <code>property</code>","text":"<pre><code>protected: bool\n</code></pre> <p>Returns <code>True</code> if the caller is protected from stopping.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre> <p>Returns <code>True</code> when the caller is available to run requests.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stopped","title":"stopped  <code>property</code>","text":"<pre><code>stopped: bool\n</code></pre> <p>Returns  <code>True</code> if the caller is stopped.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.thread","title":"thread  <code>instance-attribute</code>","text":"<pre><code>thread: Thread\n</code></pre> <p>The thread in which the caller will run.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__","title":"__new__","text":"<pre><code>__new__(\n    *,\n    thread: Thread | None = None,\n    log: LoggerAdapter | None = None,\n    create: bool = False,\n    protected: bool = False,\n) -&gt; Self\n</code></pre> <p>Create the <code>Caller</code> instance for the current thread or retrieve an existing instance     by passing the thread.</p> <p>The caller provides a way to execute synchronous code in a separate thread, and to call asynchronous code from synchronous code.</p> <p>Parameters:</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(thread)","title":"<code>thread</code>","text":"(<code>Thread | None</code>, default:                   <code>None</code> )           \u2013"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(log)","title":"<code>log</code>","text":"(<code>LoggerAdapter | None</code>, default:                   <code>None</code> )           \u2013            <p>Logger to use for logging messages.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(create)","title":"<code>create</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create a new instance if one does not exist for the current thread.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__(protected)","title":"<code>protected</code>","text":"\u2013            <p>Whether the caller is protected from having its event loop closed.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__--returns","title":"Returns","text":"<p>Caller     The <code>Caller</code> instance for the current thread.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.__new__--raises","title":"Raises","text":"<p>RuntimeError     If <code>create</code> is False and a <code>Caller</code> instance does not exist.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __new__(\n    cls,\n    *,\n    thread: threading.Thread | None = None,\n    log: logging.LoggerAdapter | None = None,\n    create: bool = False,\n    protected: bool = False,\n) -&gt; Self:\n    \"\"\"Create the `Caller` instance for the current thread or retrieve an existing instance\n        by passing the thread.\n\n    The caller provides a way to execute synchronous code in a separate\n    thread, and to call asynchronous code from synchronous code.\n\n    Args:\n        thread:\n        log: Logger to use for logging messages.\n        create: Whether to create a new instance if one does not exist for the current thread.\n        protected : Whether the caller is protected from having its event loop closed.\n\n    Returns\n    -------\n    Caller\n        The `Caller` instance for the current thread.\n\n    Raises\n    ------\n    RuntimeError\n        If `create` is False and a `Caller` instance does not exist.\n    \"\"\"\n\n    thread = thread or threading.current_thread()\n    if not (inst := cls._instances.get(thread)):\n        if not create:\n            msg = f\"A caller is not provided for {thread=}\"\n            raise RuntimeError(msg)\n        inst = super().__new__(cls)\n        inst.backend = Backend(sniffio.current_async_library())\n        inst.thread = thread\n        inst.log = log or logging.LoggerAdapter(logging.getLogger())\n        inst._callers = deque()\n        inst._callers_added = threading.Event()\n        inst._protected = protected\n        inst._executor_queue = {}\n        cls._instances[thread] = inst\n    return inst\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers","title":"all_callers  <code>classmethod</code>","text":"<pre><code>all_callers(running_only: bool = True) -&gt; list[Caller]\n</code></pre> <p>A classmethod to get a list of the callers.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef all_callers(cls, running_only: bool = True) -&gt; list[Caller]:\n    \"\"\"A classmethod to get a list of the callers.\n\n    Args:\n        running_only: Restrict the list to callers that are active (running in an async context).\n    \"\"\"\n    return [caller for caller in Caller._instances.values() if caller._running or not running_only]\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.all_callers(running_only)","title":"<code>running_only</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Restrict the list to callers that are active (running in an async context).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed","title":"as_completed  <code>async</code> <code>classmethod</code>","text":"<pre><code>as_completed(\n    items: Iterable[Future[T]] | AsyncGenerator[Future[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,\n) -&gt; AsyncGenerator[Future[T], Any]\n</code></pre> <p>An iterator to get Futures as they complete.</p> <p>Parameters:</p> <p>Tip</p> <ol> <li>Pass a generator should you wish to limit the number future jobs when calling to_thread/to_task etc.</li> <li>Pass a set/list/tuple to ensure all get monitored at once.</li> </ol> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\nasync def as_completed(\n    cls,\n    items: Iterable[Future[T]] | AsyncGenerator[Future[T]],\n    *,\n    max_concurrent: NoValue | int = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n) -&gt; AsyncGenerator[Future[T], Any]:\n    \"\"\"An iterator to get [Futures][async_kernel.caller.Future] as they complete.\n\n    Args:\n        items: Either a container with existing futures or generator of Futures.\n        max_concurrent: The maximum number of concurrent futures to monitor at a time.\n            This is useful when `items` is a generator utilising Caller.to_thread.\n            By default this will limit to `Caller.MAX_IDLE_POOL_INSTANCES`.\n\n    !!! tip\n\n        1. Pass a generator should you wish to limit the number future jobs when calling to_thread/to_task etc.\n        2. Pass a set/list/tuple to ensure all get monitored at once.\n    \"\"\"\n    event_future_ready = threading.Event()\n    has_result: deque[Future[T]] = deque()\n    futures: set[Future[T]] = set()\n    done = False\n    resume: Event | None = cast(\"anyio.Event | None\", None)\n\n    def _on_done(fut: Future[T]) -&gt; None:\n        has_result.append(fut)\n        event_future_ready.set()\n\n    async def iter_items(task_status: TaskStatus[None]):\n        nonlocal done, resume\n        if isinstance(items, set | list | tuple):\n            max_concurrent_ = 0\n        else:\n            max_concurrent_ = cls.MAX_IDLE_POOL_INSTANCES if max_concurrent is NoValue else int(max_concurrent)\n\n        gen = items if isinstance(items, AsyncGenerator) else iter(items)\n        task_status.started()\n        try:\n            while True:\n                fut = await anext(gen) if isinstance(gen, AsyncGenerator) else next(gen)\n                futures.add(fut)\n                if fut.done():\n                    has_result.append(fut)\n                    event_future_ready.set()\n                else:\n                    fut.add_done_callback(_on_done)\n                if max_concurrent_ and len(futures) == max_concurrent_:\n                    resume = anyio.Event()\n                    await resume.wait()\n        except (StopAsyncIteration, StopIteration):\n            return\n        finally:\n            done = True\n            event_future_ready.set()\n\n    try:\n        async with anyio.create_task_group() as tg:\n            await tg.start(iter_items)\n            while futures or not done:\n                if has_result:\n                    event_future_ready.clear()\n                    fut = has_result.popleft()\n                    futures.discard(fut)\n                    yield fut\n                    if resume:\n                        resume.set()\n                    continue\n                if not has_result:\n                    await wait_thread_event(event_future_ready)\n    finally:\n        for fut in futures:\n            fut.cancel()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(items)","title":"<code>items</code>","text":"(<code>Iterable[Future[T]] | AsyncGenerator[Future[T]]</code>)           \u2013            <p>Either a container with existing futures or generator of Futures.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.as_completed(max_concurrent)","title":"<code>max_concurrent</code>","text":"(<code>NoValue | int</code>, default:                   <code>NoValue</code> )           \u2013            <p>The maximum number of concurrent futures to monitor at a time. This is useful when <code>items</code> is a generator utilising Caller.to_thread. By default this will limit to <code>Caller.MAX_IDLE_POOL_INSTANCES</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later","title":"call_later","text":"<pre><code>call_later(\n    func: Callable[P, T | Awaitable[T]],\n    delay: float = 0.0,\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Future[T]\n</code></pre> <p>Schedule func to be called in this instances event loop using the current contextvars context.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_later(\n    self, func: Callable[P, T | Awaitable[T]], delay: float = 0.0, /, *args: P.args, **kwargs: P.kwargs\n) -&gt; Future[T]:\n    \"\"\"Schedule func to be called in this instances event loop using the current contextvars context.\n\n    Args:\n        func: The function (awaitables permitted, though discouraged).\n        delay: The minimum delay to add between submission and execution.\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n    \"\"\"\n    if self._stopped:\n        raise anyio.ClosedResourceError\n    fut: Future[T] = Future(thread=self.thread)\n    if threading.current_thread() is self.thread and (tg := self._taskgroup):\n        tg.start_soon(self._wrap_call, fut, time.monotonic(), delay, func, args, kwargs)\n    else:\n        self._callers.append((contextvars.copy_context(), (fut, time.monotonic(), delay, func, args, kwargs)))\n        self._callers_added.set()\n    self._outstanding += 1\n    return fut\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | Awaitable[T]]</code>)           \u2013            <p>The function (awaitables permitted, though discouraged).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(delay)","title":"<code>delay</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The minimum delay to add between submission and execution.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_later(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_no_context","title":"call_no_context","text":"<pre><code>call_no_context(func: Callable[P, Any], /, *args: args, **kwargs: kwargs) -&gt; None\n</code></pre> <p>Call func in the thread event loop.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_no_context(self, func: Callable[P, Any], /, *args: P.args, **kwargs: P.kwargs) -&gt; None:\n    \"\"\"Call func in the thread event loop.\n\n    Args:\n        func: The function (awaitables permitted, though discouraged).\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n    \"\"\"\n    self._callers.append(functools.partial(func, *args, **kwargs))\n    self._callers_added.set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_no_context(func)","title":"<code>func</code>","text":"(<code>Callable[P, Any]</code>)           \u2013            <p>The function (awaitables permitted, though discouraged).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_no_context(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_no_context(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon","title":"call_soon","text":"<pre><code>call_soon(\n    func: Callable[P, T | Awaitable[T]], /, *args: args, **kwargs: kwargs\n) -&gt; Future[T]\n</code></pre> <p>Schedule func to be called in this instances event loop using the current contextvars context.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def call_soon(self, func: Callable[P, T | Awaitable[T]], /, *args: P.args, **kwargs: P.kwargs) -&gt; Future[T]:\n    \"\"\"Schedule func to be called in this instances event loop using the current contextvars context.\n\n    Args:\n        func: The function (awaitables permitted, though discouraged).\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n    \"\"\"\n    return self.call_later(func, 0.0, *args, **kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | Awaitable[T]]</code>)           \u2013            <p>The function (awaitables permitted, though discouraged).</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.call_soon(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(name: str | None = 'MainThread', *, create: bool = False) -&gt; Self\n</code></pre> <p>A classmethod that gets an instance by name, possibly starting a new instance.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef get_instance(cls, name: str | None = \"MainThread\", *, create: bool = False) -&gt; Self:\n    \"\"\"A classmethod that gets an instance by name, possibly starting a new instance.\n\n    Args:\n        name: The name to identify the caller.\n        create: Create a new instance if one with the corresponding name does not already exist.\n    \"\"\"\n    for thread in cls._instances:\n        if thread.name == name:\n            return cls._instances[thread]\n    if create:\n        return cls.start_new(name=name)\n    msg = f\"A Caller was not found for {name=}.\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_instance(name)","title":"<code>name</code>","text":"(<code>str | None</code>, default:                   <code>'MainThread'</code> )           \u2013            <p>The name to identify the caller.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.get_instance(create)","title":"<code>create</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create a new instance if one with the corresponding name does not already exist.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.has_execution_queue","title":"has_execution_queue","text":"<pre><code>has_execution_queue(func: Callable) -&gt; bool\n</code></pre> <p>Returns True if an execution queue exists for <code>func</code>.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def has_execution_queue(self, func: Callable) -&gt; bool:\n    \"Returns True if an execution queue exists for `func`.\"\n    return func in self._executor_queue\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call","title":"queue_call","text":"<pre><code>queue_call(\n    func: Callable[[*PosArgsT], Awaitable[Any]],\n    /,\n    *args: *PosArgsT,\n    max_buffer_size: NoValue | int = NoValue,\n    send_nowait: Literal[False],\n) -&gt; CoroutineType[Any, Any, None]\n</code></pre><pre><code>queue_call(\n    func: Callable[[*PosArgsT], Awaitable[Any]],\n    /,\n    *args: *PosArgsT,\n    max_buffer_size: NoValue | int = NoValue,\n    send_nowait: Literal[True] | Any = True,\n) -&gt; None\n</code></pre> <pre><code>queue_call(\n    func: Callable[[*PosArgsT], Awaitable[Any]],\n    /,\n    *args: *PosArgsT,\n    max_buffer_size: NoValue | int = NoValue,\n    send_nowait: bool = True,\n) -&gt; CoroutineType[Any, Any, None] | None\n</code></pre> <p>Queue the execution of func in queue specific to the function (not thread-safe).</p> <p>The args are added to a queue associated with the provided <code>func</code>. If queue does not already exist for func, a new queue is created with a specified maximum buffer size. The arguments are then sent to the queue, and an <code>execute_loop</code> coroutine is started to consume the queue and execute the function with the received arguments.  Exceptions during execution are caught and logged.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def queue_call(\n    self,\n    func: Callable[[*PosArgsT], Awaitable[Any]],\n    /,\n    *args: *PosArgsT,\n    max_buffer_size: NoValue | int = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    send_nowait: bool = True,\n) -&gt; CoroutineType[Any, Any, None] | None:\n    \"\"\"Queue the execution of func in queue specific to the function (not thread-safe).\n\n    The args are added to a queue associated with the provided `func`. If queue does not already exist for\n    func, a new queue is created with a specified maximum buffer size. The arguments are then sent to the queue,\n    and an `execute_loop` coroutine is started to consume the queue and execute the function with the received\n    arguments.  Exceptions during execution are caught and logged.\n\n    Args:\n        func: The asynchronous function to execute.\n        *args: The arguments to pass to the function.\n        max_buffer_size: The maximum buffer size for the queue. If NoValue, defaults to [async_kernel.Caller.MAX_BUFFER_SIZE].\n        send_nowait: Set as False to return a coroutine that is used to send the request.\n            Use this to prevent experiencing exceptions if the buffer is full.\n    \"\"\"\n    self._check_in_thread()\n    if not self.has_execution_queue(func):\n        max_buffer_size = self.MAX_BUFFER_SIZE if max_buffer_size is NoValue else max_buffer_size\n        sender, queue = anyio.create_memory_object_stream[tuple[*PosArgsT]](max_buffer_size=max_buffer_size)\n\n        async def execute_loop():\n            try:\n                with contextlib.suppress(anyio.get_cancelled_exc_class()):\n                    async with queue as receive_stream:\n                        async for args in receive_stream:\n                            try:\n                                await func(*args)\n                            except Exception as e:\n                                self.log.exception(\"Execution %f failed\", func, exc_info=e)\n            finally:\n                self._executor_queue.pop(execute_loop, None)\n\n        self._executor_queue[func] = {\"queue\": sender, \"future\": self.call_soon(execute_loop)}\n    sender: MemoryObjectSendStream[tuple[*PosArgsT]] = self._executor_queue[func][\"queue\"]\n    return sender.send_nowait(args) if send_nowait else sender.send(args)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(func)","title":"<code>func</code>","text":"(<code>Callable[[*PosArgsT], Awaitable[Any]]</code>)           \u2013            <p>The asynchronous function to execute.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(*args)","title":"<code>*args</code>","text":"(<code>*PosArgsT</code>, default:                   <code>()</code> )           \u2013            <p>The arguments to pass to the function.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(max_buffer_size)","title":"<code>max_buffer_size</code>","text":"(<code>NoValue | int</code>, default:                   <code>NoValue</code> )           \u2013            <p>The maximum buffer size for the queue. If NoValue, defaults to [async_kernel.Caller.MAX_BUFFER_SIZE].</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_call(send_nowait)","title":"<code>send_nowait</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Set as False to return a coroutine that is used to send the request. Use this to prevent experiencing exceptions if the buffer is full.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close","title":"queue_close  <code>async</code>","text":"<pre><code>queue_close(func: Callable, *, force: bool = False) -&gt; bool\n</code></pre> <p>Close the execution queue associated with func (not thread-safe).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a queue was closed.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def queue_close(self, func: Callable, *, force: bool = False) -&gt; bool:\n    \"\"\"Close the execution queue associated with func (not thread-safe).\n\n    Args:\n        func: The queue of the function to close.\n        force: Shutdown without waiting pending tasks to complete.\n\n    Returns:\n        True if a queue was closed.\n    \"\"\"\n    self._check_in_thread()\n    if queue_map := self._executor_queue.pop(func, None):\n        if force:\n            queue_map[\"future\"].cancel()\n        else:\n            await queue_map[\"queue\"].aclose()\n        with contextlib.suppress(FutureCancelledError):\n            await queue_map[\"future\"]\n        return True\n    return False\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close(func)","title":"<code>func</code>","text":"(<code>Callable</code>)           \u2013            <p>The queue of the function to close.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.queue_close(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Shutdown without waiting pending tasks to complete.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new","title":"start_new  <code>classmethod</code>","text":"<pre><code>start_new(\n    *,\n    backend: Backend | NoValue = NoValue,\n    log: LoggerAdapter | None = None,\n    name: str | None = None,\n    protected: bool = False,\n    backend_options: dict | None | NoValue = NoValue,\n) -&gt; Self\n</code></pre> <p>Start a new thread with a new Caller open in the context of anyio event loop.</p> <p>A new thread and caller is always started and ready to start new jobs as soon as it is returned.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef start_new(\n    cls,\n    *,\n    backend: Backend | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    log: logging.LoggerAdapter | None = None,\n    name: str | None = None,\n    protected: bool = False,\n    backend_options: dict | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n) -&gt; Self:\n    \"\"\"Start a new thread with a new Caller open in the context of anyio event loop.\n\n    A new thread and caller is always started and ready to start new jobs as soon as it is returned.\n\n    Args:\n        backend: The backend to use for the anyio event loop (anyio.run). Defaults to the backend from where it is called.\n        log: A logging adapter to use for debug messages.\n        protected: When True, the caller will not shutdown unless shutdown is called with `force=True`.\n        backend_options: Backend options for [anyio.run][]. Defaults to `Kernel.backend_options`.\n    \"\"\"\n\n    def anyio_run_caller() -&gt; None:\n        async def caller_context() -&gt; None:\n            nonlocal caller\n            async with cls(log=log, create=True, protected=protected) as caller:\n                ready_event.set()\n                with contextlib.suppress(anyio.get_cancelled_exc_class()):\n                    await anyio.sleep_forever()\n\n        anyio.run(caller_context, backend=backend_, backend_options=backend_options)\n\n    assert name not in [t.name for t in cls._instances], f\"{name=} already exists!\"\n    backend_ = Backend(backend if backend is not NoValue else sniffio.current_async_library())\n    if backend_options is NoValue:\n        backend_options = async_kernel.Kernel().anyio_backend_options.get(backend_)\n    caller = cast(\"Self\", object)\n    ready_event = threading.Event()\n    thread = threading.Thread(target=anyio_run_caller, name=name, daemon=True)\n    thread.start()\n    ready_event.wait()\n    assert isinstance(caller, cls)\n    return caller\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(backend)","title":"<code>backend</code>","text":"(<code>Backend | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>The backend to use for the anyio event loop (anyio.run). Defaults to the backend from where it is called.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(log)","title":"<code>log</code>","text":"(<code>LoggerAdapter | None</code>, default:                   <code>None</code> )           \u2013            <p>A logging adapter to use for debug messages.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(protected)","title":"<code>protected</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>When True, the caller will not shutdown unless shutdown is called with <code>force=True</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.start_new(backend_options)","title":"<code>backend_options</code>","text":"(<code>dict | None | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>Backend options for anyio.run. Defaults to <code>Kernel.backend_options</code>.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop","title":"stop","text":"<pre><code>stop(*, force=False) -&gt; None\n</code></pre> <p>Stop the caller, cancelling all pending tasks and close the thread.</p> <p>If the instance is protected, this is no-op unless force is used.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def stop(self, *, force=False) -&gt; None:\n    \"\"\"Stop the caller, cancelling all pending tasks and close the thread.\n\n    If the instance is protected, this is no-op unless force is used.\n    \"\"\"\n    if self._protected and not force:\n        return\n    self._stopped = True\n    self._callers_added.set()\n    self._instances.pop(self.thread, None)\n    if self in self._to_thread_pool:\n        self._to_thread_pool.remove(self)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop_all","title":"stop_all  <code>classmethod</code>","text":"<pre><code>stop_all(*, _stop_protected: bool = False) -&gt; None\n</code></pre> <p>A classmethod to stop all un-protected callers.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef stop_all(cls, *, _stop_protected: bool = False) -&gt; None:\n    \"\"\"A classmethod to stop all un-protected callers.\n\n    Args:\n        _stop_protected: A private argument to shutdown protected instances.\n    \"\"\"\n    for caller in tuple(reversed(cls._instances.values())):\n        caller.stop(force=_stop_protected)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.stop_all(_stop_protected)","title":"<code>_stop_protected</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A private argument to shutdown protected instances.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread","title":"to_thread  <code>classmethod</code>","text":"<pre><code>to_thread(\n    func: Callable[P, T | Awaitable[T]], /, *args: args, **kwargs: kwargs\n) -&gt; Future[T]\n</code></pre> <p>A classmethod to call func in a separate thread see also to_thread_by_name.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef to_thread(cls, func: Callable[P, T | Awaitable[T]], /, *args: P.args, **kwargs: P.kwargs) -&gt; Future[T]:\n    \"\"\"A classmethod to call func in a separate thread see also [to_thread_by_name][async_kernel.Caller.to_thread_by_name].\"\"\"\n    return cls.to_thread_by_name(None, func, *args, **kwargs)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name","title":"to_thread_by_name  <code>classmethod</code>","text":"<pre><code>to_thread_by_name(\n    name: str | None,\n    func: Callable[P, T | Awaitable[T]],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Future[T]\n</code></pre> <p>A classmethod to call func in the thread specified by name.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Future[T]</code>           \u2013            <p>A future that can be awaited for the  result of func.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>@classmethod\ndef to_thread_by_name(\n    cls, name: str | None, func: Callable[P, T | Awaitable[T]], /, *args: P.args, **kwargs: P.kwargs\n) -&gt; Future[T]:\n    \"\"\"A classmethod to call func in the thread specified by name.\n\n    Args:\n        name: The name of the `Caller`. A new `Caller` is created if an instance corresponding to name  [^notes].\n\n            [^notes]:  'MainThread' is special name corresponding to the main thread.\n                A `RuntimeError` will be raised if a Caller does not exist for the main thread.\n\n        func: The function to call. If it returns an awaitable, the awaitable will be awaited.\n            Passing a coroutine as `func` discourage, but will be awaited.\n\n        *args: Arguments to use with func.\n        **kwargs: Keyword arguments to use with func.\n\n    Returns:\n        A future that can be awaited for the  result of func.\n    \"\"\"\n    caller = (\n        cls._to_thread_pool.popleft()\n        if not name and cls._to_thread_pool\n        else cls.get_instance(name=name, create=True)\n    )\n    fut = caller.call_soon(func, *args, **kwargs)\n    if not name:\n        cls._pool_instances.add(caller)\n        fut.add_done_callback(caller._to_thread_on_done)\n    return fut\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(name)","title":"<code>name</code>","text":"(<code>str | None</code>)           \u2013            <p>The name of the <code>Caller</code>. A new <code>Caller</code> is created if an instance corresponding to name  <sup>1</sup>.</p> <ol> <li> <p>'MainThread' is special name corresponding to the main thread. A <code>RuntimeError</code> will be raised if a Caller does not exist for the main thread.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(func)","title":"<code>func</code>","text":"(<code>Callable[P, T | Awaitable[T]]</code>)           \u2013            <p>The function to call. If it returns an awaitable, the awaitable will be awaited. Passing a coroutine as <code>func</code> discourage, but will be awaited.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Caller.to_thread_by_name(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to use with func.</p>"},{"location":"reference/caller/#async_kernel.caller.Future","title":"Future","text":"<pre><code>Future(thread: Thread | None = None)\n</code></pre> <p>A class representing a future result modelled on Asyncio's <code>Future</code>.</p> <p>This class provides an anyio compatible Future primitive. It is designed to work with <code>Caller</code> to enable thread-safe calling, setting and awaiting execution results.</p> <p>Methods:</p> <ul> <li> <code>add_done_callback</code>             \u2013              <p>Add a callback for when the callback is done (not thread-safe).</p> </li> <li> <code>cancel</code>             \u2013              <p>Cancel the Future and schedule callbacks (thread-safe using Caller).</p> </li> <li> <code>cancelled</code>             \u2013              <p>Return True if the Future is cancelled.</p> </li> <li> <code>done</code>             \u2013              <p>Return True if the Future is done.</p> </li> <li> <code>exception</code>             \u2013              <p>Return the exception that was set on the Future.</p> </li> <li> <code>get_caller</code>             \u2013              <p>The the Caller the Future's thread corresponds.</p> </li> <li> <code>remove_done_callback</code>             \u2013              <p>Remove all instances of a callback from the callbacks list.</p> </li> <li> <code>result</code>             \u2013              <p>Wait for the result (thread-safe).</p> </li> <li> <code>set_cancel_scope</code>             \u2013              <p>Provide a cancel scope for cancellation.</p> </li> <li> <code>set_exception</code>             \u2013              <p>Set the exception (thread-safe using Caller).</p> </li> <li> <code>set_result</code>             \u2013              <p>Set the result (thread-safe using Caller).</p> </li> <li> <code>wait_sync</code>             \u2013              <p>Synchronously wait for the result.</p> </li> </ul> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def __init__(self, thread: threading.Thread | None = None) -&gt; None:\n    self._event_done = threading.Event()\n    self._exception = None\n    self._anyio_event_done = None\n    self.thread = thread or threading.current_thread()\n    self._done_callbacks = []\n    self._cancelled = False\n    self._cancel_scope: anyio.CancelScope | None = None\n    self._setting_value = False\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.add_done_callback","title":"add_done_callback","text":"<pre><code>add_done_callback(fn: Callable[[Self], object]) -&gt; None\n</code></pre> <p>Add a callback for when the callback is done (not thread-safe).</p> <p>If the Future is already done it will be scheduled for calling.</p> <p>The result of the future and done callbacks are always called for the futures thread. Callbacks are called in the reverse order in which they were added in the owning thread.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def add_done_callback(self, fn: Callable[[Self], object]) -&gt; None:\n    \"\"\"Add a callback for when the callback is done (not thread-safe).\n\n    If the Future is already done it will be scheduled for calling.\n\n    The result of the future and done callbacks are always called for the futures thread.\n    Callbacks are called in the reverse order in which they were added in the owning thread.\n    \"\"\"\n    if not self.done():\n        self._done_callbacks.append(fn)\n    else:\n        self.get_caller().call_no_context(fn, self)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.cancel","title":"cancel","text":"<pre><code>cancel() -&gt; bool\n</code></pre> <p>Cancel the Future and schedule callbacks (thread-safe using Caller).</p> <p>Returns if it has been cancelled.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def cancel(self) -&gt; bool:\n    \"\"\"Cancel the Future and schedule callbacks (thread-safe using Caller).\n\n    Returns if it has been cancelled.\n    \"\"\"\n    if not self.done():\n        self._cancelled = True\n        if scope := self._cancel_scope:\n            if threading.current_thread() is self.thread:\n                scope.cancel()\n            else:\n                Caller(thread=self.thread).call_no_context(self.cancel)\n    return self.cancelled()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Return True if the Future is cancelled.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Return True if the Future is cancelled.\"\"\"\n    return self._cancelled\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.done","title":"done","text":"<pre><code>done() -&gt; bool\n</code></pre> <p>Return True if the Future is done.</p> <p>Done means either that a result / exception is available.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"Return True if the Future is done.\n\n    Done means either that a result / exception is available.\"\"\"\n    return self._event_done.is_set()\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.exception","title":"exception","text":"<pre><code>exception() -&gt; BaseException | None\n</code></pre> <p>Return the exception that was set on the Future.</p> <p>If the Future has been cancelled, this method raises a FutureCancelledError exception.</p> <p>If the Future isn't done yet, this method raises an InvalidStateError exception.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def exception(self) -&gt; BaseException | None:\n    \"\"\"Return the exception that was set on the Future.\n\n    If the Future has been cancelled, this method raises a [FutureCancelledError][async_kernel.caller.FutureCancelledError] exception.\n\n    If the Future isn't done yet, this method raises an [InvalidStateError][async_kernel.caller.InvalidStateError] exception.\n    \"\"\"\n    if self._cancelled:\n        raise FutureCancelledError\n    if not self.done():\n        raise InvalidStateError\n    return self._exception\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.get_caller","title":"get_caller","text":"<pre><code>get_caller() -&gt; Caller\n</code></pre> <p>The the Caller the Future's thread corresponds.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def get_caller(self) -&gt; Caller:\n    \"The the Caller the Future's thread corresponds.\"\n    return Caller(thread=self.thread)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.remove_done_callback","title":"remove_done_callback","text":"<pre><code>remove_done_callback(fn: Callable[[Self], object]) -&gt; int\n</code></pre> <p>Remove all instances of a callback from the callbacks list.</p> <p>Returns the number of callbacks removed.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def remove_done_callback(self, fn: Callable[[Self], object], /) -&gt; int:\n    \"\"\"Remove all instances of a callback from the callbacks list.\n\n    Returns the number of callbacks removed.\n    \"\"\"\n    n = 0\n    while fn in self._done_callbacks:\n        n += 1\n        self._done_callbacks.remove(fn)\n    return n\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.result","title":"result  <code>async</code>","text":"<pre><code>result() -&gt; T\n</code></pre> <p>Wait for the result (thread-safe).</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>async def result(self) -&gt; T:\n    \"Wait for the result (thread-safe).\"\n    try:\n        if not self._event_done.is_set():\n            if threading.current_thread() is self.thread:\n                if not self._anyio_event_done:\n                    self._anyio_event_done = anyio.Event()\n                await self._anyio_event_done.wait()\n            else:\n                await wait_thread_event(self._event_done)\n    except anyio.get_cancelled_exc_class():\n        self.cancel()\n        raise\n    if self._exception:\n        raise self._exception\n    return self._result\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.set_cancel_scope","title":"set_cancel_scope","text":"<pre><code>set_cancel_scope(scope: CancelScope) -&gt; None\n</code></pre> <p>Provide a cancel scope for cancellation.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set_cancel_scope(self, scope: anyio.CancelScope) -&gt; None:\n    \"Provide a cancel scope for cancellation.\"\n    if self._cancelled:\n        scope.cancel()\n    self._cancel_scope = scope\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.set_exception","title":"set_exception","text":"<pre><code>set_exception(exception: BaseException) -&gt; None\n</code></pre> <p>Set the exception (thread-safe using Caller).</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set_exception(self, exception: BaseException) -&gt; None:\n    \"Set the exception (thread-safe using Caller).\"\n    self._set_value(\"exception\", exception)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.set_result","title":"set_result","text":"<pre><code>set_result(value: T) -&gt; None\n</code></pre> <p>Set the result (thread-safe using Caller).</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def set_result(self, value: T) -&gt; None:\n    \"Set the result (thread-safe using Caller).\"\n    self._set_value(\"result\", value)\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.Future.wait_sync","title":"wait_sync","text":"<pre><code>wait_sync() -&gt; T\n</code></pre> <p>Synchronously wait for the result.</p> Source code in <code>src/async_kernel/caller.py</code> <pre><code>def wait_sync(self) -&gt; T:\n    \"Synchronously wait for the result.\"\n    if threading.current_thread() is self.thread:\n        raise RuntimeError\n    self._event_done.wait()\n    if self._exception:\n        raise self._exception\n    return self._result\n</code></pre>"},{"location":"reference/caller/#async_kernel.caller.FutureCancelledError","title":"FutureCancelledError","text":"<p>Used to indicate a <code>Future</code> is cancelled.</p>"},{"location":"reference/caller/#async_kernel.caller.InvalidStateError","title":"InvalidStateError","text":"<p>An invalid state of a Future.</p>"},{"location":"reference/command/","title":"Command","text":""},{"location":"reference/command/#command","title":"Command","text":"<p><code>async-kernel</code> is installed at the command prompt. You can use it to:</p> <ul> <li>Launch a kernel manually</li> <li>Define a new kernel spec</li> <li>Remove an existing kernel spec</li> </ul>"},{"location":"reference/command/#async_kernel.command","title":"async_kernel.command","text":"<p>Functions:</p> <ul> <li> <code>command_line</code>             \u2013              <p>Parses command-line arguments to manage and start kernels.</p> </li> <li> <code>setattr_nested</code>             \u2013              <p>Set a nested attribute of an object.</p> </li> </ul>"},{"location":"reference/command/#async_kernel.command.command_line","title":"command_line","text":"<pre><code>command_line(wait_exit_context: Callable[[], Awaitable] = sleep_forever) -&gt; None\n</code></pre> <p>Parses command-line arguments to manage and start kernels.</p> <p>This function uses <code>argparse</code> to handle command-line arguments for various kernel operations, including:</p> <ul> <li>Starting a kernel with a specified connection file.</li> <li>Adding a new kernel specification.</li> <li>Removing an existing kernel specification.</li> </ul> <p>The function determines the appropriate action based on the provided arguments and either starts a kernel, adds a kernel spec, or removes a kernel spec.  If no connection file is provided and no other action is specified, it prints the help message.</p> <p>When starting a kernel, it imports the specified kernel factory (or uses the default <code>Kernel</code> class) and configures the kernel instance with the provided arguments. It then starts the kernel within an <code>anyio</code> context, handling keyboard interrupts and other exceptions.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>If an error occurs during kernel execution or if the program is interrupted.</p> </li> </ul> Source code in <code>src/async_kernel/command.py</code> <pre><code>def command_line(wait_exit_context: Callable[[], Awaitable] = anyio.sleep_forever) -&gt; None:\n    \"\"\"Parses command-line arguments to manage and start kernels.\n\n    This function uses `argparse` to handle command-line arguments for\n    various kernel operations, including:\n\n    - Starting a kernel with a specified connection file.\n    - Adding a new kernel specification.\n    - Removing an existing kernel specification.\n\n    The function determines the appropriate action based on the provided\n    arguments and either starts a kernel, adds a kernel spec, or removes\n    a kernel spec.  If no connection file is provided and no other action\n    is specified, it prints the help message.\n\n    When starting a kernel, it imports the specified kernel factory (or uses\n    the default `Kernel` class) and configures the kernel instance with\n    the provided arguments. It then starts the kernel within an `anyio`\n    context, handling keyboard interrupts and other exceptions.\n\n    Args:\n        wait_exit_context: An optional asynchronous function or context manager\n            that determines how long the kernel should run. Defaults to\n            `anyio.sleep_forever`, which keeps the kernel running indefinitely\n            until an external signal is received.\n\n    Raises:\n        SystemExit: If an error occurs during kernel execution or if the\n            program is interrupted.\n    \"\"\"\n    kernel_dir: Path = get_kernel_dir()\n    parser = argparse.ArgumentParser(\n        description=\"Kernel interface to start a kernel or add/remove a kernel spec. \"\n        + f\"The Jupyter Kernel directory is: f'{kernel_dir}'\"\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--file\",\n        dest=\"connection_file\",\n        help=\"Start a Kernel with a connection file. To start a Kernel without a file use a period `.`.\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--add\",\n        dest=\"add\",\n        help=f\"Add a kernel spec. Default kernel names are: {list(map(str, KernelName))}.\\n\"\n        + \"To specify a 'trio' backend, include 'trio' in the name. Other options are also permitted. See: `write_kernel_spec` for detail.\",\n    )\n    kernels = [] if not kernel_dir.exists() else [item.name for item in kernel_dir.iterdir() if item.is_dir()]\n    parser.add_argument(\n        \"-r\",\n        \"--remove\",\n        dest=\"remove\",\n        help=f\"remove existing kernel specs. Installed kernels: {kernels}\",\n    )\n\n    args, unknownargs = parser.parse_known_args()\n    for k, v in pairwise(unknownargs):\n        if k.startswith(\"--\"):\n            setattr(args, k.removeprefix(\"--\"), v)\n    if args.add:\n        if not hasattr(args, \"kernel_name\"):\n            args.kernel_name = args.add\n        for name in [\"add\", \"remove\"] + ([\"connection_file\"] if args.connection_file is None else []):\n            delattr(args, name)\n        path = write_kernel_spec(**vars(args))\n        print(f\"Added kernel spec {path!s}\")\n    elif args.remove:\n        for name in args.remove.split(\",\"):\n            folder = kernel_dir / str(name)\n            if folder.exists():\n                shutil.rmtree(folder, ignore_errors=True)\n                print(f\"Removed kernel spec: {name}\")\n            else:\n                print(f\"Kernel spec folder: '{name}' not found!\")\n\n    elif not args.connection_file:\n        parser.print_help()\n    else:\n        kernel_factory = getattr(args, \"kernel_factory\", None)\n        kernel_name: str = getattr(args, \"kernel_name\", None) or KernelName.asyncio\n        factory: type[Kernel] = traitlets.import_item(kernel_factory) if kernel_factory else Kernel\n        kernel = factory(kernel_name=kernel_name)\n        for k, v in vars(args).items():\n            if (k == \"connection_file\" and v == \".\") or k in [\"add\", \"remove\"]:\n                continue\n            setattr_nested(kernel, k, v)\n\n        async def _start() -&gt; None:\n            print(\"Starting kernel\")\n            async with kernel.start_in_context():\n                with contextlib.suppress(kernel.CancelledError):\n                    await wait_exit_context()\n\n        try:\n            backend = Backend.trio if \"trio\" in kernel_name.lower() else Backend.asyncio\n            anyio.run(_start, backend=backend, backend_options=kernel.anyio_backend_options.get(backend))\n        except KeyboardInterrupt:\n            pass\n        except BaseException as e:\n            traceback.print_exception(e, file=sys.stderr)\n            if sys.__stderr__ is not sys.stderr:\n                traceback.print_exception(e, file=sys.__stderr__)\n            sys.exit(1)\n        else:\n            sys.exit(0)\n        finally:\n            print(\"Kernel stopped: \", kernel.connection_file)\n</code></pre>"},{"location":"reference/command/#async_kernel.command.command_line(wait_exit_context)","title":"<code>wait_exit_context</code>","text":"(<code>Callable[[], Awaitable]</code>, default:                   <code>sleep_forever</code> )           \u2013            <p>An optional asynchronous function or context manager that determines how long the kernel should run. Defaults to <code>anyio.sleep_forever</code>, which keeps the kernel running indefinitely until an external signal is received.</p>"},{"location":"reference/command/#async_kernel.command.setattr_nested","title":"setattr_nested","text":"<pre><code>setattr_nested(obj: object, name: str, value: str | Any) -&gt; None\n</code></pre> <p>Set a nested attribute of an object.</p> <p>If the attribute name contains dots, it is interpreted as a nested attribute. For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.</p> <p>This is primarily intended for use with async_kernel.command.command_line to set the nesteded attributes on on kernels.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/command.py</code> <pre><code>def setattr_nested(obj: object, name: str, value: str | Any) -&gt; None:\n    \"\"\"Set a nested attribute of an object.\n\n    If the attribute name contains dots, it is interpreted as a nested attribute.\n    For example, if name is \"a.b.c\", then the code will attempt to set obj.a.b.c to value.\n\n    This is primarily intended for use with [async_kernel.command.command_line][]\n    to set the nesteded attributes on on kernels.\n\n    Args:\n        obj: The object to set the attribute on.\n        name: The name of the attribute to set.\n        value: The value to set the attribute to.\n    \"\"\"\n    if len(bits := name.split(\".\")) &gt; 1:\n        try:\n            obj = getattr(obj, bits[0])\n        except Exception:\n            return\n        setattr_nested(obj, \".\".join(bits[1:]), value)\n    if (isinstance(obj, traitlets.HasTraits) and obj.has_trait(name)) or hasattr(obj, name):\n        try:\n            setattr(obj, name, value)\n        except Exception:\n            setattr(obj, name, eval(value))\n</code></pre>"},{"location":"reference/command/#async_kernel.command.setattr_nested(obj)","title":"<code>obj</code>","text":"(<code>object</code>)           \u2013            <p>The object to set the attribute on.</p>"},{"location":"reference/command/#async_kernel.command.setattr_nested(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The name of the attribute to set.</p>"},{"location":"reference/command/#async_kernel.command.setattr_nested(value)","title":"<code>value</code>","text":"(<code>str | Any</code>)           \u2013            <p>The value to set the attribute to.</p>"},{"location":"reference/kernel/","title":"Kernel","text":""},{"location":"reference/kernel/#async_kernel.kernel","title":"async_kernel.kernel","text":"<p>Classes:</p> <ul> <li> <code>Kernel</code>           \u2013            <p>An asynchronous kernel with an anyio backend providing an IPython AsyncInteractiveShell with zmq sockets.</p> </li> <li> <code>KernelInterruptError</code>           \u2013            <p>Raised to interrupt the kernel.</p> </li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel","title":"Kernel","text":"<pre><code>Kernel(**kwargs)\n</code></pre> <p>An asynchronous kernel with an anyio backend providing an IPython AsyncInteractiveShell with zmq sockets.</p> <p>Only one instance will be created/run at a time. The instance can be obtained with <code>Kernel()</code>.</p> <p>To start the kernel:</p> ShellNormalstart (<code>classmethod</code>)Asynchronously inside anyio event loop <p>At the command prompt.</p> <pre><code>async-kernel -f .\n</code></pre> <p>See also:</p> <p>-</p> <pre><code>from async_kernel.__main__ import main\n\nmain()\n</code></pre> <pre><code>Kernel.start()\n</code></pre> <pre><code>kernel = Kernel()\nasync with kernel.start_in_context():\n    await anyio.sleep_forever()\n</code></pre> Tip <p>This is a convenient way to start a kernel for debugging.</p> <p>Origins: IPyKernel Kernel, IPyKernel IPKernelApp &amp;  IPyKernel IPythonKernel</p> <p>Methods:</p> <ul> <li> <code>all_concurrency_run_modes</code>             \u2013              <p>Generates a dictionary containing all combinations of SocketID, KernelConcurrencyMode, and MsgType,</p> </li> <li> <code>comm_close</code>             \u2013              <p>Handle a comm close request.</p> </li> <li> <code>comm_info_request</code>             \u2013              <p>Handle a comm info request.</p> </li> <li> <code>comm_msg</code>             \u2013              <p>Handle a comm msg request.</p> </li> <li> <code>comm_open</code>             \u2013              <p>Handle a comm open request.</p> </li> <li> <code>complete_request</code>             \u2013              <p>Handle a completion request.</p> </li> <li> <code>debug_request</code>             \u2013              <p>Handle a debug request (control only).</p> </li> <li> <code>excepthook</code>             \u2013              <p>Handle an exception.</p> </li> <li> <code>execute_request</code>             \u2013              <p>Handle a execute request.</p> </li> <li> <code>get_run_mode</code>             \u2013              <p>Determine the run mode for a given channel, message type and concurrency mode.</p> </li> <li> <code>getpass</code>             \u2013              <p>Forward getpass to frontends.</p> </li> <li> <code>handle_message_request</code>             \u2013              <p>The main handler for all shell and control messages.</p> </li> <li> <code>history_request</code>             \u2013              <p>Handle a history request.</p> </li> <li> <code>inspect_request</code>             \u2013              <p>Handle a inspect request.</p> </li> <li> <code>interrupt_request</code>             \u2013              <p>Handle a interrupt request (control only).</p> </li> <li> <code>iopub_send</code>             \u2013              <p>Send a message on the zmq iopub socket.</p> </li> <li> <code>is_complete_request</code>             \u2013              <p>Handle a is_complete request.</p> </li> <li> <code>kernel_info_request</code>             \u2013              <p>Handle a kernel info request.</p> </li> <li> <code>raw_input</code>             \u2013              <p>Forward raw_input to frontends.</p> </li> <li> <code>run_handler</code>             \u2013              <p>Runs the handler in the context of the job/message sending the reply content if it is provided.</p> </li> <li> <code>shutdown_request</code>             \u2013              <p>Handle a shutdown request (control only).</p> </li> <li> <code>start_in_context</code>             \u2013              <p>Start the Kernel in an already running anyio event loop.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the kernel.</p> </li> <li> <code>topic</code>             \u2013              <p>prefixed topic for IOPub messages</p> </li> <li> <code>unraisablehook</code>             \u2013              <p>Handle unraisable exceptions (during gc for instance).</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>anyio_backend</code>           \u2013            </li> <li> <code>anyio_backend_options</code>               (<code>Dict[Backend, dict[str, Any] | None]</code>)           \u2013            <p>Default options to use with anyio.run. See also: <code>Kernel.handle_message_request</code></p> </li> <li> <code>comm_manager</code>               (<code>Instance[CommManager]</code>)           \u2013            </li> <li> <code>concurrency_mode</code>           \u2013            <p>The mode to use when getting the run mode for running the handler of a message request.</p> </li> <li> <code>debugger</code>           \u2013            </li> <li> <code>execution_count</code>               (<code>int</code>)           \u2013            <p>The execution count in context of the current coroutine, else the current value if there isn't one in context.</p> </li> <li> <code>help_links</code>           \u2013            </li> <li> <code>log</code>           \u2013            </li> <li> <code>quiet</code>           \u2013            </li> <li> <code>session</code>           \u2013            </li> <li> <code>shell</code>           \u2013            </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    if self._initialised:\n        return  # Only initialize once\n    self._initialised = True\n    super().__init__(**kwargs)\n    sys.excepthook = self.excepthook\n    sys.unraisablehook = self.unraisablehook\n    signal.signal(signal.SIGINT, self._signal_handler)\n    if not os.environ.get(\"MPLBACKEND\"):\n        os.environ[\"MPLBACKEND\"] = \"module://matplotlib_inline.backend_inline\"\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.anyio_backend","title":"anyio_backend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anyio_backend = UseEnum(Backend)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.anyio_backend_options","title":"anyio_backend_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anyio_backend_options: Dict[Backend, dict[str, Any] | None] = Dict(allow_none=True)\n</code></pre> <p>Default options to use with anyio.run. See also: <code>Kernel.handle_message_request</code></p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_manager","title":"comm_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_manager: Instance[CommManager] = Instance('async_kernel.comm.CommManager')\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.concurrency_mode","title":"concurrency_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>concurrency_mode = UseEnum(KernelConcurrencyMode)\n</code></pre> <p>The mode to use when getting the run mode for running the handler of a message request.</p> See also <ul> <li>async_kernel.Kernel.handle_message_request</li> </ul>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debugger","title":"debugger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debugger = Instance(Debugger, ())\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execution_count","title":"execution_count  <code>property</code>","text":"<pre><code>execution_count: int\n</code></pre> <p>The execution count in context of the current coroutine, else the current value if there isn't one in context.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.help_links","title":"help_links  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help_links = Tuple()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log = Instance(LoggerAdapter)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.quiet","title":"quiet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quiet = CBool(True, help='Only send stdout/stderr to output stream')\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session = Instance(Session)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = Instance(AsyncInteractiveShell)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.all_concurrency_run_modes","title":"all_concurrency_run_modes","text":"<pre><code>all_concurrency_run_modes(\n    socket_ids: Iterable[Literal[shell, control]] = (shell, control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"KernelConcurrencyMode\", \"MsgType\", \"RunMode\"],\n    tuple[SocketID, KernelConcurrencyMode, MsgType, RunMode | None],\n]\n</code></pre> <p>Generates a dictionary containing all combinations of SocketID, KernelConcurrencyMode, and MsgType, along with their corresponding RunMode (if available).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def all_concurrency_run_modes(\n    self,\n    socket_ids: Iterable[Literal[SocketID.shell, SocketID.control]] = (SocketID.shell, SocketID.control),\n    msg_types: Iterable[MsgType] = MsgType,\n) -&gt; dict[\n    Literal[\"SocketID\", \"KernelConcurrencyMode\", \"MsgType\", \"RunMode\"],\n    tuple[SocketID, KernelConcurrencyMode, MsgType, RunMode | None],\n]:\n    \"\"\"Generates a dictionary containing all combinations of SocketID, KernelConcurrencyMode, and MsgType,\n    along with their corresponding RunMode (if available).\"\"\"\n    data: list[Any] = []\n    for socket_id in socket_ids:\n        for concurrency_mode in KernelConcurrencyMode:\n            for msg_type in msg_types:\n                try:\n                    mode = self.get_run_mode(msg_type, socket_id=socket_id, concurrency_mode=concurrency_mode)\n                except ValueError:\n                    mode = None\n                data.append((socket_id, concurrency_mode, msg_type, mode))\n    data_ = zip(*data, strict=True)\n    return dict(zip([\"SocketID\", \"KernelConcurrencyMode\", \"MsgType\", \"RunMode\"], data_, strict=True))\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_close","title":"comm_close  <code>async</code>","text":"<pre><code>comm_close(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm close request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_close(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm close request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#tearing-down-comms).\"\"\"\n    self.comm_manager.comm_close(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_info_request","title":"comm_info_request  <code>async</code>","text":"<pre><code>comm_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a comm info request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [comm info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-info).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    target_name = c.get(\"target_name\", None)\n    comms = {\n        k: {\"target_name\": v.target_name}\n        for (k, v) in tuple(self.comm_manager.comms.items())\n        if v.target_name == target_name or target_name is None\n    }\n    return {\"comms\": comms}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_msg","title":"comm_msg  <code>async</code>","text":"<pre><code>comm_msg(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm msg request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_msg(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm msg request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#comm-messages).\"\"\"\n    self.comm_manager.comm_msg(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.comm_open","title":"comm_open  <code>async</code>","text":"<pre><code>comm_open(job: Job[Content]) -&gt; None\n</code></pre> <p>Handle a comm open request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def comm_open(self, job: Job[Content], /) -&gt; None:\n    \"\"\"Handle a [comm open request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#opening-a-comm).\"\"\"\n    self.comm_manager.comm_open(stream=job[\"socket\"], ident=job[\"ident\"], msg=job[\"msg\"])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.complete_request","title":"complete_request  <code>async</code>","text":"<pre><code>complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a completion request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [completion request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#completion).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    code: str = c[\"code\"]\n    cursor_pos = c.get(\"cursor_pos\") or len(code)\n    with _provisionalcompleter():\n        completions = list(_rectify_completions(code, self.shell.Completer.completions(code, cursor_pos)))\n    comps = [\n        {\n            \"start\": comp.start,\n            \"end\": comp.end,\n            \"text\": comp.text,\n            \"type\": comp.type,\n            \"signature\": comp.signature,\n        }\n        for comp in completions\n    ]\n    s, e = completions[0].start, completions[0].end if completions else (cursor_pos, cursor_pos)\n    matches = [c.text for c in completions]\n    return {\n        \"matches\": matches,\n        \"cursor_end\": e,\n        \"cursor_start\": s,\n        \"metadata\": {\"_jupyter_types_experimental\": comps},\n    }\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.debug_request","title":"debug_request  <code>async</code>","text":"<pre><code>debug_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a debug request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def debug_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [debug request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#debug-request) (control only).\"\"\"\n    return await self.debugger.process_request(job[\"msg\"][\"content\"])\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.excepthook","title":"excepthook","text":"<pre><code>excepthook(etype, evalue, tb) -&gt; None\n</code></pre> <p>Handle an exception.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def excepthook(self, etype, evalue, tb) -&gt; None:\n    \"\"\"Handle an exception.\"\"\"\n    # write uncaught traceback to 'real' stderr, not zmq-forwarder\n    traceback.print_exception(etype, evalue, tb, file=sys.__stderr__)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.execute_request","title":"execute_request  <code>async</code>","text":"<pre><code>execute_request(job: Job[ExecuteContent]) -&gt; Content\n</code></pre> <p>Handle a execute request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def execute_request(self, job: Job[ExecuteContent], /) -&gt; Content:\n    \"\"\"Handle a [execute request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#execute).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    if (\n        job[\"run_mode\"] is RunMode.queue\n        and (job[\"received_time\"] &lt; self._stop_on_error_time)\n        and not c.get(\"silent\", False)\n    ):\n        self.log.info(\"Aborting execute_request: %s\", job)\n        return error_to_content(RuntimeError(\"Aborting due to prior exception\")) | {\n            \"execution_count\": self.execution_count\n        }\n    metadata = job[\"msg\"].get(\"metadata\") or {}\n    if not (silent := c[\"silent\"]):\n        self._execution_count += 1\n        utils._execution_count_var.set(self._execution_count)  # pyright: ignore[reportPrivateUsage]\n        self.iopub_send(\n            msg_or_type=\"execute_input\",\n            content={\"code\": c[\"code\"], \"execution_count\": self.execution_count},\n            parent=job[\"msg\"],\n            ident=self.topic(\"execute_input\"),\n        )\n    fut = (Caller.to_thread if job[\"run_mode\"] is RunMode.thread else Caller().call_soon)(\n        self.shell.run_cell_async,\n        raw_cell=c[\"code\"],\n        store_history=c.get(\"store_history\", False),\n        silent=silent,\n        transformed_cell=self.shell.transform_cell(c[\"code\"]),\n        shell_futures=True,\n        cell_id=metadata.get(\"cellId\"),\n    )\n    if not silent:\n        self._interrupts.add(fut.cancel)\n        fut.add_done_callback(lambda fut: self._interrupts.discard(fut.cancel))\n    try:\n        result: ExecutionResult = await fut\n        err = result.error_before_exec or result.error_in_exec if result else KernelInterruptError()\n    except Exception as e:\n        # A safeguard to catch exceptions not caught by the shell.\n        err = e\n    if (err) and (\n        (Tags.suppress_error in metadata.get(\"tags\", ()))  # 1.\n        or (isinstance(err, self.CancelledError) and (utils.get_execute_request_timeout() is not None))  # 2.\n    ):\n        # Suppress the error due to either:\n        # 1. tag\n        # 2. timeout\n        err = None\n    content = {\n        \"status\": \"error\" if err else \"ok\",\n        \"execution_count\": self.execution_count,\n        \"user_expressions\": self.shell.user_expressions(c.get(\"user_expressions\", {})),\n    }\n    if err:\n        content |= error_to_content(err)\n        if (not silent) and c.get(\"stop_on_error\"):\n            try:\n                self._stop_on_error_time = math.inf\n                self.log.info(\"An error occurred in a non-silent execution request\")\n                await anyio.sleep(0)\n            finally:\n                self._stop_on_error_time = time.monotonic()\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode","title":"get_run_mode","text":"<pre><code>get_run_mode(\n    msg_type: MsgType,\n    *,\n    socket_id: Literal[shell, control] = shell,\n    concurrency_mode: KernelConcurrencyMode | NoValue = NoValue,\n    job: Job | None = None,\n) -&gt; RunMode\n</code></pre> <p>Determine the run mode for a given channel, message type and concurrency mode.</p> <p>The run mode determines how the kernel will execute the message.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RunMode</code>           \u2013            <p>The run mode for the message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a shutdown or debug request is received on the shell socket.</p> </li> </ul> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def get_run_mode(\n    self,\n    msg_type: MsgType,\n    *,\n    socket_id: Literal[SocketID.shell, SocketID.control] = SocketID.shell,\n    concurrency_mode: KernelConcurrencyMode | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    job: Job | None = None,\n) -&gt; RunMode:\n    \"\"\"Determine the run mode for a given channel, message type and concurrency mode.\n\n    The run mode determines how the kernel will execute the message.\n\n    Args:\n        socket_id: The socket ID the message was received on.\n        msg_type: The type of the message.\n        concurrency_mode: The concurrency mode of the kernel. Defaults to [kernel.concurrency_mode][async_kernel.Kernel.concurrency_mode]\n        job: The job associated with the message, if any.\n\n    Returns:\n        The run mode for the message.\n\n    Raises:\n        ValueError: If a shutdown or debug request is received on the shell socket.\n    \"\"\"\n\n    concurrency_mode = self.concurrency_mode if concurrency_mode is NoValue else concurrency_mode\n    # TODO: Are any of these options worth including?\n    # if mode_from_metadata := job[\"msg\"][\"metadata\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_metadata)\n    # if mode_from_header := job[\"msg\"][\"header\"].get(\"run_mode\"):\n    #     return RunMode( mode_from_header)\n    match (concurrency_mode, socket_id, msg_type):\n        case KernelConcurrencyMode.blocking, _, _:\n            return RunMode.blocking\n        case _, SocketID.control, MsgType.execute_request:\n            return RunMode.task\n        case _, _, MsgType.execute_request:\n            if job:\n                if content := job[\"msg\"].get(\"content\", {}):\n                    if (code := content.get(\"code\")) and (mode_ := RunMode.get_mode(code)):\n                        return mode_\n                    if content.get(\"silent\"):\n                        return RunMode.task\n                if mode_ := set(utils.get_tags(job)).intersection(RunMode):\n                    return RunMode(next(iter(mode_)))\n            return RunMode.queue\n        case _, SocketID.shell, MsgType.shutdown_request | MsgType.debug_request:\n            msg = f\"{msg_type=} not allowed on shell!\"\n            raise ValueError(msg)\n        case _, _, MsgType.inspect_request | MsgType.complete_request | MsgType.is_complete_request:\n            return RunMode.thread\n        case _, _, MsgType.history_request:\n            return RunMode.thread\n        case _, _, MsgType.kernel_info_request | MsgType.comm_info_request | MsgType.comm_open | MsgType.comm_close:\n            return RunMode.blocking\n        case _:\n            return RunMode.task\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(socket_id)","title":"<code>socket_id</code>","text":"(<code>Literal[shell, control]</code>, default:                   <code>shell</code> )           \u2013            <p>The socket ID the message was received on.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(msg_type)","title":"<code>msg_type</code>","text":"(<code>MsgType</code>)           \u2013            <p>The type of the message.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(concurrency_mode)","title":"<code>concurrency_mode</code>","text":"(<code>KernelConcurrencyMode | NoValue</code>, default:                   <code>NoValue</code> )           \u2013            <p>The concurrency mode of the kernel. Defaults to kernel.concurrency_mode</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.get_run_mode(job)","title":"<code>job</code>","text":"(<code>Job | None</code>, default:                   <code>None</code> )           \u2013            <p>The job associated with the message, if any.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.getpass","title":"getpass","text":"<pre><code>getpass(prompt='') -&gt; Any\n</code></pre> <p>Forward getpass to frontends.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def getpass(self, prompt=\"\") -&gt; Any:\n    \"\"\"Forward getpass to frontends.\"\"\"\n    return self._input_request(prompt, password=True)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.handle_message_request","title":"handle_message_request  <code>async</code>","text":"<pre><code>handle_message_request(job: Job) -&gt; None\n</code></pre> <p>The main handler for all shell and control messages.</p> <p>Parameters:</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def handle_message_request(self, job: Job, /) -&gt; None:\n    \"\"\"The main handler for all shell and control messages.\n\n    Args:\n        job: The packed [message][async_kernel.typing.Message] for handling.\n    \"\"\"\n    try:\n        msg_type = MsgType(job[\"msg\"][\"header\"][\"msg_type\"])\n        socket_id = job[\"socket_id\"]\n        handler = self.get_handler(msg_type)\n    except (ValueError, TypeError):\n        self.log.debug(\"Invalid job %s\", job)\n        return\n    run_mode = self.get_run_mode(msg_type, socket_id=socket_id, job=job)\n    self.log.debug(\"%s  %s run mode %s handler: %s\", socket_id, msg_type, run_mode, handler)\n    job[\"run_mode\"] = run_mode\n    runner = _wrap_handler(self.run_handler, handler)\n    match run_mode:\n        case RunMode.queue:\n            await Caller().queue_call(runner, job, send_nowait=False)\n        case RunMode.thread:\n            Caller.to_thread(runner, job)\n        case RunMode.task:\n            Caller().call_soon(runner, job)\n        case RunMode.blocking:\n            await runner(job)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.handle_message_request(job)","title":"<code>job</code>","text":"(<code>Job</code>)           \u2013            <p>The packed message for handling.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.history_request","title":"history_request  <code>async</code>","text":"<pre><code>history_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a history request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def history_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [history request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#history).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    history_manager = self.shell.history_manager\n    assert history_manager\n    if c.get(\"hist_access_type\") == \"tail\":\n        hist = history_manager.get_tail(c[\"n\"], raw=c.get(\"raw\"), output=c.get(\"output\"), include_latest=True)\n    elif c.get(\"hist_access_type\") == \"range\":\n        hist = history_manager.get_range(\n            c.get(\"session\"), c.get(\"start\"), c.get(\"stop\"), raw=c.get(\"raw\"), output=c.get(\"output\")\n        )\n    elif c.get(\"hist_access_type\") == \"search\":\n        hist = history_manager.search(\n            c.get(\"pattern\"), raw=c.get(\"raw\"), output=c.get(\"output\"), n=c.get(\"n\"), unique=c.get(\"unique\")\n        )\n    else:\n        hist = []\n    return {\"history\": list(hist)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.inspect_request","title":"inspect_request  <code>async</code>","text":"<pre><code>inspect_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a inspect request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def inspect_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [inspect request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#introspection).\"\"\"\n    c = job[\"msg\"][\"content\"]\n    detail_level = int(c.get(\"detail_level\", 0))\n    omit_sections = set(c.get(\"omit_sections\", []))\n    name = token_at_cursor(c[\"code\"], c[\"cursor_pos\"])\n    content: dict[str, Any] = {\"status\": \"ok\"}\n    content[\"data\"] = {}\n    content[\"metadata\"] = {}\n    try:\n        bundle = self.shell.object_inspect_mime(name, detail_level=detail_level, omit_sections=omit_sections)\n        content[\"data\"].update(bundle)\n        if not self.shell.enable_html_pager:\n            content[\"data\"].pop(\"text/html\")\n        content[\"found\"] = True\n    except KeyError:\n        content[\"found\"] = False\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.interrupt_request","title":"interrupt_request  <code>async</code>","text":"<pre><code>interrupt_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a interrupt request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def interrupt_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [interrupt request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-interrupt) (control only).\"\"\"\n    self._interrupt_requested = True\n    if sys.platform == \"win32\":\n        signal.raise_signal(signal.SIGINT)\n        time.sleep(0)\n    else:\n        os.kill(os.getpid(), signal.SIGINT)\n    for interrupter in tuple(self._interrupts):\n        interrupter()\n    return {}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.iopub_send","title":"iopub_send","text":"<pre><code>iopub_send(\n    msg_or_type: dict[str, Any] | str,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | None | NoValue = NoValue,\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None\n</code></pre> <p>Send a message on the zmq iopub socket.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def iopub_send(\n    self,\n    msg_or_type: dict[str, Any] | str,\n    content: Content | None = None,\n    metadata: dict[str, Any] | None = None,\n    parent: dict[str, Any] | None | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n    ident: bytes | list[bytes] | None = None,\n    buffers: list[bytes] | None = None,\n) -&gt; None:\n    \"\"\"Send a message on the zmq iopub socket.\"\"\"\n    if socket := Caller.iopub_sockets.get(thread := threading.current_thread()):\n        msg = self.session.send(\n            stream=socket,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else utils.get_parent(),  # pyright: ignore[reportArgumentType]\n            ident=ident,\n            buffers=buffers,\n        )\n        if msg:\n            self.log.debug(\n                \"iopub_send: (thread=%s) msg_type:'%s', content: %s\", thread.name, msg[\"msg_type\"], msg[\"content\"]\n            )\n    else:\n        self.control_thread_caller.call_no_context(\n            self.iopub_send,\n            msg_or_type=msg_or_type,\n            content=content,\n            metadata=metadata,\n            parent=parent if parent is not NoValue else None,\n            ident=ident,\n            buffers=buffers,\n        )\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.is_complete_request","title":"is_complete_request  <code>async</code>","text":"<pre><code>is_complete_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a is_complete request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def is_complete_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [is_complete request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-completeness).\"\"\"\n    status, indent_spaces = self.shell.input_transformer_manager.check_complete(job[\"msg\"][\"content\"][\"code\"])\n    content = {\"status\": status}\n    if status == \"incomplete\":\n        content[\"indent\"] = \" \" * indent_spaces\n    return content\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.kernel_info_request","title":"kernel_info_request  <code>async</code>","text":"<pre><code>kernel_info_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a kernel info request.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def kernel_info_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a ke[rnel info request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-info).\"\"\"\n    return self.kernel_info\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.raw_input","title":"raw_input","text":"<pre><code>raw_input(prompt='') -&gt; Any\n</code></pre> <p>Forward raw_input to frontends.</p>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.raw_input--raises","title":"Raises","text":"<p>StdinNotImplementedError if active frontend doesn't support stdin.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def raw_input(self, prompt=\"\") -&gt; Any:\n    \"\"\"Forward raw_input to frontends.\n\n    Raises\n    ------\n    StdinNotImplementedError if active frontend doesn't support stdin.\n    \"\"\"\n    return self._input_request(str(prompt), password=False)\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.run_handler","title":"run_handler  <code>async</code>","text":"<pre><code>run_handler(handler: HandlerType, job: Job[dict]) -&gt; None\n</code></pre> <p>Runs the handler in the context of the job/message sending the reply content if it is provided.</p> <p>This method gets called for every valid request with the relevant handler.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def run_handler(self, handler: HandlerType, job: Job[dict]) -&gt; None:\n    \"\"\"Runs the handler in the context of the job/message sending the reply content if it is provided.\n\n    This method gets called for every valid request with the relevant handler.\n    \"\"\"\n\n    def _send_reply(content: dict, /) -&gt; None:\n        \"\"\"Send a reply to the job with the specified content.\"\"\"\n        if \"status\" not in content:\n            content[\"status\"] = \"ok\"\n        msg = self.session.send(\n            stream=job[\"socket\"],\n            msg_or_type=job[\"msg\"][\"header\"][\"msg_type\"].replace(\"request\", \"reply\"),\n            content=content,\n            parent=job[\"msg\"][\"header\"],  # pyright: ignore[reportArgumentType]\n            ident=job[\"ident\"],\n        )\n        if msg:\n            self.log.debug(\"*** _send_reply %s*** %s\", job[\"socket_id\"], msg)\n\n    utils._job_var.set(job)  # pyright: ignore[reportPrivateUsage]\n    try:\n        self.iopub_send(msg_or_type=\"status\", content={\"execution_state\": \"busy\"}, ident=self.topic(\"status\"))\n        if (content := await handler(job)) is not None:\n            _send_reply(content)\n    except Exception as e:\n        _send_reply(error_to_content(e))\n        self.log.exception(\"Exception in message handler:\", exc_info=e)\n    finally:\n        self.iopub_send(msg_or_type=\"status\", content={\"execution_state\": \"idle\"}, ident=self.topic(\"status\"))\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.shutdown_request","title":"shutdown_request  <code>async</code>","text":"<pre><code>shutdown_request(job: Job[Content]) -&gt; Content\n</code></pre> <p>Handle a shutdown request (control only).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>async def shutdown_request(self, job: Job[Content], /) -&gt; Content:\n    \"\"\"Handle a [shutdown request](https://jupyter-client.readthedocs.io/en/stable/messaging.html#kernel-shutdown) (control only).\"\"\"\n    await self.debugger.disconnect()\n    Caller().call_no_context(self.stop)\n    return {\"status\": \"ok\", \"restart\": job[\"msg\"][\"content\"].get(\"restart\", False)}\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.start_in_context","title":"start_in_context  <code>async</code>","text":"<pre><code>start_in_context() -&gt; AsyncGenerator[Self, Any]\n</code></pre> <p>Start the Kernel in an already running anyio event loop.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>@asynccontextmanager\nasync def start_in_context(self) -&gt; AsyncGenerator[Self, Any]:\n    \"\"\"Start the Kernel in an already running anyio event loop.\"\"\"\n    if self._sockets:\n        msg = \"Already started\"\n        raise RuntimeError(msg)\n    self.CancelledError = anyio.get_cancelled_exc_class()\n    self.anyio_backend = sniffio.current_async_library()\n    if self.connection_file and Path(self.connection_file).exists():\n        self.load_connection_file()\n    try:\n        async with Caller(log=self.log, create=True, protected=True) as caller:\n            tg = caller._taskgroup  # pyright: ignore[reportPrivateUsage]\n            assert tg\n            await tg.start(self._wait_stopped)\n            try:\n                await tg.start(self._start_heartbeat)\n                await tg.start(self._start_stdin)\n                await tg.start(self._start_iopub_proxy)\n                await tg.start(self._start_control_loop)\n                await tg.start(self._receive_msg_loop, SocketID.shell)\n                assert len(self._sockets) == len(SocketID)\n                if not self.connection_file:\n                    self.connection_file = str(Path(jupyter_runtime_dir()).joinpath(f\"kernel-{uuid.uuid4()}.json\"))\n                pathlib.Path(self.connection_file).parent.mkdir(parents=True, exist_ok=True)\n                self.write_connection_file()\n                atexit.register(self.cleanup_connection_file)\n                print(\n                    f\"\"\"Kernel started with backend: {self.anyio_backend}. To connect a client use: --existing \"{self.connection_file}\" \"\"\"\n                )\n                await tg.start(self._start_iopub)\n                yield self\n            finally:\n                self.stop()\n    finally:\n        AsyncInteractiveShell.clear_instance()\n        Context.instance().term()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.stop","title":"stop  <code>classmethod</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the kernel.</p> <p>Once a kernel is stopped; that instance of the kernel cannot be restarted. Instead, a new kernel must be started.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>@classmethod\ndef stop(cls) -&gt; None:\n    \"\"\"Stop the kernel.\n\n    Once a kernel is stopped; that instance of the kernel cannot be restarted.\n    Instead, a new kernel must be started.\n    \"\"\"\n    if instance := cls._instance:\n        cls._instance = None\n        instance._stop_event.set()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.topic","title":"topic","text":"<pre><code>topic(topic) -&gt; bytes\n</code></pre> <p>prefixed topic for IOPub messages</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def topic(self, topic) -&gt; bytes:\n    \"\"\"prefixed topic for IOPub messages\"\"\"\n    return (f\"kernel.{topic}\").encode()\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.Kernel.unraisablehook","title":"unraisablehook","text":"<pre><code>unraisablehook(unraisable: UnraisableHookArgs) -&gt; None\n</code></pre> <p>Handle unraisable exceptions (during gc for instance).</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def unraisablehook(self, unraisable: sys.UnraisableHookArgs, /) -&gt; None:\n    \"Handle unraisable exceptions (during gc for instance).\"\n    exc_info = (\n        unraisable.exc_type,\n        unraisable.exc_value or unraisable.exc_type(unraisable.err_msg),\n        unraisable.exc_traceback,\n    )\n    self.log.exception(unraisable.err_msg, exc_info=exc_info, extra={\"object\": unraisable.object})\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.KernelInterruptError","title":"KernelInterruptError","text":"<p>Raised to interrupt the kernel.</p>"},{"location":"reference/kernel/#async_kernel.kernel.bind_socket","title":"bind_socket","text":"<pre><code>bind_socket(\n    socket: Socket[SocketType],\n    transport: Literal[\"tcp\", \"ipc\"],\n    ip: str,\n    port: int = 0,\n    max_attempts: int | NoValue = NoValue,\n) -&gt; int\n</code></pre> <p>Bind the socket to a port using the settings.</p> <p>max_attempts: The maximum number of attempts to bind the socket. If un-specified, defaults to 100 if port missing, else 2 attempts.</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def bind_socket(\n    socket: Socket[SocketType],\n    transport: Literal[\"tcp\", \"ipc\"],\n    ip: str,\n    port: int = 0,\n    max_attempts: int | NoValue = NoValue,  # pyright: ignore[reportInvalidTypeForm]\n) -&gt; int:\n    \"\"\"Bind the socket to a port using the settings.\n\n    max_attempts: The maximum number of attempts to bind the socket. If un-specified,\n    defaults to 100 if port missing, else 2 attempts.\n    \"\"\"\n\n    def _try_bind_socket(port: int):\n        if transport == \"tcp\":\n            if not port:\n                port = socket.bind_to_random_port(f\"tcp://{ip}\")\n            else:\n                socket.bind(f\"tcp://{ip}:{port}\")\n        elif transport == \"ipc\":\n            if not port:\n                port = 1\n                while True:\n                    port = port + 1\n                    path = f\"{ip}-{port}\"\n                    if not Path(path).exists():\n                        break\n            else:\n                path = f\"{ip}-{port}\"\n            socket.bind(f\"ipc://{path}\")\n        return port\n\n    if transport == \"ipc\":\n        ip = Path(ip).as_posix()\n    if socket.TYPE == SocketType.ROUTER:\n        # ref: https://github.com/ipython/ipykernel/issues/270\n        socket.router_handover = 1\n    try:\n        win_in_use = errno.WSAEADDRINUSE  # type: ignore[attr-defined]\n    except AttributeError:\n        win_in_use = None\n    # Try up to 100 times to bind a port when in conflict to avoid\n    # infinite attempts in bad setups\n    if max_attempts is NoValue:\n        max_attempts = 2 if port else 100\n    e = None\n    for _ in range(max_attempts):\n        try:\n            return _try_bind_socket(port)\n        except ZMQError as e_:\n            # Raise if we have any error not related to socket binding\n            # 135: Protocol not supported\n            if e_.errno in {errno.EADDRINUSE, win_in_use, 135}:\n                e = e_\n                break\n            if port:\n                time.sleep(1)\n    msg = f\"Failed to bind {socket} for {transport=}\" + (f\" to {port=}!\" if port else \"!\")\n    raise RuntimeError(msg) from e\n</code></pre>"},{"location":"reference/kernel/#async_kernel.kernel.error_to_content","title":"error_to_content","text":"<pre><code>error_to_content(error: BaseException) -&gt; Content\n</code></pre> <p>Convert the error to a dict.</p> <p>ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#request-reply</p> Source code in <code>src/async_kernel/kernel.py</code> <pre><code>def error_to_content(error: BaseException, /) -&gt; Content:\n    \"\"\"Convert the error to a dict.\n\n    ref: https://jupyter-client.readthedocs.io/en/stable/messaging.html#request-reply\n    \"\"\"\n    return {\n        \"status\": \"error\",\n        \"ename\": type(error).__name__,\n        \"evalue\": str(error),\n        \"traceback\": traceback.format_exception(error),\n    }\n</code></pre>"},{"location":"reference/typing/","title":"Typing","text":""},{"location":"reference/typing/#async_kernel.typing","title":"async_kernel.typing","text":"<p>Classes:</p> <ul> <li> <code>Job</code>           \u2013            <p>An async_kernel.typing.Message bundled with sockit_id, socket and ident.</p> </li> <li> <code>KernelConcurrencyMode</code>           \u2013            </li> <li> <code>Message</code>           \u2013            <p>A message.</p> </li> <li> <code>MetadataKeys</code>           \u2013            <p>This is an enum of keys for metadata in kernel messages</p> </li> <li> <code>MsgHeader</code>           \u2013            <p>A message header.</p> </li> <li> <code>MsgType</code>           \u2013            <p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> </li> <li> <code>RunMode</code>           \u2013            <p>An Enum of the kernel run modes available for</p> </li> <li> <code>SocketID</code>           \u2013            <p>Mapping of <code>Kernel.port_&lt;id&gt;</code> for sockets. Ref.</p> </li> <li> <code>Tags</code>           \u2013            <p>Tags recognised by the kernel.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent","title":"ExecuteContent","text":"<p>Ref.  see also: Message</p> <p>Attributes:</p> <ul> <li> <code>allow_stdin</code>               (<code>bool</code>)           \u2013            </li> <li> <code>code</code>               (<code>str</code>)           \u2013            <p>The code to execute.</p> </li> <li> <code>silent</code>               (<code>bool</code>)           \u2013            </li> <li> <code>stop_on_error</code>               (<code>bool</code>)           \u2013            </li> <li> <code>store_history</code>               (<code>bool</code>)           \u2013            </li> <li> <code>user_expressions</code>               (<code>dict[str, str]</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.allow_stdin","title":"allow_stdin  <code>instance-attribute</code>","text":"<pre><code>allow_stdin: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>The code to execute.</p>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.silent","title":"silent  <code>instance-attribute</code>","text":"<pre><code>silent: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.stop_on_error","title":"stop_on_error  <code>instance-attribute</code>","text":"<pre><code>stop_on_error: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.store_history","title":"store_history  <code>instance-attribute</code>","text":"<pre><code>store_history: bool\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.ExecuteContent.user_expressions","title":"user_expressions  <code>instance-attribute</code>","text":"<pre><code>user_expressions: dict[str, str]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job","title":"Job","text":"<p>An async_kernel.typing.Message bundled with sockit_id, socket and ident.</p> <p>Attributes:</p> <ul> <li> <code>ident</code>               (<code>bytes | list[bytes]</code>)           \u2013            </li> <li> <code>msg</code>               (<code>Message[T]</code>)           \u2013            </li> <li> <code>received_time</code>               (<code>float</code>)           \u2013            <p>The time the message was received.</p> </li> <li> <code>run_mode</code>               (<code>RunMode</code>)           \u2013            <p>The run mode.</p> </li> <li> <code>socket</code>               (<code>Socket</code>)           \u2013            </li> <li> <code>socket_id</code>               (<code>Literal[control, shell]</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Job.ident","title":"ident  <code>instance-attribute</code>","text":"<pre><code>ident: bytes | list[bytes]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: Message[T]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.received_time","title":"received_time  <code>instance-attribute</code>","text":"<pre><code>received_time: float\n</code></pre> <p>The time the message was received.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.run_mode","title":"run_mode  <code>instance-attribute</code>","text":"<pre><code>run_mode: RunMode\n</code></pre> <p>The run mode.</p>"},{"location":"reference/typing/#async_kernel.typing.Job.socket","title":"socket  <code>instance-attribute</code>","text":"<pre><code>socket: Socket\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Job.socket_id","title":"socket_id  <code>instance-attribute</code>","text":"<pre><code>socket_id: Literal[control, shell]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.KernelConcurrencyMode","title":"KernelConcurrencyMode","text":"<p>Attributes:</p> <ul> <li> <code>blocking</code>           \u2013            <p>All handlers are run with the blocking.</p> </li> <li> <code>default</code>           \u2013            <p>The default concurrency mode</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.KernelConcurrencyMode.blocking","title":"blocking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocking = 'blocking'\n</code></pre> <p>All handlers are run with the blocking.</p>"},{"location":"reference/typing/#async_kernel.typing.KernelConcurrencyMode.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default = 'default'\n</code></pre> <p>The default concurrency mode</p>"},{"location":"reference/typing/#async_kernel.typing.Message","title":"Message","text":"<p>A message.</p> <p>Attributes:</p> <ul> <li> <code>buffers</code>               (<code>list[bytearray | bytes]</code>)           \u2013            </li> <li> <code>content</code>               (<code>T | Content</code>)           \u2013            <p>ref</p> </li> <li> <code>header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> <li> <code>metadata</code>               (<code>Mapping[MetadataKeys | str, Any]</code>)           \u2013            <p>ref</p> </li> <li> <code>parent_header</code>               (<code>MsgHeader</code>)           \u2013            <p>ref</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.buffers","title":"buffers  <code>instance-attribute</code>","text":"<pre><code>buffers: list[bytearray | bytes]\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Message.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: T | Content\n</code></pre> <p>ref</p> <p>See also:</p> <ul> <li>ExecuteContent</li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Message.header","title":"header  <code>instance-attribute</code>","text":"<pre><code>header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: Mapping[MetadataKeys | str, Any]\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.Message.parent_header","title":"parent_header  <code>instance-attribute</code>","text":"<pre><code>parent_header: MsgHeader\n</code></pre> <p>ref</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys","title":"MetadataKeys","text":"<p>This is an enum of keys for metadata in kernel messages that are used in async_kernel.</p> <p>Note</p> <p>Metadata can be edited in Jupyter lab \"Advanced tools\" and Tags can be added using \"common tools\" in the right side bar.</p> <p>Attributes:</p> <ul> <li> <code>suppress_error_message</code>           \u2013            <p>A message to print when the error has been suppressed using async_kernel.typing.Tags.suppress_error. </p> </li> <li> <code>tags</code>           \u2013            <p>The <code>tags</code> metadata key corresponds to is a list of strings. </p> </li> <li> <code>timeout</code>           \u2013            <p>The <code>timeout</code> metadata key is used to specify a timeout for execution of the code.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.suppress_error_message","title":"suppress_error_message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error_message = 'suppress-error-message'\n</code></pre> <p>A message to print when the error has been suppressed using async_kernel.typing.Tags.suppress_error. </p> Note <p>The default message is '\u26a0'.</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags = 'tags'\n</code></pre> <p>The <code>tags</code> metadata key corresponds to is a list of strings. </p> <p>The list can be edited by the user in a notebook. see also: Tags.</p>"},{"location":"reference/typing/#async_kernel.typing.MetadataKeys.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout = 'timeout'\n</code></pre> <p>The <code>timeout</code> metadata key is used to specify a timeout for execution of the code.</p> <p>The value should be a floating point value of the timeout in seconds.</p>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader","title":"MsgHeader","text":"<p>A message header.</p> <p>Attributes:</p> <ul> <li> <code>date</code>               (<code>str</code>)           \u2013            </li> <li> <code>msg_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>msg_type</code>               (<code>MsgType</code>)           \u2013            </li> <li> <code>session</code>               (<code>str</code>)           \u2013            </li> <li> <code>username</code>               (<code>str</code>)           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_id","title":"msg_id  <code>instance-attribute</code>","text":"<pre><code>msg_id: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.msg_type","title":"msg_type  <code>instance-attribute</code>","text":"<pre><code>msg_type: MsgType\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgHeader.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.MsgType","title":"MsgType","text":"<p>An enumeration of Message <code>msg_type</code> for shell and control messages.</p> <p>Some message types are on the control channel only.</p> <p>Attributes:</p> <ul> <li> <code>comm_close</code>           \u2013            <p>async_kernel.Kernel.comm_close</p> </li> <li> <code>comm_info_request</code>           \u2013            <p>async_kernel.Kernel.comm_info_request</p> </li> <li> <code>comm_msg</code>           \u2013            <p>async_kernel.Kernel.comm_msg</p> </li> <li> <code>comm_open</code>           \u2013            <p>async_kernel.Kernel.comm_open</p> </li> <li> <code>complete_request</code>           \u2013            <p>async_kernel.Kernel.complete_request</p> </li> <li> <code>debug_request</code>           \u2013            <p>async_kernel.Kernel.debug_request (control channel only)</p> </li> <li> <code>execute_request</code>           \u2013            <p>async_kernel.Kernel.execute_request</p> </li> <li> <code>history_request</code>           \u2013            <p>async_kernel.Kernel.history_request</p> </li> <li> <code>inspect_request</code>           \u2013            <p>async_kernel.Kernel.inspect_request</p> </li> <li> <code>interrupt_request</code>           \u2013            <p>async_kernel.Kernel.interrupt_request (control channel only)</p> </li> <li> <code>is_complete_request</code>           \u2013            <p>async_kernel.Kernel.is_complete_request</p> </li> <li> <code>kernel_info_request</code>           \u2013            <p>async_kernel.Kernel.kernel_info_request</p> </li> <li> <code>shutdown_request</code>           \u2013            <p>async_kernel.Kernel.shutdown_request (control channel only)</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_close","title":"comm_close  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_close = 'comm_close'\n</code></pre> <p>async_kernel.Kernel.comm_close</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_info_request","title":"comm_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_info_request = 'comm_info_request'\n</code></pre> <p>async_kernel.Kernel.comm_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_msg","title":"comm_msg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_msg = 'comm_msg'\n</code></pre> <p>async_kernel.Kernel.comm_msg</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.comm_open","title":"comm_open  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comm_open = 'comm_open'\n</code></pre> <p>async_kernel.Kernel.comm_open</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.complete_request","title":"complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>complete_request = 'complete_request'\n</code></pre> <p>async_kernel.Kernel.complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.debug_request","title":"debug_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_request = 'debug_request'\n</code></pre> <p>async_kernel.Kernel.debug_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.execute_request","title":"execute_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execute_request = 'execute_request'\n</code></pre> <p>async_kernel.Kernel.execute_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.history_request","title":"history_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_request = 'history_request'\n</code></pre> <p>async_kernel.Kernel.history_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.inspect_request","title":"inspect_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_request = 'inspect_request'\n</code></pre> <p>async_kernel.Kernel.inspect_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.interrupt_request","title":"interrupt_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupt_request = 'interrupt_request'\n</code></pre> <p>async_kernel.Kernel.interrupt_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.is_complete_request","title":"is_complete_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_complete_request = 'is_complete_request'\n</code></pre> <p>async_kernel.Kernel.is_complete_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.kernel_info_request","title":"kernel_info_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kernel_info_request = 'kernel_info_request'\n</code></pre> <p>async_kernel.Kernel.kernel_info_request</p>"},{"location":"reference/typing/#async_kernel.typing.MsgType.shutdown_request","title":"shutdown_request  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shutdown_request = 'shutdown_request'\n</code></pre> <p>async_kernel.Kernel.shutdown_request (control channel only)</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode","title":"RunMode","text":"<p>An Enum of the kernel run modes available for altering how message requests are run.</p> <p>String match options</p> <p>Each of these options will give a match.</p> <ul> <li><code>&lt;value&gt;</code></li> <li><code>&lt;##value&gt;</code></li> <li>'<code>RunMode.&lt;value&gt;</code>.</li> </ul> <p>special usage</p> <p>Run mode can be used in execute requests. Add it at the top line (or use the string equivalent \"##\") of a code cell. <p>Methods:</p> <ul> <li> <code>get_mode</code>             \u2013              <p>Get a RunMode from the code if it is found.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>blocking</code>           \u2013            <p>Run the handler directly as soon as it is received.</p> </li> <li> <code>queue</code>           \u2013            <p>The message for the handler is run sequentially with other messages that are queued.</p> </li> <li> <code>task</code>           \u2013            <p>The message for the handler are run concurrently in task (starting immediately).</p> </li> <li> <code>thread</code>           \u2013            <p>Messages for the handler are run concurrently in a thread (starting immediately).</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.RunMode.blocking","title":"blocking  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocking = 'blocking'\n</code></pre> <p>Run the handler directly as soon as it is received.</p> <p>Warning</p> <p>This mode blocks the message loop. </p> <p>Use this for short running messages that should be processed as soon as it is received.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue = 'queue'\n</code></pre> <p>The message for the handler is run sequentially with other messages that are queued.</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task = 'task'\n</code></pre> <p>The message for the handler are run concurrently in task (starting immediately).</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.thread","title":"thread  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>thread = 'thread'\n</code></pre> <p>Messages for the handler are run concurrently in a thread (starting immediately).</p>"},{"location":"reference/typing/#async_kernel.typing.RunMode.get_mode","title":"get_mode  <code>classmethod</code>","text":"<pre><code>get_mode(code: str) -&gt; RunMode | None\n</code></pre> <p>Get a RunMode from the code if it is found.</p> Source code in <code>src/async_kernel/typing.py</code> <pre><code>@classmethod\ndef get_mode(cls, code: str) -&gt; RunMode | None:\n    \"Get a RunMode from the code if it is found.\"\n    try:\n        if (code := code.strip().split(\"\\n\")[0].strip()).startswith(\"##\"):\n            return RunMode(code.removeprefix(\"##\"))\n        if code.startswith(\"RunMode.\"):\n            return RunMode(code.removeprefix(\"RunMode.\"))\n    except ValueError:\n        return None\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID","title":"SocketID","text":"<p>Mapping of <code>Kernel.port_&lt;id&gt;</code> for sockets. Ref.</p> <p>Attributes:</p> <ul> <li> <code>control</code>           \u2013            </li> <li> <code>heartbeat</code>           \u2013            </li> <li> <code>iopub</code>           \u2013            </li> <li> <code>shell</code>           \u2013            </li> <li> <code>stdin</code>           \u2013            </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.SocketID.control","title":"control  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>control = 'control'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.heartbeat","title":"heartbeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>heartbeat = 'hb'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.iopub","title":"iopub  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iopub = 'iopub'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell = 'shell'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.SocketID.stdin","title":"stdin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stdin = 'stdin'\n</code></pre>"},{"location":"reference/typing/#async_kernel.typing.Tags","title":"Tags","text":"<p>Tags recognised by the kernel.</p> Info <p>Tags are can be added per cell.</p> <ul> <li>Jupyter: via the right side bar.</li> <li>VScode: via Jupyter variables explorer/</li> </ul> <p>Attributes:</p> <ul> <li> <code>suppress_error</code>           \u2013            <p>Suppress exceptions that occur during execution of the code cell.</p> </li> </ul>"},{"location":"reference/typing/#async_kernel.typing.Tags.suppress_error","title":"suppress_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_error = 'suppress-error'\n</code></pre> <p>Suppress exceptions that occur during execution of the code cell.</p> <p>Warning</p> <p>The code block will return as 'ok' and there will be no message recorded.</p>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#async_kernel.utils","title":"async_kernel.utils","text":"<p>Functions:</p> <ul> <li> <code>do_not_debug_this_thread</code>             \u2013              <p>A context to mark the thread for debugpy to not debug.</p> </li> <li> <code>get_execute_request_timeout</code>             \u2013              <p>Gets the execute_request_timeout for the current context.</p> </li> <li> <code>get_execution_count</code>             \u2013              <p>Gets the execution count for the current context, defaults to the current kernel count.</p> </li> <li> <code>get_job</code>             \u2013              <p>Get the job for the current context.</p> </li> <li> <code>get_metadata</code>             \u2013              <p>Gets metadata for the current context.</p> </li> <li> <code>get_parent</code>             \u2013              <p>Get the parent message for the current context.</p> </li> <li> <code>get_tags</code>             \u2013              <p>Gets the tags for the current context.</p> </li> <li> <code>mark_thread_pydev_do_not_trace</code>             \u2013              <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> </li> <li> <code>wait_thread_event</code>             \u2013              <p>Wait for the threading event using an anyio worker thread.</p> </li> </ul>"},{"location":"reference/utils/#async_kernel.utils.do_not_debug_this_thread","title":"do_not_debug_this_thread","text":"<pre><code>do_not_debug_this_thread(name='')\n</code></pre> <p>A context to mark the thread for debugpy to not debug.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>@contextlib.contextmanager\ndef do_not_debug_this_thread(name=\"\"):\n    \"A context to mark the thread for debugpy to not debug.\"\n    if not LAUNCHED_BY_DEBUGPY:\n        mark_thread_pydev_do_not_trace(threading.current_thread(), name)\n    try:\n        yield\n    finally:\n        if not LAUNCHED_BY_DEBUGPY:\n            mark_thread_pydev_do_not_trace(threading.current_thread(), remove=True)\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execute_request_timeout","title":"get_execute_request_timeout","text":"<pre><code>get_execute_request_timeout(job: Job | None = None) -&gt; float | None\n</code></pre> <p>Gets the execute_request_timeout for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execute_request_timeout(job: Job | None = None, /) -&gt; float | None:\n    \"Gets the execute_request_timeout for the current context.\"\n    try:\n        if timeout := get_metadata(job).get(MetadataKeys.timeout):\n            return float(timeout)\n        return get_kernel().shell.execute_request_timeout\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_execution_count","title":"get_execution_count","text":"<pre><code>get_execution_count() -&gt; int\n</code></pre> <p>Gets the execution count for the current context, defaults to the current kernel count.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_execution_count() -&gt; int:\n    \"Gets the execution count for the current context, defaults to the current kernel count.\"\n\n    return _execution_count_var.get(None) or async_kernel.Kernel()._execution_count  # pyright: ignore[reportPrivateUsage]\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_job","title":"get_job","text":"<pre><code>get_job() -&gt; Job[dict] | dict\n</code></pre> <p>Get the job for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_job() -&gt; Job[dict] | dict:\n    \"Get the job for the current context.\"\n    try:\n        return _job_var.get()\n    except Exception:\n        return {}\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_kernel","title":"get_kernel","text":"<pre><code>get_kernel() -&gt; Kernel\n</code></pre> <p>Get the current kernel.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_kernel() -&gt; Kernel:\n    \"Get the current kernel.\"\n    return async_kernel.Kernel()\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(job: Job | None = None) -&gt; Mapping[str, Any]\n</code></pre> <p>Gets metadata for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_metadata(job: Job | None = None, /) -&gt; Mapping[str, Any]:\n    \"Gets [metadata]() for the current context.\"\n    return (job or get_job()).get(\"msg\", {}).get(\"metadata\", {})\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_parent","title":"get_parent","text":"<pre><code>get_parent(job: Job | None = None) -&gt; Message[dict[str, Any]] | None\n</code></pre> <p>Get the parent message for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_parent(job: Job | None = None, /) -&gt; Message[dict[str, Any]] | None:\n    \"Get the [parent message]() for the current context.\"\n    return (job or get_job()).get(\"msg\")\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.get_tags","title":"get_tags","text":"<pre><code>get_tags(job: Job | None = None) -&gt; list[str]\n</code></pre> <p>Gets the tags for the current context.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def get_tags(job: Job | None = None, /) -&gt; list[str]:\n    \"Gets the [tags]() for the current context.\"\n    return get_metadata(job).get(\"tags\", [])\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.mark_thread_pydev_do_not_trace","title":"mark_thread_pydev_do_not_trace","text":"<pre><code>mark_thread_pydev_do_not_trace(thread: Thread, name='', *, remove=False)\n</code></pre> <p>Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>def mark_thread_pydev_do_not_trace(thread: threading.Thread, name=\"\", *, remove=False):\n    \"\"\"Modifies the given thread's attributes to hide or unhide it from the debugger (e.g., debugpy).\"\"\"\n    thread.pydev_do_not_trace = not remove  # pyright: ignore[reportAttributeAccessIssue]\n    if name:\n        thread.name = name\n</code></pre>"},{"location":"reference/utils/#async_kernel.utils.wait_thread_event","title":"wait_thread_event  <code>async</code>","text":"<pre><code>wait_thread_event(event: Event)\n</code></pre> <p>Wait for the threading event using an anyio worker thread.</p> <p>The event will be set event if the coroutine is cancelled to ensure the thread is cleared.</p> Source code in <code>src/async_kernel/utils.py</code> <pre><code>async def wait_thread_event(event: threading.Event):\n    \"\"\"Wait for the threading event using an anyio worker thread.\n\n    The event will be set event if the coroutine is cancelled to ensure the thread is cleared.\n    \"\"\"\n\n    def _in_thread_call():\n        with do_not_debug_this_thread():\n            event.wait()\n\n    try:\n        await anyio.to_thread.run_sync(_in_thread_call)\n    finally:\n        event.set()\n</code></pre>"}]}